"use strict";
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const vue = require("vue");
function default2(n2) {
  return { all: n2 = n2 || /* @__PURE__ */ new Map(), on: function(t2, e) {
    var i = n2.get(t2);
    i ? i.push(e) : n2.set(t2, [e]);
  }, off: function(t2, e) {
    var i = n2.get(t2);
    i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n2.set(t2, []));
  }, emit: function(t2, e) {
    var i = n2.get(t2);
    i && i.slice().map(function(n3) {
      n3(e);
    }), (i = n2.get("*")) && i.slice().map(function(n3) {
      n3(t2, e);
    });
  } };
}
const mitt_star = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: default2
}, Symbol.toStringTag, { value: "Module" }));
var __defProp$B = Object.defineProperty;
var __defProps$e = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs$e = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols$B = Object.getOwnPropertySymbols;
var __hasOwnProp$B = Object.prototype.hasOwnProperty;
var __propIsEnum$B = Object.prototype.propertyIsEnumerable;
var __defNormalProp$B = (obj, key3, value) => key3 in obj ? __defProp$B(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$B = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$B.call(b, prop))
      __defNormalProp$B(a, prop, b[prop]);
  if (__getOwnPropSymbols$B)
    for (var prop of __getOwnPropSymbols$B(b)) {
      if (__propIsEnum$B.call(b, prop))
        __defNormalProp$B(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$e = (a, b) => __defProps$e(a, __getOwnPropDescs$e(b));
var __export = (target, all) => {
  for (var name2 in all)
    __defProp$B(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key3 of __getOwnPropNames(from))
      if (!__hasOwnProp$B.call(to, key3) && key3 !== except)
        __defProp$B(to, key3, { get: () => from[key3], enumerable: !(desc = __getOwnPropDesc(from, key3)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod2, secondTarget) => (__copyProps(target, mod2, "default"), secondTarget);
var src_exports = {};
__export(src_exports, {
  NOOP: () => NOOP,
  assert: () => assert$1,
  at: () => at,
  baseRound: () => baseRound,
  call: () => call,
  camelize: () => camelize,
  cancelAnimationFrame: () => cancelAnimationFrame,
  ceil: () => ceil$1,
  chunk: () => chunk,
  clamp: () => clamp$1,
  clampArrayRange: () => clampArrayRange,
  classes: () => classes$1d,
  cloneDeep: () => cloneDeep,
  cloneDeepWith: () => cloneDeepWith,
  copyText: () => copyText,
  createNamespaceFn: () => createNamespaceFn,
  createStorage: () => createStorage,
  debounce: () => debounce$1,
  delay: () => delay,
  difference: () => difference,
  differenceWith: () => differenceWith,
  doubleRaf: () => doubleRaf,
  download: () => download,
  ensurePrefix: () => ensurePrefix,
  ensureSuffix: () => ensureSuffix,
  find: () => find,
  floor: () => floor$1,
  genNumberKey: () => genNumberKey,
  genStringKey: () => genStringKey,
  getAllParentScroller: () => getAllParentScroller$1,
  getGlobalThis: () => getGlobalThis,
  getParentScroller: () => getParentScroller$1,
  getRect: () => getRect,
  getScrollLeft: () => getScrollLeft,
  getScrollTop: () => getScrollTop,
  getStyle: () => getStyle$1,
  groupBy: () => groupBy,
  hasOwn: () => hasOwn,
  inBrowser: () => inBrowser,
  inMobile: () => inMobile,
  inViewport: () => inViewport,
  intersection: () => intersection,
  intersectionWith: () => intersectionWith,
  isArray: () => isArray,
  isArrayBuffer: () => isArrayBuffer,
  isBlob: () => isBlob,
  isBoolean: () => isBoolean,
  isDOMException: () => isDOMException,
  isDataView: () => isDataView,
  isDate: () => isDate,
  isEmpty: () => isEmpty,
  isEmptyPlainObject: () => isEmptyPlainObject,
  isEqual: () => isEqual,
  isEqualWith: () => isEqualWith,
  isError: () => isError,
  isFile: () => isFile,
  isFunction: () => isFunction,
  isMap: () => isMap,
  isNonEmptyArray: () => isNonEmptyArray,
  isNullish: () => isNullish,
  isNumber: () => isNumber,
  isNumeric: () => isNumeric,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  isPrimitive: () => isPrimitive,
  isPromise: () => isPromise,
  isRegExp: () => isRegExp,
  isSet: () => isSet,
  isString: () => isString,
  isSymbol: () => isSymbol,
  isTruthy: () => isTruthy,
  isTypedArray: () => isTypedArray,
  isWeakMap: () => isWeakMap,
  isWeakSet: () => isWeakSet,
  isWindow: () => isWindow,
  kebabCase: () => kebabCase,
  localStorage: () => localStorage,
  lowerFirst: () => lowerFirst,
  mapObject: () => mapObject,
  maxBy: () => maxBy,
  mean: () => mean,
  meanBy: () => meanBy,
  merge: () => merge$1,
  mergeWith: () => mergeWith,
  minBy: () => minBy,
  mitt: () => default2,
  motion: () => motion,
  normalizeToArray: () => normalizeToArray,
  objectToString: () => objectToString,
  omit: () => omit,
  omitBy: () => omitBy,
  once: () => once,
  pascalCase: () => pascalCase,
  pick: () => pick,
  pickBy: () => pickBy,
  prettyJSONObject: () => prettyJSONObject,
  preventDefault: () => preventDefault,
  promiseWithResolvers: () => promiseWithResolvers,
  raf: () => raf,
  randomColor: () => randomColor,
  randomNumber: () => randomNumber,
  randomString: () => randomString,
  removeArrayBlank: () => removeArrayBlank,
  removeArrayEmpty: () => removeArrayEmpty,
  removeItem: () => removeItem,
  requestAnimationFrame: () => requestAnimationFrame$1,
  round: () => round$2,
  sample: () => sample,
  sessionStorage: () => sessionStorage,
  shuffle: () => shuffle,
  slash: () => slash,
  sum: () => sum$1,
  sumBy: () => sumBy,
  sumHash: () => sumHash,
  supportTouch: () => supportTouch,
  throttle: () => throttle,
  times: () => times,
  toArrayBuffer: () => toArrayBuffer,
  toDataURL: () => toDataURL,
  toNumber: () => toNumber,
  toRawType: () => toRawType,
  toText: () => toText,
  toTypeString: () => toTypeString,
  toggleItem: () => toggleItem,
  tryParseJSON: () => tryParseJSON,
  uniq: () => uniq,
  uniqBy: () => uniqBy,
  upperFirst: () => upperFirst,
  xor: () => xor,
  xorWith: () => xorWith
});
function at(arr, index) {
  if (!arr.length) {
    return;
  }
  if (index < 0) {
    index += arr.length;
  }
  return arr[index];
}
function clamp$1(num, min2, max2) {
  return Math.min(max2, Math.max(min2, num));
}
function clampArrayRange(index, arr) {
  return clamp$1(index, 0, arr.length - 1);
}
function delay(time) {
  return new Promise((resolve) => {
    setTimeout(resolve, time);
  });
}
function randomNumber(min2 = 0, max2 = 100) {
  return Math.floor(Math.random() * (max2 - min2 + 1)) + min2;
}
function times(num, fn2) {
  return Array.from({ length: num }, (_, index) => fn2(index));
}
function inBrowser() {
  return typeof window !== "undefined";
}
function getGlobalThis() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (inBrowser()) {
    return window;
  }
  return typeof global !== "undefined" ? global : self;
}
var { hasOwnProperty } = Object.prototype;
function hasOwn(val, key3) {
  return hasOwnProperty.call(val, key3);
}
function inMobile() {
  return inBrowser() && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}
function isArray(val) {
  return Array.isArray(val);
}
var objectToString = Object.prototype.toString;
function toTypeString(value) {
  return objectToString.call(value);
}
function toRawType(value) {
  return toTypeString(value).slice(8, -1);
}
function isArrayBuffer(val) {
  return toRawType(val) === "ArrayBuffer";
}
function isBoolean(val) {
  return typeof val === "boolean";
}
function isDataView(val) {
  return toRawType(val) === "DataView";
}
function isDate(val) {
  return toRawType(val) === "Date";
}
function isDOMException(val) {
  return toRawType(val) === "DOMException";
}
function isEmpty(val) {
  return val === void 0 || val === null || val === "" || isArray(val) && !val.length;
}
function isMap(val) {
  return toRawType(val) === "Map";
}
function isPlainObject(val) {
  return toRawType(val) === "Object";
}
function isSet(val) {
  return toRawType(val) === "Set";
}
function isObject(val) {
  return typeof val === "object" && val !== null;
}
function isRegExp(val) {
  return toRawType(val) === "RegExp";
}
function isError(val) {
  return toRawType(val) === "Error";
}
function isTypedArray(val) {
  return [
    "Int8Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Int16Array",
    "Uint16Array",
    "Int32Array",
    "Uint32Array",
    "Float32Array",
    "Float64Array",
    "BigInt64Array",
    "BigUint64Array"
  ].includes(toRawType(val));
}
function isEqualWith(value, other, fn2) {
  const valueStack = /* @__PURE__ */ new WeakMap();
  const otherStack = /* @__PURE__ */ new WeakMap();
  function baseIsEqual(value2, other2, valueStack2, otherStack2) {
    const customEqual = fn2(value2, other2);
    if (customEqual === true) {
      return true;
    }
    if (value2 === other2) {
      return true;
    }
    if (value2 !== value2 && other2 !== other2) {
      return true;
    }
    if (!isObject(value2) || !isObject(other2)) {
      return value2 === other2;
    }
    if (value2.constructor !== other2.constructor) {
      return false;
    }
    if (toRawType(value2) === "String" && toRawType(other2) === "String" || toRawType(value2) === "Number" && toRawType(other2) === "Number" || toRawType(value2) === "Boolean" && toRawType(other2) === "Boolean" || toRawType(value2) === "BigInt" && toRawType(other2) === "BigInt" || toRawType(value2) === "Symbol" && toRawType(other2) === "Symbol") {
      return value2.valueOf() === other2.valueOf();
    }
    if (isDate(value2) && isDate(other2)) {
      return value2.getTime() === other2.getTime();
    }
    if (isRegExp(value2) && isRegExp(other2)) {
      return value2.source === other2.source && value2.flags === other2.flags;
    }
    if (isError(value2) && isError(other2)) {
      return value2.name === other2.name && value2.message === other2.message && value2.cause === other2.cause;
    }
    if (isDOMException(value2) && isDOMException(other2)) {
      return value2.name === other2.name && value2.message === other2.message;
    }
    if (isTypedArray(value2) && isTypedArray(other2) || isDataView(value2) && isDataView(other2)) {
      if (value2.byteLength !== other2.byteLength) {
        return false;
      }
      const valueTypedArray = new Uint8Array(value2.buffer);
      const otherTypedArray = new Uint8Array(other2.buffer);
      return valueTypedArray.every((v, i) => v === otherTypedArray[i]);
    }
    if (isArrayBuffer(value2) && isArrayBuffer(other2)) {
      if (value2.byteLength !== other2.byteLength) {
        return false;
      }
      const valueTypedArray = new Uint8Array(value2);
      const otherTypedArray = new Uint8Array(other2);
      return valueTypedArray.every((v, i) => v === otherTypedArray[i]);
    }
    if (valueStack2.get(value2) === other2 && otherStack2.get(other2) === value2) {
      return true;
    }
    valueStack2.set(value2, other2);
    otherStack2.set(other2, value2);
    if (isMap(value2) && isMap(other2) || isSet(value2) && isSet(other2)) {
      if (value2.size !== other2.size) {
        return false;
      }
      const valueArray = [...value2];
      const otherArray = [...other2];
      const result = valueArray.every((v, i) => baseIsEqual(v, otherArray[i], valueStack2, otherStack2));
      valueStack2.delete(value2);
      otherStack2.delete(other2);
      return result;
    }
    if (isArray(value2) && isArray(other2)) {
      if (value2.length !== other2.length) {
        return false;
      }
      const result = value2.every((v, i) => baseIsEqual(v, other2[i], valueStack2, otherStack2));
      valueStack2.delete(value2);
      otherStack2.delete(other2);
      return result;
    }
    if (isPlainObject(value2) && isPlainObject(other2)) {
      const valueOwnKeys = [...Object.keys(value2), ...Object.getOwnPropertySymbols(value2)];
      const otherOwnKeys = [...Object.keys(other2), ...Object.getOwnPropertySymbols(other2)];
      if (valueOwnKeys.length !== otherOwnKeys.length) {
        return false;
      }
      const result = valueOwnKeys.every(
        (k) => baseIsEqual(value2[k], other2[k], valueStack2, otherStack2)
      );
      valueStack2.delete(value2);
      otherStack2.delete(other2);
      return result;
    }
    return false;
  }
  return baseIsEqual(value, other, valueStack, otherStack);
}
function isEqual(value, other) {
  return isEqualWith(value, other, () => void 0);
}
function isFunction(val) {
  return typeof val === "function";
}
function isNonEmptyArray(val) {
  return isArray(val) && !!val.length;
}
function isNullish(val) {
  return val == null;
}
function isNumber(val) {
  return typeof val === "number";
}
function isString(val) {
  return typeof val === "string";
}
function isNumeric(val) {
  return isNumber(val) || isString(val) && /^[-+]?\d+$/.test(val);
}
function isPromise(val) {
  return isObject(val) && isFunction(val.then) && isFunction(val.catch);
}
function isSymbol(val) {
  return typeof val === "symbol";
}
function isTruthy(v) {
  return Boolean(v);
}
function isWeakMap(val) {
  return toRawType(val) === "WeakMap";
}
function isWeakSet(val) {
  return toRawType(val) === "WeakSet";
}
function isWindow(val) {
  return val === window;
}
function supportTouch() {
  return inBrowser() && "ontouchstart" in window;
}
function isFile(val) {
  return toRawType(val) === "File";
}
function isBlob(val) {
  return toRawType(val) === "Blob";
}
function isPrimitive(val) {
  return val == null || typeof val !== "object" && typeof val !== "function";
}
function isEmptyPlainObject(val) {
  return isPlainObject(val) && Object.keys(val).length === 0 && Object.getOwnPropertySymbols(val).length === 0;
}
function assert$1(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}
function toNumber(val) {
  if (val == null) {
    return 0;
  }
  if (isString(val)) {
    val = parseFloat(val);
    val = Number.isNaN(val) ? 0 : val;
    return val;
  }
  if (isBoolean(val)) {
    return Number(val);
  }
  return val;
}
var key = 0;
function genNumberKey() {
  return key++;
}
function chunk(arr, size = 1) {
  size = clamp$1(size, 1, arr.length);
  const result = [];
  let index = 0;
  while (index < arr.length) {
    result.push(arr.slice(index, index + size));
    index += size;
  }
  return result;
}
function removeItem(arr, item) {
  if (arr.length) {
    const index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}
function toggleItem(arr, item) {
  arr.includes(item) ? removeItem(arr, item) : arr.push(item);
  return arr;
}
function uniq(arr) {
  return [...new Set(arr)];
}
function uniqBy(arr, fn2) {
  return arr.reduce((ret, i) => {
    const index = ret.findIndex((j) => fn2(i, j));
    if (index === -1) {
      ret.push(i);
    }
    return ret;
  }, []);
}
function find(arr, fn2, from = "start") {
  let i = from === "start" ? 0 : arr.length - 1;
  while (arr.length > 0 && i >= 0 && i <= arr.length - 1) {
    const flag = fn2(arr[i], i, arr);
    if (flag) {
      return [arr[i], i];
    }
    from === "start" ? i++ : i--;
  }
  return [null, -1];
}
function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
function removeArrayBlank(arr) {
  return arr.filter((item) => item != null);
}
function removeArrayEmpty(arr) {
  return arr.filter((item) => item != null && item !== "");
}
function normalizeToArray(value) {
  return isArray(value) ? value : [value];
}
function differenceWith(arr, ...values) {
  const fn2 = at(values, -1);
  const targets = values.slice(0, -1).reduce((targets2, value) => [...targets2, ...value], []);
  return arr.filter((item) => !targets.some((value) => fn2(item, value)));
}
function difference(arr, ...values) {
  return differenceWith(arr, ...values, (a, b) => a === b);
}
function intersectionWith(...values) {
  const fn2 = at(values, -1);
  const targets = values.slice(0, -1);
  if (targets.length === 0) {
    return [];
  }
  if (targets.length === 1) {
    return uniqBy(targets[0], fn2);
  }
  function baseIntersectionWith(arr1, arr2) {
    return arr1.filter((item) => arr2.some((value) => fn2(item, value)));
  }
  return uniqBy(
    targets.reduce((result, target) => baseIntersectionWith(result, target)),
    fn2
  );
}
function intersection(...values) {
  return intersectionWith(...values, (a, b) => a === b);
}
function groupBy(arr, fn2) {
  return arr.reduce(
    (result, item) => {
      var _a;
      const key3 = fn2(item);
      ((_a = result[key3]) != null ? _a : result[key3] = []).push(item);
      return result;
    },
    {}
  );
}
function xorWith(...values) {
  const fn2 = at(values, -1);
  const targets = values.slice(0, -1);
  return uniqBy(
    targets.reduce((result, target) => {
      return [...differenceWith(result, target, fn2), ...differenceWith(target, result, fn2)];
    }),
    fn2
  );
}
function xor(...values) {
  return xorWith(...values, (a, b) => a === b);
}
function pick(object, keys) {
  return keys.reduce(
    (result, key3) => {
      result[key3] = object[key3];
      return result;
    },
    {}
  );
}
function pickBy(object, fn2) {
  const ownKeys = [...Object.keys(object), ...Object.getOwnPropertySymbols(object)];
  return ownKeys.reduce((result, key3) => {
    const value = object[key3];
    if (fn2(value, key3)) {
      result[key3] = value;
    }
    return result;
  }, {});
}
function omit(object, keys) {
  const ownKeys = [...Object.keys(object), ...Object.getOwnPropertySymbols(object)];
  return ownKeys.reduce(
    (result, key3) => {
      if (!keys.includes(key3)) {
        result[key3] = object[key3];
      }
      return result;
    },
    {}
  );
}
function omitBy(object, fn2) {
  const ownKeys = [...Object.keys(object), ...Object.getOwnPropertySymbols(object)];
  return ownKeys.reduce((result, key3) => {
    const value = object[key3];
    if (!fn2(value, key3)) {
      result[key3] = value;
    }
    return result;
  }, {});
}
function mapObject(object, fn2) {
  return Object.entries(object).reduce(
    (result, [key3, value]) => {
      const entry = fn2(key3, value);
      if (isArray(entry)) {
        const [newKey, newValue] = entry;
        result[newKey] = newValue;
      }
      return result;
    },
    {}
  );
}
function promiseWithResolvers() {
  let resolve;
  let reject;
  const promise = new Promise((_resolver, _reject) => {
    resolve = _resolver;
    reject = _reject;
  });
  return { promise, resolve, reject };
}
var util_exports = {};
__export(util_exports, {
  cancelAnimationFrame: () => cancelAnimationFrame,
  classes: () => classes$1d,
  copyText: () => copyText,
  createNamespaceFn: () => createNamespaceFn,
  createStorage: () => createStorage,
  doubleRaf: () => doubleRaf,
  download: () => download,
  getAllParentScroller: () => getAllParentScroller$1,
  getParentScroller: () => getParentScroller$1,
  getRect: () => getRect,
  getScrollLeft: () => getScrollLeft,
  getScrollTop: () => getScrollTop,
  getStyle: () => getStyle$1,
  inViewport: () => inViewport,
  localStorage: () => localStorage,
  mitt: () => default2,
  motion: () => motion,
  prettyJSONObject: () => prettyJSONObject,
  preventDefault: () => preventDefault,
  raf: () => raf,
  requestAnimationFrame: () => requestAnimationFrame$1,
  sessionStorage: () => sessionStorage,
  tryParseJSON: () => tryParseJSON
});
function cancelAnimationFrame(handle) {
  const globalThis2 = getGlobalThis();
  globalThis2.cancelAnimationFrame ? globalThis2.cancelAnimationFrame(handle) : globalThis2.clearTimeout(handle);
}
function classes$1d(...classes2) {
  return classes2.map((className) => {
    if (isArray(className)) {
      const [condition, truthy, falsy = null] = className;
      return condition ? truthy : falsy;
    }
    return className;
  });
}
function copyText(value) {
  if (!value) {
    return;
  }
  const textArea = document.createElement("textarea");
  textArea.value = value;
  textArea.style.position = "fixed";
  textArea.style.opacity = "0";
  document.body.appendChild(textArea);
  textArea.select();
  document.execCommand("copy");
  document.body.removeChild(textArea);
}
function camelize(s) {
  s = s.replace(/-(\w)/g, (_, p) => p.toUpperCase());
  return s.replace(s.charAt(0), s.charAt(0).toLowerCase());
}
function ensurePrefix(s, prefix) {
  return s.startsWith(prefix) ? s : prefix + s;
}
function ensureSuffix(s, suffix) {
  return s.endsWith(suffix) ? s : s + suffix;
}
var key2 = 0;
function genStringKey() {
  return `generated-key-${key2++}`;
}
function kebabCase(s) {
  const ret = s.replace(/([A-Z])/g, " $1").trim();
  return ret.split(" ").join("-").toLowerCase();
}
function pascalCase(s) {
  return camelize(s).replace(s.charAt(0), s.charAt(0).toUpperCase());
}
function lowerFirst(s) {
  return s.charAt(0).toLowerCase() + s.slice(1);
}
function upperFirst(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}
function randomColor() {
  const letters = "0123456789abcdef";
  let color = "#";
  for (let i = 0; i < 6; i++) {
    color += letters[Math.floor(Math.random() * 16)];
  }
  return color;
}
function randomString(length = 10) {
  let str = baseRandomString();
  while (str.length < length) {
    str += baseRandomString();
  }
  function baseRandomString() {
    return Math.random().toString(36).slice(2);
  }
  return str.slice(0, length);
}
function slash(path) {
  const isExtendedLengthPath = path.startsWith("\\\\?\\");
  if (isExtendedLengthPath) {
    return path;
  }
  return path.replace(/\\/g, "/");
}
function createNamespaceFn(namespace) {
  return (name2) => {
    const componentName = `${namespace}-${name2}`;
    const createBEM = (suffix) => {
      if (!suffix) {
        return componentName;
      }
      if (suffix[0] === "$") {
        return suffix.replace("$", namespace);
      }
      return suffix.startsWith("--") ? `${componentName}${suffix}` : `${componentName}__${suffix}`;
    };
    return {
      name: pascalCase(componentName),
      n: createBEM,
      classes: classes$1d
    };
  };
}
function requestAnimationFrame$1(fn2) {
  const globalThis2 = getGlobalThis();
  return globalThis2.requestAnimationFrame ? globalThis2.requestAnimationFrame(fn2) : globalThis2.setTimeout(fn2);
}
function doubleRaf() {
  return new Promise((resolve) => {
    requestAnimationFrame$1(() => {
      requestAnimationFrame$1(resolve);
    });
  });
}
function getStyle$1(element) {
  return window.getComputedStyle(element);
}
function getParentScroller$1(el) {
  let element = el;
  while (element) {
    if (!element.parentNode) {
      break;
    }
    element = element.parentNode;
    if (element === document.body || element === document.documentElement) {
      break;
    }
    const scrollRE = /(scroll|auto)/;
    const { overflowY, overflow } = getStyle$1(element);
    if (scrollRE.test(overflowY) || scrollRE.test(overflow)) {
      return element;
    }
  }
  return window;
}
function getAllParentScroller$1(el) {
  const allParentScroller = [];
  let element = el;
  while (!isWindow(element)) {
    element = getParentScroller$1(element);
    allParentScroller.push(element);
  }
  return allParentScroller;
}
function getRect(element) {
  if (isWindow(element)) {
    const width = element.innerWidth;
    const height = element.innerHeight;
    const rect = {
      x: 0,
      y: 0,
      top: 0,
      left: 0,
      right: width,
      bottom: height,
      width,
      height
    };
    return __spreadProps$e(__spreadValues$B({}, rect), {
      toJSON: () => rect
    });
  }
  return element.getBoundingClientRect();
}
function getScrollLeft(element) {
  const left2 = "scrollLeft" in element ? element.scrollLeft : element.scrollX;
  return Math.max(left2, 0);
}
function getScrollTop(element) {
  const top2 = "scrollTop" in element ? element.scrollTop : element.scrollY;
  return Math.max(top2, 0);
}
function inViewport(element) {
  const { top: top2, bottom: bottom2, left: left2, right: right2 } = getRect(element);
  const { width, height } = getRect(window);
  const xInViewport = left2 <= width && right2 >= 0;
  const yInViewport = top2 <= height && bottom2 >= 0;
  return xInViewport && yInViewport;
}
function prettyJSONObject(jsonObject) {
  return JSON.stringify(jsonObject, null, 2);
}
function preventDefault(event) {
  if (event.cancelable === false) {
    return;
  }
  event.preventDefault();
}
function raf() {
  return new Promise((resolve) => {
    requestAnimationFrame$1(resolve);
  });
}
function createStorage(storage) {
  return __spreadProps$e(__spreadValues$B({}, storage), {
    set(key3, value) {
      if (value == null) {
        return;
      }
      if (!isString(value)) {
        value = JSON.stringify(value);
      }
      storage.setItem(key3, value);
    },
    get(key3) {
      const data = storage.getItem(key3);
      try {
        return JSON.parse(data);
      } catch (err) {
        return data;
      }
    },
    remove(key3) {
      storage.removeItem(key3);
    }
  });
}
var sessionStorage = createStorage(getGlobalThis().sessionStorage);
var localStorage = createStorage(getGlobalThis().localStorage);
function tryParseJSON(json) {
  try {
    return JSON.parse(json);
  } catch (e) {
    return void 0;
  }
}
function download(val, filename = "file") {
  const a = document.createElement("a");
  a.style.display = "none";
  a.href = isString(val) ? val : URL.createObjectURL(val);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  URL.revokeObjectURL(a.href);
  document.body.removeChild(a);
}
function motion(options) {
  const {
    from,
    to,
    duration = 300,
    frame = () => {
    },
    timingFunction = (value2) => value2,
    onStateChange = () => {
    }
  } = options;
  let state = "pending";
  let value = from;
  const distance = to - from;
  let ticker = void 0;
  let startTime = void 0;
  let pausedTime = void 0;
  let sleepTime = 0;
  function start2() {
    if (state === "running" || state === "finished") {
      return;
    }
    setState("running");
    const now = performance.now();
    startTime = startTime != null ? startTime : now;
    sleepTime += pausedTime != null ? now - pausedTime : 0;
    pausedTime = void 0;
    tick2();
    function tick2() {
      ticker = requestAnimationFrame$1(() => {
        const now2 = performance.now();
        const executionTime = now2 - startTime - sleepTime;
        const progress = clamp$1(executionTime / duration, 0, 1);
        value = distance * timingFunction(progress) + from;
        if (progress >= 1) {
          setState("finished");
          frame({ value: to, done: true });
          return;
        }
        frame({ value, done: false });
        tick2();
      });
    }
  }
  function pause() {
    if (state !== "running") {
      return;
    }
    cancelAnimationFrame(ticker);
    setState("paused");
    pausedTime = performance.now();
  }
  function reset() {
    cancelAnimationFrame(ticker);
    setState("pending");
    value = from;
    ticker = void 0;
    startTime = void 0;
    pausedTime = void 0;
    sleepTime = 0;
  }
  function getState() {
    return state;
  }
  function setState(_state) {
    state = _state;
    onStateChange(_state);
  }
  return {
    start: start2,
    pause,
    reset,
    getState
  };
}
__reExport(util_exports, mitt_star);
__reExport(src_exports, util_exports);
function call(fn2, ...args) {
  if (isArray(fn2)) {
    return fn2.map((f) => f(...args));
  }
  if (fn2) {
    return fn2(...args);
  }
}
function once(fn2) {
  let called = false;
  let result;
  return function(...args) {
    if (called) {
      return result;
    }
    called = true;
    result = fn2.apply(this, args);
    return result;
  };
}
function debounce$1(fn2, delay2 = 0) {
  let timer;
  return function(...args) {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => {
      fn2.apply(this, args);
    }, delay2);
  };
}
function throttle(fn2, delay2 = 200) {
  let timer;
  let start2 = 0;
  return function loop(...args) {
    const now = performance.now();
    const elapsed = now - start2;
    if (!start2) {
      start2 = now;
    }
    if (timer) {
      clearTimeout(timer);
    }
    if (elapsed >= delay2) {
      fn2.apply(this, args);
      start2 = now;
    } else {
      timer = setTimeout(() => {
        loop.apply(this, args);
      }, delay2 - elapsed);
    }
  };
}
function NOOP() {
}
function cloneDeepWith(value, fn2) {
  const cache = /* @__PURE__ */ new WeakMap();
  function baseCloneDeep(value2, cache2) {
    const customResult = fn2(value2);
    if (customResult !== void 0) {
      return customResult;
    }
    if (!isObject(value2)) {
      return value2;
    }
    if (cache2.has(value2)) {
      return cache2.get(value2);
    }
    if (isDate(value2)) {
      return new Date(value2);
    }
    if (isRegExp(value2)) {
      return new RegExp(value2);
    }
    if (isMap(value2)) {
      const result = /* @__PURE__ */ new Map();
      cache2.set(value2, result);
      value2.forEach((val, key3) => {
        result.set(baseCloneDeep(key3, cache2), baseCloneDeep(val, cache2));
      });
      return result;
    }
    if (isSet(value2)) {
      const result = /* @__PURE__ */ new Set();
      cache2.set(value2, result);
      value2.forEach((val) => {
        result.add(baseCloneDeep(val, cache2));
      });
      return result;
    }
    if (toRawType(value2) === "String" || toRawType(value2) === "Number" || toRawType(value2) === "Boolean") {
      return newConstructor(value2, value2.valueOf());
    }
    if (isWeakMap(value2) || isWeakSet(value2) || isError(value2) || isDOMException(value2)) {
      return {};
    }
    if (isTypedArray(value2)) {
      return newConstructor(value2, baseCloneArrayBuffer(value2.buffer), value2.byteOffset, value2.length);
    }
    if (isDataView(value2)) {
      return newConstructor(value2, baseCloneArrayBuffer(value2.buffer), value2.byteOffset, value2.byteLength);
    }
    if (isArrayBuffer(value2)) {
      return baseCloneArrayBuffer(value2);
    }
    if (isArray(value2)) {
      const result = [];
      cache2.set(value2, result);
      value2.forEach((value3, index) => {
        result[index] = baseCloneDeep(value3, cache2);
      });
      return result;
    }
    if (isPlainObject(value2)) {
      const result = Object.create(Reflect.getPrototypeOf(value2));
      cache2.set(value2, result);
      const ownKeys = [...Object.keys(value2), ...Object.getOwnPropertySymbols(value2)];
      ownKeys.forEach((key3) => {
        result[key3] = baseCloneDeep(value2[key3], cache2);
      });
      return result;
    }
    return value2;
  }
  function baseCloneArrayBuffer(value2) {
    const result = new ArrayBuffer(value2.byteLength);
    new Uint8Array(result).set(new Uint8Array(value2));
    return result;
  }
  function newConstructor(value2, ...args) {
    return new value2.constructor(...args);
  }
  return baseCloneDeep(value, cache);
}
function cloneDeep(value) {
  return cloneDeepWith(value, () => void 0);
}
function mergeWith(object, ...sources) {
  const fn2 = at(sources, -1);
  const targets = [object, ...sources.slice(0, -1)];
  let len = targets.length - 1;
  let result = targets[len];
  while (len) {
    result = baseMergeWith(targets[len - 1], result, fn2);
    len--;
  }
  function baseMergeWith(object2, source, fn22) {
    function baseMerge(target, src) {
      for (const key3 in src) {
        if (hasOwn(src, key3)) {
          const srcValue = src[key3];
          const targetValue = target[key3];
          const customResult = fn22(targetValue, srcValue, key3, object2, source);
          if (customResult !== void 0) {
            target[key3] = customResult;
          } else if (isObject(srcValue)) {
            if (isObject(targetValue)) {
              target[key3] = baseMerge(targetValue, srcValue);
            } else {
              target[key3] = baseMerge(isArray(srcValue) ? [] : {}, srcValue);
            }
          } else {
            target[key3] = srcValue;
          }
        }
      }
      return target;
    }
    return baseMerge(object2, source);
  }
  return result;
}
function merge$1(object, ...sources) {
  return mergeWith(object, ...sources, () => void 0);
}
function toArrayBuffer(file) {
  return new Promise((resolve) => {
    const fileReader = new FileReader();
    fileReader.onload = () => {
      resolve(fileReader.result);
    };
    fileReader.readAsArrayBuffer(file);
  });
}
function toDataURL(file) {
  return new Promise((resolve) => {
    const fileReader = new FileReader();
    fileReader.onload = () => {
      resolve(fileReader.result);
    };
    fileReader.readAsDataURL(file);
  });
}
function toText(file) {
  return new Promise((resolve) => {
    const fileReader = new FileReader();
    fileReader.onload = () => {
      resolve(fileReader.result);
    };
    fileReader.readAsText(file);
  });
}
function maxBy(arr, fn2) {
  if (!arr.length) {
    return;
  }
  return arr.reduce((result, item) => fn2(result) > fn2(item) ? result : item, arr[0]);
}
function minBy(arr, fn2) {
  if (!arr.length) {
    return;
  }
  return arr.reduce((result, item) => fn2(result) < fn2(item) ? result : item, arr[0]);
}
function sum$1(arr) {
  return arr.reduce((ret, val) => ret + val, 0);
}
function sumBy(arr, fn2) {
  return arr.reduce((ret, val) => ret + fn2(val), 0);
}
function sumHash(value) {
  function sum2(hash2, value2) {
    for (let i = 0; i < value2.length; i++) {
      const chr = value2.charCodeAt(i);
      hash2 = (hash2 << 5) - hash2 + chr;
      hash2 |= 0;
    }
    return hash2 < 0 ? hash2 * -2 : hash2;
  }
  function baseSumHash(hash2, value2, key3, seen) {
    hash2 = sum2(hash2, key3);
    hash2 = sum2(hash2, toTypeString(value2));
    hash2 = sum2(hash2, typeof value2);
    if (value2 === null) {
      return sum2(hash2, "null");
    }
    if (value2 === void 0) {
      return sum2(hash2, "undefined");
    }
    if (isObject(value2) || isFunction(value2)) {
      if (seen.includes(value2)) {
        return sum2(hash2, `[Circular]${key3}`);
      }
      seen.push(value2);
      hash2 = Object.keys(value2).sort().reduce((hash22, key4) => baseSumHash(hash22, value2[key4], key4, seen), hash2);
      if (isFunction(value2.valueOf)) {
        return sum2(hash2, String(value2.valueOf()));
      }
      return hash2;
    }
    return sum2(hash2, value2.toString());
  }
  return baseSumHash(0, value, "", []).toString(16).padStart(8, "0");
}
function mean(arr) {
  return sum$1(arr) / arr.length;
}
function meanBy(arr, fn2) {
  return sumBy(arr, fn2) / arr.length;
}
function sample(arr) {
  if (!arr.length) {
    return;
  }
  return arr[randomNumber(0, arr.length - 1)];
}
function round$2(val, precision = 0) {
  return baseRound(val, precision, Math.round);
}
function baseRound(val, precision = 0, fn2) {
  precision = clamp$1(precision, -292, 292);
  if (!precision) {
    return fn2(val);
  }
  const value = fn2(`${val}e${precision}`);
  return +`${value}e${-precision}`;
}
function floor$1(val, precision = 0) {
  return baseRound(val, precision, Math.floor);
}
function ceil$1(val, precision = 0) {
  return baseRound(val, precision, Math.ceil);
}
function assert(condition, source, message) {
  return assert$1(condition, `Varlet [${source}]: ${message}`);
}
function warn(source, message) {
  console.warn(`Varlet [${source}]: ${message}`);
}
function error$1(source, message) {
  console.error(`Varlet [${source}]: ${message}`);
}
var isURL = (val) => {
  if (!val) {
    return false;
  }
  return /^(http)|(\.*\/)/.test(val);
};
var __defProp$A = Object.defineProperty;
var __getOwnPropSymbols$A = Object.getOwnPropertySymbols;
var __hasOwnProp$A = Object.prototype.hasOwnProperty;
var __propIsEnum$A = Object.prototype.propertyIsEnumerable;
var __defNormalProp$A = (obj, key3, value) => key3 in obj ? __defProp$A(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$A = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$A.call(b, prop))
      __defNormalProp$A(a, prop, b[prop]);
  if (__getOwnPropSymbols$A)
    for (var prop of __getOwnPropSymbols$A(b)) {
      if (__propIsEnum$A.call(b, prop))
        __defNormalProp$A(a, prop, b[prop]);
    }
  return a;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$A.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$A)
    for (var prop of __getOwnPropSymbols$A(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$A.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function onSmartMounted(hook) {
  let isMounted = false;
  vue.onMounted(() => {
    hook();
    vue.nextTick(() => {
      isMounted = true;
    });
  });
  vue.onActivated(() => {
    if (!isMounted) {
      return;
    }
    hook();
  });
}
function useEventListener(target, type, listener, options = {}) {
  if (!inBrowser()) {
    return;
  }
  const { passive: passive2 = false, capture = false } = options;
  let listening = false;
  let cleaned = false;
  const getElement = (target2) => isFunction(target2) ? target2() : vue.unref(target2);
  const add2 = (target2) => {
    if (listening || cleaned) {
      return;
    }
    const element = getElement(target2);
    if (element) {
      element.addEventListener(type, listener, {
        passive: passive2,
        capture
      });
      listening = true;
    }
  };
  const remove = (target2) => {
    if (!listening || cleaned) {
      return;
    }
    const element = getElement(target2);
    if (element) {
      element.removeEventListener(type, listener, {
        capture
      });
      listening = false;
    }
  };
  let watchStopHandle;
  if (vue.isRef(target)) {
    watchStopHandle = vue.watch(
      () => target.value,
      (newValue, oldValue) => {
        remove(oldValue);
        add2(newValue);
      }
    );
  }
  const cleanup = () => {
    watchStopHandle == null ? void 0 : watchStopHandle();
    remove(target);
    cleaned = true;
  };
  onSmartMounted(() => {
    add2(target);
  });
  vue.onBeforeUnmount(() => {
    remove(target);
  });
  vue.onDeactivated(() => {
    remove(target);
  });
  return cleanup;
}
function useClickOutside(target, type, listener) {
  if (!inBrowser()) {
    return;
  }
  const handler = (event) => {
    const element = isFunction(target) ? target() : vue.unref(target);
    if (element && !element.contains(event.target)) {
      listener(event);
    }
  };
  useEventListener(document, type, handler);
}
function onSmartUnmounted(hook) {
  let keepalive = false;
  vue.onDeactivated(() => {
    keepalive = true;
    hook();
  });
  vue.onUnmounted(() => {
    if (keepalive) {
      return;
    }
    hook();
  });
}
function keyInProvides(key3) {
  const instance = vue.getCurrentInstance();
  return key3 in instance.provides;
}
function useParent(key3) {
  if (!keyInProvides(key3)) {
    return {
      index: null,
      parentProvider: null,
      bindParent: null
    };
  }
  const provider = vue.inject(key3);
  const _a = provider, { childInstances, collect, clear: clear2 } = _a, parentProvider = __objRest(_a, ["childInstances", "collect", "clear"]);
  const childInstance = vue.getCurrentInstance();
  const index = vue.computed(() => childInstances.indexOf(childInstance));
  const bindParent = (childProvider) => {
    vue.onMounted(() => {
      vue.nextTick().then(() => {
        collect(childInstance, childProvider);
      });
    });
    vue.onBeforeUnmount(() => {
      vue.nextTick().then(() => {
        clear2(childInstance, childProvider);
      });
    });
  };
  return {
    index,
    parentProvider,
    bindParent
  };
}
function flatVNodes(subTree) {
  const vNodes = [];
  const flat = (subTree2) => {
    if (subTree2 == null ? void 0 : subTree2.component) {
      flat(subTree2 == null ? void 0 : subTree2.component.subTree);
      return;
    }
    if (isArray(subTree2 == null ? void 0 : subTree2.children)) {
      subTree2.children.forEach((child) => {
        if (vue.isVNode(child)) {
          vNodes.push(child);
          flat(child);
        }
      });
    }
  };
  flat(subTree);
  return vNodes;
}
function useChildren(key3) {
  const parentInstance = vue.getCurrentInstance();
  const childInstances = vue.reactive([]);
  const childProviders = [];
  const length = vue.computed(() => childInstances.length);
  const sortInstances = () => {
    const vNodes = flatVNodes(parentInstance.subTree);
    childInstances.sort((a, b) => vNodes.indexOf(a.vnode) - vNodes.indexOf(b.vnode));
  };
  const collect = (childInstance, childProvider) => {
    childInstances.push(childInstance);
    childProviders.push(childProvider);
    sortInstances();
  };
  const clear2 = (childInstance, childProvider) => {
    removeItem(childInstances, childInstance);
    removeItem(childProviders, childProvider);
  };
  const bindChildren = (parentProvider) => {
    vue.provide(key3, __spreadValues$A({
      childInstances,
      collect,
      clear: clear2
    }, parentProvider));
  };
  return {
    length,
    childProviders,
    bindChildren
  };
}
function onWindowResize(listener) {
  useEventListener(() => window, "resize", listener, { passive: true });
  useEventListener(() => window, "orientationchange", listener, { passive: true });
}
function useInitialized(source, value) {
  const initialized = vue.ref(false);
  vue.watch(
    source,
    (newValue) => {
      if (value === newValue) {
        initialized.value = true;
      }
    },
    { immediate: true }
  );
  return initialized;
}
function getDirection(x, y) {
  if (x > y) {
    return "horizontal";
  }
  if (y > x) {
    return "vertical";
  }
}
function useTouch() {
  const startX = vue.ref(0);
  const startY = vue.ref(0);
  const deltaX = vue.ref(0);
  const deltaY = vue.ref(0);
  const offsetX = vue.ref(0);
  const offsetY = vue.ref(0);
  const prevX = vue.ref(0);
  const prevY = vue.ref(0);
  const moveX = vue.ref(0);
  const moveY = vue.ref(0);
  const direction = vue.ref();
  const touching = vue.ref(false);
  const dragging = vue.ref(false);
  const startTime = vue.ref(0);
  const distance = vue.ref(0);
  let draggingAnimationFrame = null;
  const resetTouch = () => {
    startX.value = 0;
    startY.value = 0;
    deltaX.value = 0;
    deltaY.value = 0;
    offsetX.value = 0;
    offsetY.value = 0;
    prevX.value = 0;
    prevY.value = 0;
    moveX.value = 0;
    moveY.value = 0;
    direction.value = void 0;
    touching.value = false;
    dragging.value = false;
    startTime.value = 0;
    distance.value = 0;
  };
  const startTouch = (event) => {
    resetTouch();
    const { clientX: x, clientY: y } = event.touches[0];
    startX.value = x;
    startY.value = y;
    prevX.value = x;
    prevY.value = y;
    touching.value = true;
    startTime.value = performance.now();
    dragging.value = false;
    if (draggingAnimationFrame) {
      window.cancelAnimationFrame(draggingAnimationFrame);
    }
  };
  const moveTouch = (event) => {
    const { clientX: x, clientY: y } = event.touches[0];
    dragging.value = true;
    deltaX.value = x - startX.value;
    deltaY.value = y - startY.value;
    offsetX.value = Math.abs(deltaX.value);
    offsetY.value = Math.abs(deltaY.value);
    distance.value = Math.sqrt(offsetX.value ** 2 + offsetY.value ** 2);
    moveX.value = x - prevX.value;
    moveY.value = y - prevY.value;
    if (!direction.value) {
      direction.value = getDirection(offsetX.value, offsetY.value);
    }
    prevX.value = x;
    prevY.value = y;
  };
  const endTouch = () => {
    touching.value = false;
    draggingAnimationFrame = window.requestAnimationFrame(() => {
      dragging.value = false;
    });
  };
  const isReachTop = (element) => {
    const scrollTop = getScrollTop(element);
    return scrollTop === 0 && deltaY.value > 0;
  };
  const isReachBottom = (element, offset2 = 1) => {
    const { scrollHeight, clientHeight, scrollTop } = element;
    const offsetBottom = Math.abs(scrollHeight - scrollTop - clientHeight);
    return deltaY.value < 0 && offsetBottom <= offset2;
  };
  return {
    startX,
    startY,
    deltaX,
    deltaY,
    offsetX,
    offsetY,
    prevX,
    prevY,
    moveX,
    moveY,
    direction,
    touching,
    dragging,
    startTime,
    distance,
    resetTouch,
    startTouch,
    moveTouch,
    endTouch,
    isReachTop,
    isReachBottom
  };
}
function useClientId() {
  const instance = vue.getCurrentInstance();
  const name2 = kebabCase(instance.type.name);
  const id = vue.ref(process.env.NODE_ENV === "test" ? `${name2}-mock-id` : void 0);
  vue.onMounted(() => {
    if (process.env.NODE_ENV !== "test") {
      id.value = `${name2}-${instance.uid}`;
    }
  });
  return id;
}
function useWindowSize(options = {}) {
  const { initialWidth = 0, initialHeight = 0 } = options;
  const width = vue.ref(initialWidth);
  const height = vue.ref(initialHeight);
  const update = () => {
    if (!inBrowser()) {
      return;
    }
    width.value = window.innerWidth;
    height.value = window.innerHeight;
  };
  onSmartMounted(update);
  onWindowResize(update);
  return {
    width,
    height
  };
}
function useVModel(props2, key3, options = {}) {
  const { passive: passive2 = true, eventName, defaultValue, emit } = options;
  const event = eventName != null ? eventName : `onUpdate:${key3.toString()}`;
  const getValue = () => {
    var _a;
    return (_a = props2[key3]) != null ? _a : defaultValue;
  };
  if (!passive2) {
    return vue.computed({
      get() {
        return getValue();
      },
      set(value) {
        emit ? emit(event, value) : call(props2[event], value);
      }
    });
  }
  const proxy = vue.ref(getValue());
  let shouldEmit = true;
  vue.watch(
    () => props2[key3],
    () => {
      shouldEmit = false;
      proxy.value = getValue();
      vue.nextTick(() => {
        shouldEmit = true;
      });
    }
  );
  vue.watch(
    () => proxy.value,
    (newValue) => {
      if (!shouldEmit) {
        return;
      }
      emit ? emit(event, newValue) : call(props2[event], newValue);
    }
  );
  return proxy;
}
function useMotion(options) {
  const value = vue.ref(getter(options.from));
  const state = vue.ref("pending");
  let ctx2 = createMotionContext();
  function getter(value2) {
    return isFunction(value2) ? value2() : value2;
  }
  function reset() {
    ctx2.reset();
    value.value = getter(options.from);
    state.value = "pending";
    ctx2 = createMotionContext();
  }
  function start2() {
    ctx2.start();
  }
  function pause() {
    ctx2.pause();
  }
  function createMotionContext() {
    return motion({
      from: getter(options.from),
      to: getter(options.to),
      duration: options.duration ? getter(options.duration) : 300,
      timingFunction: options.timingFunction,
      onStateChange(newState) {
        state.value = newState;
      },
      frame({ value: newValue, done }) {
        var _a;
        value.value = newValue;
        if (done) {
          (_a = options.onFinished) == null ? void 0 : _a.call(options, value.value);
        }
      }
    });
  }
  return {
    value,
    state,
    start: start2,
    pause,
    reset
  };
}
var __defProp$z = Object.defineProperty;
var __defProps$d = Object.defineProperties;
var __getOwnPropDescs$d = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$z = Object.getOwnPropertySymbols;
var __hasOwnProp$z = Object.prototype.hasOwnProperty;
var __propIsEnum$z = Object.prototype.propertyIsEnumerable;
var __defNormalProp$z = (obj, key3, value) => key3 in obj ? __defProp$z(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$z = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$z.call(b, prop))
      __defNormalProp$z(a, prop, b[prop]);
  if (__getOwnPropSymbols$z)
    for (var prop of __getOwnPropSymbols$z(b)) {
      if (__propIsEnum$z.call(b, prop))
        __defNormalProp$z(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$d = (a, b) => __defProps$d(a, __getOwnPropDescs$d(b));
var __async$l = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function pickProps(props2, propsKey) {
  return isArray(propsKey) ? propsKey.reduce((pickedProps, key3) => {
    pickedProps[key3] = props2[key3];
    return pickedProps;
  }, {}) : props2[propsKey];
}
function withInstall(component, target) {
  const componentWithInstall = target != null ? target : component;
  componentWithInstall.install = function(app) {
    const { name: name2 } = component;
    if (name2) {
      app.component(name2, component);
    }
  };
  return componentWithInstall;
}
function withPropsDefaultsSetter(target, props2) {
  target.setPropsDefaults = function(defaults) {
    Object.entries(defaults).forEach(([key3, value]) => {
      const prop = props2[key3];
      if (prop == null) {
        return;
      }
      if (isPlainObject(prop)) {
        props2[key3] = __spreadProps$d(__spreadValues$z({}, prop), {
          default: value
        });
        return;
      }
      props2[key3] = {
        type: prop,
        default: value
      };
    });
  };
}
function mount$1(component) {
  const app = vue.createApp(component);
  const host = document.createElement("div");
  document.body.appendChild(host);
  return {
    instance: app.mount(host),
    unmount() {
      app.unmount();
      if (host.parentNode) {
        document.body.removeChild(host);
      }
    }
  };
}
function mountInstance(component, props2 = {}, eventListener = {}) {
  const Host = {
    setup() {
      return () => vue.h(component, __spreadValues$z(__spreadValues$z({}, props2), eventListener));
    }
  };
  const { unmount: unmount2 } = mount$1(Host);
  return { unmountInstance: unmount2 };
}
function flatFragment(vNodes) {
  const result = [];
  vNodes.forEach((vNode) => {
    if (vNode.type === vue.Comment) {
      return;
    }
    if (vNode.type === vue.Fragment && isArray(vNode.children)) {
      vNode.children.forEach((item) => {
        result.push(item);
      });
      return;
    }
    result.push(vNode);
  });
  return result;
}
function isZodRule(rule) {
  return isPlainObject(rule) && isFunction(rule.safeParseAsync);
}
function isZodResult(result) {
  return isPlainObject(result) && hasOwn(result, "success");
}
function useValidation() {
  const errorMessage = vue.ref("");
  const validate = (ruleOrRules, value, apis) => __async$l(this, null, function* () {
    const rules = normalizeToArray(ruleOrRules).filter((rule) => isZodRule(rule) || isFunction(rule));
    const results = yield Promise.all(
      rules.map((rule) => isZodRule(rule) ? rule.safeParseAsync(value) : rule(value, apis))
    );
    resetValidation();
    return !results.some((result) => {
      if (isZodResult(result)) {
        if (result.success === false) {
          errorMessage.value = result.error.issues[0].message;
          return true;
        }
      } else if (result !== true) {
        errorMessage.value = String(result);
        return true;
      }
      return false;
    });
  });
  const resetValidation = () => {
    errorMessage.value = "";
  };
  const validateWithTrigger = (validateTrigger, trigger, rules, value, apis) => __async$l(this, null, function* () {
    if (validateTrigger.includes(trigger)) {
      (yield validate(rules, value, apis)) && (errorMessage.value = "");
    }
  });
  return {
    errorMessage,
    validate,
    resetValidation,
    validateWithTrigger
  };
}
function useRouteListener(listener) {
  useEventListener(() => window, "hashchange", listener);
  useEventListener(() => window, "popstate", listener);
}
function useTeleport() {
  const disabled = vue.ref(false);
  vue.onActivated(() => {
    disabled.value = false;
  });
  vue.onDeactivated(() => {
    disabled.value = true;
  });
  return {
    disabled
  };
}
const createNamespace = createNamespaceFn("var");
function defineListenerProp(fallback) {
  return {
    type: [Function, Array],
    default: fallback
  };
}
function formatElevation(elevation, defaultLevel) {
  if (elevation === false) {
    return null;
  }
  if (elevation === true && defaultLevel) {
    elevation = defaultLevel;
  }
  return `var-elevation--${elevation}`;
}
const MaybeVNode = vue.defineComponent({
  props: {
    is: {
      type: [String, Object]
    },
    tag: {
      type: String,
      default: "span"
    }
  },
  setup(props2) {
    return () => isString(props2.is) ? vue.h(props2.tag, props2.is) : props2.is;
  }
});
var stdin_default$6c = {
  // Dialog
  dialogTitle: "Hint",
  dialogConfirmButtonText: "Confirm",
  dialogCancelButtonText: "Cancel",
  // ActionSheet
  actionSheetTitle: "Select One",
  // List
  listLoadingText: "Loading",
  listFinishedText: "No more",
  listErrorText: "Load fail",
  // Picker
  pickerTitle: "Pick it",
  pickerConfirmButtonText: "Confirm",
  pickerCancelButtonText: "Cancel",
  // date-picker
  datePickerMonthDict: {
    "01": {
      name: "January",
      abbr: "JAN"
    },
    "02": {
      name: "February",
      abbr: "FEB"
    },
    "03": {
      name: "March",
      abbr: "MAR"
    },
    "04": {
      name: "April",
      abbr: "APR"
    },
    "05": {
      name: "May",
      abbr: "MAY"
    },
    "06": {
      name: "June",
      abbr: "JUN"
    },
    "07": {
      name: "July",
      abbr: "JUL"
    },
    "08": {
      name: "August",
      abbr: "AUG"
    },
    "09": {
      name: "September",
      abbr: "SEP"
    },
    "10": {
      name: "October",
      abbr: "OCT"
    },
    "11": {
      name: "November",
      abbr: "NOV"
    },
    "12": {
      name: "December",
      abbr: "DEC"
    }
  },
  datePickerWeekDict: {
    "0": {
      name: "Sunday",
      abbr: "S"
    },
    "1": {
      name: "Monday",
      abbr: "M"
    },
    "2": {
      name: "Tuesday",
      abbr: "T"
    },
    "3": {
      name: "Wednesday",
      abbr: "W"
    },
    "4": {
      name: "Thursday",
      abbr: "T"
    },
    "5": {
      name: "Friday",
      abbr: "F"
    },
    "6": {
      name: "Saturday",
      abbr: "S"
    }
  },
  datePickerSelected: " selected",
  datePickerHint: "SELECT DATE",
  // pagination
  paginationItem: "",
  paginationPage: "page",
  paginationJump: "Go to",
  // time-picker
  timePickerHint: "SELECT TIME"
};
var stdin_default$6b = {
  // Dialog
  dialogTitle: "",
  dialogConfirmButtonText: "",
  dialogCancelButtonText: "",
  // ActionSheet
  actionSheetTitle: "  ",
  // List
  listLoadingText: "  ",
  listFinishedText: "   ",
  listErrorText: " ",
  // Picker
  pickerTitle: " ",
  pickerConfirmButtonText: "",
  pickerCancelButtonText: "",
  // date-picker
  datePickerMonthDict: {
    "01": {
      name: "",
      abbr: "JAN"
    },
    "02": {
      name: "",
      abbr: "FEB"
    },
    "03": {
      name: "",
      abbr: "MAR"
    },
    "04": {
      name: "",
      abbr: "APR"
    },
    "05": {
      name: "",
      abbr: "MAY"
    },
    "06": {
      name: "",
      abbr: "JUN"
    },
    "07": {
      name: "",
      abbr: "JUL"
    },
    "08": {
      name: "",
      abbr: "AUG"
    },
    "09": {
      name: "",
      abbr: "SEP"
    },
    "10": {
      name: "",
      abbr: "OCT"
    },
    "11": {
      name: "",
      abbr: "NOV"
    },
    "12": {
      name: "",
      abbr: "DEC"
    }
  },
  datePickerWeekDict: {
    "0": {
      name: "",
      abbr: "S"
    },
    "1": {
      name: "",
      abbr: "M"
    },
    "2": {
      name: "",
      abbr: "T"
    },
    "3": {
      name: "",
      abbr: "W"
    },
    "4": {
      name: "",
      abbr: "T"
    },
    "5": {
      name: "",
      abbr: "F"
    },
    "6": {
      name: "",
      abbr: "S"
    }
  },
  datePickerSelected: "  ",
  datePickerHint: " ",
  // pagination
  paginationItem: "",
  paginationPage: "",
  paginationJump: " ",
  // time-picker
  timePickerHint: " "
};
var stdin_default$6a = {
  // Dialog
  dialogTitle: "",
  dialogConfirmButtonText: "",
  dialogCancelButtonText: "",
  // ActionSheet
  actionSheetTitle: "",
  // List
  listLoadingText: "",
  listFinishedText: "",
  listErrorText: "",
  // Picker
  pickerTitle: "",
  pickerConfirmButtonText: "",
  pickerCancelButtonText: "",
  // date-picker
  datePickerMonthDict: {
    "01": {
      name: "",
      abbr: ""
    },
    "02": {
      name: "",
      abbr: ""
    },
    "03": {
      name: "",
      abbr: ""
    },
    "04": {
      name: "",
      abbr: ""
    },
    "05": {
      name: "",
      abbr: ""
    },
    "06": {
      name: "",
      abbr: ""
    },
    "07": {
      name: "",
      abbr: ""
    },
    "08": {
      name: "",
      abbr: ""
    },
    "09": {
      name: "",
      abbr: ""
    },
    "10": {
      name: "",
      abbr: ""
    },
    "11": {
      name: "",
      abbr: ""
    },
    "12": {
      name: "",
      abbr: ""
    }
  },
  datePickerWeekDict: {
    "0": {
      name: "",
      abbr: ""
    },
    "1": {
      name: "",
      abbr: ""
    },
    "2": {
      name: "",
      abbr: ""
    },
    "3": {
      name: "",
      abbr: ""
    },
    "4": {
      name: "",
      abbr: ""
    },
    "5": {
      name: "",
      abbr: ""
    },
    "6": {
      name: "",
      abbr: ""
    }
  },
  datePickerSelected: "",
  datePickerHint: "",
  // pagination
  paginationItem: "",
  paginationPage: "",
  paginationJump: "",
  // time-picker
  timePickerHint: ""
};
var stdin_default$69 = {
  // Dialog
  dialogTitle: "",
  dialogConfirmButtonText: "",
  dialogCancelButtonText: "",
  // ActionSheet
  actionSheetTitle: "",
  // List
  listLoadingText: "",
  listFinishedText: "",
  listErrorText: "",
  // Picker
  pickerTitle: "",
  pickerConfirmButtonText: "",
  pickerCancelButtonText: "",
  // date-picker
  datePickerMonthDict: {
    "01": {
      name: "",
      abbr: ""
    },
    "02": {
      name: "",
      abbr: ""
    },
    "03": {
      name: "",
      abbr: ""
    },
    "04": {
      name: "",
      abbr: ""
    },
    "05": {
      name: "",
      abbr: ""
    },
    "06": {
      name: "",
      abbr: ""
    },
    "07": {
      name: "",
      abbr: ""
    },
    "08": {
      name: "",
      abbr: ""
    },
    "09": {
      name: "",
      abbr: ""
    },
    "10": {
      name: "",
      abbr: ""
    },
    "11": {
      name: "",
      abbr: ""
    },
    "12": {
      name: "",
      abbr: ""
    }
  },
  datePickerWeekDict: {
    "0": {
      name: "",
      abbr: ""
    },
    "1": {
      name: "",
      abbr: ""
    },
    "2": {
      name: "",
      abbr: ""
    },
    "3": {
      name: "",
      abbr: ""
    },
    "4": {
      name: "",
      abbr: ""
    },
    "5": {
      name: "",
      abbr: ""
    },
    "6": {
      name: "",
      abbr: ""
    }
  },
  datePickerSelected: "",
  // pagination
  paginationItem: "",
  paginationPage: "",
  paginationJump: ""
};
var stdin_default$68 = stdin_default$69;
var __defProp$y = Object.defineProperty;
var __getOwnPropSymbols$y = Object.getOwnPropertySymbols;
var __hasOwnProp$y = Object.prototype.hasOwnProperty;
var __propIsEnum$y = Object.prototype.propertyIsEnumerable;
var __defNormalProp$y = (obj, key3, value) => key3 in obj ? __defProp$y(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$y = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$y.call(b, prop))
      __defNormalProp$y(a, prop, b[prop]);
  if (__getOwnPropSymbols$y)
    for (var prop of __getOwnPropSymbols$y(b)) {
      if (__propIsEnum$y.call(b, prop))
        __defNormalProp$y(a, prop, b[prop]);
    }
  return a;
};
function useLocale() {
  const messages2 = vue.ref({});
  const currentMessage2 = vue.ref({});
  const add2 = (lang, message) => {
    message.lang = lang;
    messages2.value[lang] = message;
  };
  const use2 = (lang) => {
    if (!messages2.value[lang]) {
      console.warn(`The ${lang} does not exist. You can mount a language message using the add method`);
      return {};
    }
    currentMessage2.value = messages2.value[lang];
  };
  const merge2 = (lang, message) => {
    if (!messages2.value[lang]) {
      console.warn(`The ${lang} does not exist. You can mount a language message using the add method`);
      return;
    }
    messages2.value[lang] = __spreadValues$y(__spreadValues$y({}, messages2.value[lang]), message);
    use2(lang);
  };
  const t2 = (id) => {
    if (hasOwn(currentMessage2.value, id)) {
      return currentMessage2.value[id];
    }
  };
  return {
    messages: messages2,
    currentMessage: currentMessage2,
    add: add2,
    use: use2,
    merge: merge2,
    t: t2
  };
}
const { messages, currentMessage, add: add$2, use, merge, t } = useLocale();
add$2("zh-CN", stdin_default$6a);
use("zh-CN");
const _LocaleComponent = {
  zhCN: stdin_default$6a,
  enUS: stdin_default$6c,
  zhTW: stdin_default$69,
  zhHK: stdin_default$68,
  faIR: stdin_default$6b,
  messages,
  currentMessage,
  add: add$2,
  use,
  merge,
  t,
  useLocale
};
var stdin_default$67 = {
  zhCN: stdin_default$6a,
  enUS: stdin_default$6c,
  zhTW: stdin_default$69,
  zhHK: stdin_default$68,
  faIR: stdin_default$6b,
  messages,
  currentMessage,
  add: add$2,
  use,
  merge,
  t,
  useLocale
};
const LOCALE_PROVIDER_KEY = Symbol("LOCALE_PROVIDER_KEY");
function provideLocaleProvider(localeProvider) {
  vue.provide(LOCALE_PROVIDER_KEY, localeProvider);
}
function injectLocaleProvider() {
  if (!keyInProvides(LOCALE_PROVIDER_KEY)) {
    return { t: null };
  }
  return vue.inject(LOCALE_PROVIDER_KEY);
}
const context = {
  locks: {},
  zIndex: 2e3,
  enableRipple: true
};
const _ContextComponent = vue.reactive(context);
var stdin_default$66 = vue.reactive(context);
const { n: n$1x } = createNamespace("");
function resolveLock() {
  const lockCounts = Object.keys(stdin_default$66.locks).length;
  lockCounts <= 0 ? document.body.classList.remove(n$1x("$--lock")) : document.body.classList.add(n$1x("$--lock"));
}
function addLock(uid) {
  stdin_default$66.locks[uid] = 1;
  resolveLock();
}
function releaseLock(uid) {
  delete stdin_default$66.locks[uid];
  resolveLock();
}
function useLock(source, useSource) {
  const { uid } = vue.getCurrentInstance();
  if (useSource) {
    vue.watch(useSource, (newValue) => {
      if (newValue === false) {
        releaseLock(uid);
      } else if (newValue === true && source() === true) {
        addLock(uid);
      }
    });
  }
  vue.watch(source, (newValue) => {
    if (useSource && useSource() === false) {
      return;
    }
    if (newValue === true) {
      addLock(uid);
    } else {
      releaseLock(uid);
    }
  });
  vue.onBeforeMount(() => {
    if (useSource && useSource() === false) {
      return;
    }
    if (source() === true) {
      addLock(uid);
    }
  });
  vue.onUnmounted(() => {
    if (useSource && useSource() === false) {
      return;
    }
    if (source() === true) {
      releaseLock(uid);
    }
  });
  vue.onActivated(() => {
    if (useSource && useSource() === false) {
      return;
    }
    if (source() === true) {
      addLock(uid);
    }
  });
  vue.onDeactivated(() => {
    if (useSource && useSource() === false) {
      return;
    }
    if (source() === true) {
      releaseLock(uid);
    }
  });
}
const stack = [];
function useStack(activeGetter, zIndex) {
  const { uid } = vue.getCurrentInstance();
  vue.watch(activeGetter, (isActive) => {
    if (isActive && !getStackItem(uid)) {
      pushStackItem();
    } else {
      setTimeout(() => {
        removeItem(stack, getStackItem(uid));
      });
    }
  });
  onSmartMounted(() => {
    if (activeGetter()) {
      pushStackItem();
    }
  });
  onSmartUnmounted(() => {
    removeItem(stack, getStackItem(uid));
  });
  function onStackTop() {
    if (stack.length === 0) {
      return true;
    }
    stack.sort((a, b) => a.zIndex.value - b.zIndex.value);
    return stack[stack.length - 1].uid === uid;
  }
  function pushStackItem() {
    if (getStackItem(uid)) {
      return;
    }
    stack.push({ uid, zIndex });
  }
  function getStackItem(uid2) {
    return stack.find((item) => item.uid === uid2);
  }
  return {
    onStackTop
  };
}
function useZIndex(source, count) {
  const zIndex = vue.ref(stdin_default$66.zIndex);
  vue.watch(
    source,
    (newValue) => {
      if (newValue) {
        stdin_default$66.zIndex += process.env.NODE_ENV === "test" ? 0 : count;
        zIndex.value = stdin_default$66.zIndex;
      }
    },
    { immediate: true }
  );
  return { zIndex };
}
const props$1l = {
  show: Boolean,
  position: {
    type: String,
    default: "center"
  },
  transition: String,
  overlay: {
    type: Boolean,
    default: true
  },
  overlayClass: String,
  overlayStyle: Object,
  lockScroll: {
    type: Boolean,
    default: true
  },
  closeOnClickOverlay: {
    type: Boolean,
    default: true
  },
  closeOnKeyEscape: {
    type: Boolean,
    default: true
  },
  defaultStyle: {
    type: Boolean,
    default: true
  },
  zIndex: Number,
  safeArea: Boolean,
  safeAreaTop: Boolean,
  teleport: {
    type: [String, Object, Boolean],
    default: "body"
  },
  onOpen: defineListenerProp(),
  onOpened: defineListenerProp(),
  onClose: defineListenerProp(),
  onClosed: defineListenerProp(),
  onKeyEscape: defineListenerProp(),
  onClickOverlay: defineListenerProp(),
  "onUpdate:show": defineListenerProp(),
  // internal for Dialog
  onRouteChange: defineListenerProp()
};
const POPUP_BIND_POPUP_ITEM_KEY = Symbol("POPUP_BIND_POPUP_ITEM_KEY");
function usePopup() {
  const { bindParent, parentProvider, index } = useParent(POPUP_BIND_POPUP_ITEM_KEY);
  return {
    index,
    popup: parentProvider,
    bindPopup: bindParent
  };
}
function usePopupItems() {
  const { bindChildren, childProviders, length } = useChildren(POPUP_BIND_POPUP_ITEM_KEY);
  return {
    length,
    popupItems: childProviders,
    bindPopupItems: bindChildren
  };
}
var __defProp$x = Object.defineProperty;
var __getOwnPropSymbols$x = Object.getOwnPropertySymbols;
var __hasOwnProp$x = Object.prototype.hasOwnProperty;
var __propIsEnum$x = Object.prototype.propertyIsEnumerable;
var __defNormalProp$x = (obj, key3, value) => key3 in obj ? __defProp$x(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$x = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$x.call(b, prop))
      __defNormalProp$x(a, prop, b[prop]);
  if (__getOwnPropSymbols$x)
    for (var prop of __getOwnPropSymbols$x(b)) {
      if (__propIsEnum$x.call(b, prop))
        __defNormalProp$x(a, prop, b[prop]);
    }
  return a;
};
const {
  name: name$1o,
  n: n$1w,
  classes: classes$1c
} = createNamespace("popup");
var stdin_default$65 = vue.defineComponent({
  name: name$1o,
  inheritAttrs: false,
  props: props$1l,
  setup(props2, {
    slots,
    attrs
  }) {
    const rendered = useInitialized(() => props2.show, true);
    const {
      zIndex
    } = useZIndex(() => props2.show, 3);
    const normalizedZIndex = vue.computed(() => {
      var _a;
      return (_a = props2.zIndex) != null ? _a : zIndex.value;
    });
    const {
      onStackTop
    } = useStack(() => props2.show, normalizedZIndex);
    const {
      disabled
    } = useTeleport();
    const {
      bindPopupItems
    } = usePopupItems();
    useLock(() => props2.show, () => props2.lockScroll);
    vue.watch(() => props2.show, (newValue) => {
      newValue ? call(props2.onOpen) : call(props2.onClose);
    });
    bindPopupItems({
      show: vue.computed(() => props2.show)
    });
    useEventListener(() => window, "keydown", handleKeydown);
    useRouteListener(() => call(props2.onRouteChange));
    function hidePopup() {
      const {
        closeOnClickOverlay,
        onClickOverlay
      } = props2;
      call(onClickOverlay);
      if (!closeOnClickOverlay) {
        return;
      }
      call(props2["onUpdate:show"], false);
    }
    function renderOverlay() {
      const {
        overlayClass = "",
        overlayStyle
      } = props2;
      return vue.createVNode("div", {
        "class": classes$1c(n$1w("overlay"), overlayClass),
        "style": __spreadValues$x({
          zIndex: normalizedZIndex.value - 1
        }, overlayStyle),
        "onClick": hidePopup
      }, null);
    }
    function renderContent() {
      return vue.withDirectives(vue.createVNode("div", vue.mergeProps({
        "class": classes$1c(n$1w("content"), n$1w(`--${props2.position}`), [props2.defaultStyle, n$1w("--content-background-color")], [props2.defaultStyle, n$1w("$-elevation--3")], [props2.safeArea, n$1w("--safe-area")], [props2.safeAreaTop, n$1w("--safe-area-top")]),
        "style": {
          zIndex: normalizedZIndex.value
        },
        "role": "dialog",
        "aria-modal": "true"
      }, attrs), [rendered.value && call(slots.default)]), [[vue.vShow, props2.show]]);
    }
    function renderPopup() {
      return vue.createVNode(vue.Transition, {
        "name": n$1w("$-fade"),
        "onAfterEnter": props2.onOpened,
        "onAfterLeave": props2.onClosed
      }, {
        default: () => [vue.withDirectives(vue.createVNode("div", {
          "class": classes$1c(n$1w("$--box"), n$1w(), [!props2.overlay, n$1w("--pointer-events-none")]),
          "style": {
            zIndex: normalizedZIndex.value - 2
          }
        }, [props2.overlay && renderOverlay(), vue.createVNode(vue.Transition, {
          "name": props2.transition || n$1w(`$-pop-${props2.position}`)
        }, {
          default: () => [renderContent()]
        })]), [[vue.vShow, props2.show]])]
      });
    }
    function handleKeydown(event) {
      if (!onStackTop() || event.key !== "Escape" || !props2.show) {
        return;
      }
      call(props2.onKeyEscape);
      if (!props2.closeOnKeyEscape) {
        return;
      }
      preventDefault(event);
      call(props2["onUpdate:show"], false);
    }
    return () => {
      const {
        teleport
      } = props2;
      if (teleport) {
        return vue.createVNode(vue.Teleport, {
          "to": teleport,
          "disabled": disabled.value
        }, {
          default: () => [renderPopup()]
        });
      }
      return renderPopup();
    };
  }
});
withInstall(stdin_default$65);
withPropsDefaultsSetter(stdin_default$65, props$1l);
const _PopupComponent = stdin_default$65;
var stdin_default$64 = stdin_default$65;
var __defProp$w = Object.defineProperty;
var __defProps$c = Object.defineProperties;
var __getOwnPropDescs$c = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$w = Object.getOwnPropertySymbols;
var __hasOwnProp$w = Object.prototype.hasOwnProperty;
var __propIsEnum$w = Object.prototype.propertyIsEnumerable;
var __defNormalProp$w = (obj, key3, value) => key3 in obj ? __defProp$w(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$w = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$w.call(b, prop))
      __defNormalProp$w(a, prop, b[prop]);
  if (__getOwnPropSymbols$w)
    for (var prop of __getOwnPropSymbols$w(b)) {
      if (__propIsEnum$w.call(b, prop))
        __defNormalProp$w(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$c = (a, b) => __defProps$c(a, __getOwnPropDescs$c(b));
const { n: n$1v } = createNamespace("ripple");
const ANIMATION_DURATION$1 = 250;
function setStyles(element) {
  const { zIndex, position } = getStyle$1(element);
  element.style.overflow = "hidden";
  element.style.overflowX = "hidden";
  element.style.overflowY = "hidden";
  position === "static" && (element.style.position = "relative");
  zIndex === "auto" && (element.style.zIndex = "1");
}
function isTouchEvent(event) {
  return "touches" in event;
}
function computeRippleStyles(element, event) {
  const { top: top2, left: left2 } = getRect(element);
  const { clientWidth, clientHeight } = element;
  const radius = Math.sqrt(clientWidth ** 2 + clientHeight ** 2) / 2;
  const size = radius * 2;
  const localX = isTouchEvent(event) ? event.touches[0].clientX - left2 : clientWidth / 2;
  const localY = isTouchEvent(event) ? event.touches[0].clientY - top2 : clientHeight / 2;
  const centerX = (clientWidth - radius * 2) / 2;
  const centerY = (clientHeight - radius * 2) / 2;
  const x = localX - radius;
  const y = localY - radius;
  return { x, y, centerX, centerY, size };
}
function createRipple(event) {
  const _ripple = this._ripple;
  _ripple.removeRipple();
  if (_ripple.disabled || _ripple.tasker || !stdin_default$66.enableRipple) {
    return;
  }
  const task = () => {
    _ripple.tasker = null;
    const { x, y, centerX, centerY, size } = computeRippleStyles(this, event);
    const ripple = document.createElement("div");
    ripple.classList.add(n$1v());
    ripple.style.opacity = `0`;
    ripple.style.transform = `translate(${x}px, ${y}px) scale3d(.3, .3, .3)`;
    ripple.style.width = `${size}px`;
    ripple.style.height = `${size}px`;
    _ripple.color && (ripple.style.backgroundColor = _ripple.color);
    ripple.dataset.createdAt = String(performance.now());
    setStyles(this);
    this.appendChild(ripple);
    window.setTimeout(() => {
      ripple.style.transform = `translate(${centerX}px, ${centerY}px) scale3d(1, 1, 1)`;
      ripple.style.opacity = `.25`;
    }, 20);
  };
  _ripple.tasker = window.setTimeout(task, 30);
}
function removeRipple() {
  const _ripple = this._ripple;
  const task = () => {
    const ripples = this.querySelectorAll(`.${n$1v()}`);
    if (!ripples.length) {
      return;
    }
    const lastRipple = ripples[ripples.length - 1];
    const delay2 = ANIMATION_DURATION$1 - performance.now() + Number(lastRipple.dataset.createdAt);
    window.setTimeout(() => {
      lastRipple.style.opacity = `0`;
      window.setTimeout(() => {
        var _a;
        return (_a = lastRipple.parentNode) == null ? void 0 : _a.removeChild(lastRipple);
      }, ANIMATION_DURATION$1);
    }, delay2);
  };
  _ripple.tasker ? window.setTimeout(task, 30) : task();
}
function forbidRippleTask() {
  if (!supportTouch() || !stdin_default$66.enableRipple) {
    return;
  }
  const _ripple = this._ripple;
  _ripple.tasker && window.clearTimeout(_ripple.tasker);
  _ripple.tasker = null;
}
let hasKeyboardRipple = false;
function createKeyboardRipple(event) {
  if (hasKeyboardRipple || !(event.key === " " || event.key === "Enter")) {
    return;
  }
  createRipple.call(this, event);
  hasKeyboardRipple = true;
}
function removeKeyboardRipple() {
  if (!hasKeyboardRipple) {
    return;
  }
  removeRipple.call(this);
  hasKeyboardRipple = false;
}
function mounted$2(el, binding) {
  var _a;
  el._ripple = __spreadProps$c(__spreadValues$w({
    tasker: null
  }, (_a = binding.value) != null ? _a : {}), {
    removeRipple: removeRipple.bind(el)
  });
  el.addEventListener("touchstart", createRipple, { passive: true });
  el.addEventListener("touchmove", forbidRippleTask, { passive: true });
  el.addEventListener("dragstart", removeRipple, { passive: true });
  el.addEventListener("keydown", createKeyboardRipple);
  el.addEventListener("keyup", removeKeyboardRipple);
  el.addEventListener("blur", removeKeyboardRipple);
  document.addEventListener("touchend", el._ripple.removeRipple, { passive: true });
  document.addEventListener("touchcancel", el._ripple.removeRipple, { passive: true });
  document.addEventListener("dragend", el._ripple.removeRipple, { passive: true });
}
function unmounted$1(el) {
  el.removeEventListener("touchstart", createRipple);
  el.removeEventListener("touchmove", forbidRippleTask);
  el.removeEventListener("dragstart", removeRipple);
  if (!el._ripple || !el._ripple.removeRipple) {
    return;
  }
  document.removeEventListener("touchend", el._ripple.removeRipple);
  document.removeEventListener("touchcancel", el._ripple.removeRipple);
  document.removeEventListener("dragend", el._ripple.removeRipple);
}
function updated$2(el, binding) {
  var _a, _b, _c, _d, _e, _f;
  const newBinding = {
    color: (_a = binding.value) == null ? void 0 : _a.color,
    disabled: (_b = binding.value) == null ? void 0 : _b.disabled
  };
  const diff2 = newBinding.color !== ((_c = el._ripple) == null ? void 0 : _c.color) || newBinding.disabled !== ((_d = el._ripple) == null ? void 0 : _d.disabled);
  if (diff2) {
    el._ripple = __spreadValues$w({
      tasker: newBinding.disabled ? null : (_e = el._ripple) == null ? void 0 : _e.tasker,
      removeRipple: (_f = el._ripple) == null ? void 0 : _f.removeRipple
    }, newBinding);
  }
}
const Ripple = {
  mounted: mounted$2,
  unmounted: unmounted$1,
  updated: updated$2,
  install(app) {
    app.directive("ripple", this);
  }
};
const _RippleComponent = Ripple;
var stdin_default$63 = Ripple;
function shouldDisabled(arg) {
  if (!arg) {
    return false;
  }
  if (arg === "desktop" && inMobile()) {
    return true;
  }
  if (arg === "mobile" && !inMobile()) {
    return true;
  }
  return false;
}
function getStyle(element) {
  const style = element.getAttribute("style");
  if (!style) {
    return {};
  }
  return style.split(";").filter(Boolean).reduce(
    (style2, item) => {
      const [key3, value] = item.split(":").map((item2) => item2.trim());
      style2[camelize(key3)] = value;
      return style2;
    },
    {}
  );
}
function updateRawStyle(element) {
  const { value } = element._hover;
  const style = getStyle(element);
  Object.keys(value).forEach((key3) => {
    const camelizedKey = camelize(key3);
    const styleValue = value[camelizedKey];
    if (styleValue != null && style[camelizedKey]) {
      element._hover.rawStyle[camelizedKey] = style[camelizedKey];
    }
  });
}
function updateStyle(element, styleValue) {
  Object.keys(styleValue).forEach((key3) => {
    const value = styleValue[key3];
    if (value != null) {
      element.style[key3] = value;
    }
  });
}
function clearStyle(element) {
  Object.keys(element._hover.value).forEach((key3) => {
    const value = element._hover.value[key3];
    if (value != null) {
      element.style[key3] = "";
    }
  });
}
function restoreStyle(element) {
  if ((element == null ? void 0 : element._hover) == null) {
    return;
  }
  clearStyle(element);
  updateStyle(element, element._hover.rawStyle);
}
function createHover() {
  const { value } = this._hover;
  this._hover.hovering = true;
  if (isFunction(value)) {
    value(this._hover.hovering);
    return;
  }
  updateStyle(this, value);
}
function removeHover() {
  this._hover.hovering = false;
  if (isFunction(this._hover.value)) {
    this._hover.value(this._hover.hovering);
    return;
  }
  restoreStyle(this);
}
function mounted$1(element, binding) {
  var _a, _b;
  const { arg, value } = binding;
  if (shouldDisabled(arg)) {
    return;
  }
  element._hover = {
    value,
    hovering: (_b = (_a = element._hover) == null ? void 0 : _a.hovering) != null ? _b : false,
    rawStyle: {}
  };
  updateRawStyle(element);
  element.addEventListener("mouseenter", createHover);
  element.addEventListener("mouseleave", removeHover);
}
function unmounted(element, binding) {
  if (shouldDisabled(binding.arg)) {
    return;
  }
  restoreStyle(element);
  element.removeEventListener("mouseenter", createHover);
  element.removeEventListener("mouseleave", removeHover);
}
function beforeUpdate(element, binding) {
  if (!element._hover) {
    return;
  }
  unmounted(element, binding);
}
function shouldUpdateStyle(element, binding) {
  return !isFunction(binding.value) && element._hover.hovering;
}
function updated$1(element, binding) {
  mounted$1(element, binding);
  if (shouldUpdateStyle(element, binding)) {
    updateStyle(element, binding.value);
  }
}
const Hover = {
  mounted: mounted$1,
  unmounted,
  beforeUpdate,
  updated: updated$1,
  install(app) {
    app.directive("hover", this);
  }
};
const _HoverComponent = Hover;
var stdin_default$62 = Hover;
const props$1k = {
  hovering: Boolean,
  focusing: Boolean
};
const { name: name$1n, n: n$1u, classes: classes$1b } = createNamespace("hover-overlay");
function __render__$1s(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.classes(_ctx.n(), [_ctx.hovering, _ctx.n("--hovering")], [_ctx.focusing && !_ctx.inMobile(), _ctx.n("--focusing")]))
    },
    null,
    2
    /* CLASS */
  );
}
const __sfc__$1v = vue.defineComponent({
  name: name$1n,
  props: props$1k,
  setup: () => ({
    n: n$1u,
    classes: classes$1b,
    inMobile
  })
});
__sfc__$1v.render = __render__$1s;
var stdin_default$61 = __sfc__$1v;
withInstall(stdin_default$61);
withPropsDefaultsSetter(stdin_default$61, props$1k);
function useHoverOverlay() {
  const hovering = vue.ref(false);
  const handleHovering = (value) => {
    hovering.value = value;
  };
  return {
    hovering,
    handleHovering
  };
}
const _HoverOverlayComponent = stdin_default$61;
var stdin_default$60 = stdin_default$61;
function getLeft(element) {
  const { left: left2 } = getRect(element);
  return left2 + (document.body.scrollLeft || document.documentElement.scrollLeft);
}
function getTop$1(element) {
  const { top: top2 } = getRect(element);
  return top2 + (document.body.scrollTop || document.documentElement.scrollTop);
}
function getTranslateY(el) {
  const { transform } = getStyle$1(el);
  return +transform.slice(transform.lastIndexOf(",") + 2, transform.length - 1);
}
function getParentScroller(el) {
  let element = el;
  while (element) {
    if (!element.parentNode) {
      break;
    }
    element = element.parentNode;
    if (element === document.body || element === document.documentElement) {
      break;
    }
    const scrollRE = /(scroll|auto)/;
    const { overflowY, overflow } = getStyle$1(element);
    if (scrollRE.test(overflowY) || scrollRE.test(overflow)) {
      return element;
    }
  }
  return window;
}
function getAllParentScroller(el) {
  const allParentScroller = [];
  let element = el;
  while (!isWindow(element)) {
    element = getParentScroller(element);
    allParentScroller.push(element);
  }
  return allParentScroller;
}
function getTarget(target, componentName) {
  if (isString(target)) {
    const el = document.querySelector(target);
    assert(!!el, componentName, "target element cannot found");
    return el;
  }
  assert(isObject(target), componentName, 'type of prop "target" should be an element object');
  return target;
}
function getViewportSize() {
  const { width, height } = getRect(window);
  return {
    vw: width,
    vh: height,
    vMin: Math.min(width, height),
    vMax: Math.max(width, height)
  };
}
const isRem = (value) => isString(value) && value.endsWith("rem");
const isPx = (value) => isString(value) && value.endsWith("px") || isNumber(value);
const isVw = (value) => isString(value) && value.endsWith("vw");
const isVh = (value) => isString(value) && value.endsWith("vh");
const isVMin = (value) => isString(value) && value.endsWith("vmin");
const isVMax = (value) => isString(value) && value.endsWith("vmax");
const toPxNum = (value) => {
  if (isNumeric(value)) {
    return Number(value);
  }
  if (isPx(value)) {
    return +value.replace("px", "");
  }
  if (!inBrowser()) {
    return 0;
  }
  const { vw, vh, vMin, vMax } = getViewportSize();
  if (isVw(value)) {
    return +value.replace("vw", "") * vw / 100;
  }
  if (isVh(value)) {
    return +value.replace("vh", "") * vh / 100;
  }
  if (isVMin(value)) {
    return +value.replace("vmin", "") * vMin / 100;
  }
  if (isVMax(value)) {
    return +value.replace("vmax", "") * vMax / 100;
  }
  if (isRem(value)) {
    const num = +value.replace("rem", "");
    const rootFontSize = getStyle$1(document.documentElement).fontSize;
    return num * parseFloat(rootFontSize);
  }
  if (isString(value)) {
    return toNumber(value);
  }
  return 0;
};
const toSizeUnit = (value) => {
  if (value == null) {
    return void 0;
  }
  if (isNumeric(value)) {
    return `${value}px`;
  }
  return String(value);
};
const multiplySizeUnit = (value, quantity = 1) => {
  if (value == null) {
    return void 0;
  }
  const legalSize = toSizeUnit(value);
  const unit = legalSize.match(/(vh|%|r?em|px|vw|vmin|vmax)$/)[0];
  return `${parseFloat(legalSize) * quantity}${unit}`;
};
function scrollTo(element, { top: top2 = 0, left: left2 = 0, duration = 300, animation }) {
  const startTime = Date.now();
  const scrollTop = getScrollTop(element);
  const scrollLeft = getScrollLeft(element);
  return new Promise((resolve) => {
    const frame = () => {
      const progress = (Date.now() - startTime) / duration;
      if (progress < 1) {
        const nextTop = scrollTop + (top2 - scrollTop) * animation(progress);
        const nextLeft = scrollLeft + (left2 - scrollLeft) * animation(progress);
        element.scrollTo(nextLeft, nextTop);
        requestAnimationFrame(frame);
      } else {
        element.scrollTo(left2, top2);
        resolve();
      }
    };
    requestAnimationFrame(frame);
  });
}
function formatStyleVars(styleVars) {
  return Object.entries(styleVars != null ? styleVars : {}).reduce((styles, [key3, value]) => {
    const cssVar = key3.startsWith("--") ? key3 : `--${kebabCase(key3)}`;
    styles[cssVar] = value;
    return styles;
  }, {});
}
function padStartFlex(style) {
  return style === "start" || style === "end" ? `flex-${style}` : style;
}
function isDisplayNoneElement(element) {
  let parent = element;
  while (parent && parent !== document.documentElement) {
    if (getStyle$1(parent).display === "none") {
      return true;
    }
    parent = parent.parentNode;
  }
  return false;
}
const focusableSelector = ["button", "input", "select", "textarea", "[tabindex]", "[href]"].map((s) => `${s}:not([disabled])`).join(", ");
function focusChildElementByKey(referenceElement, parentElement, key3, beforeFocus) {
  const focusableElements = Array.from(parentElement.querySelectorAll(focusableSelector)).filter(
    (element) => !isDisplayNoneElement(element)
  );
  if (!focusableElements.length) {
    return;
  }
  const isActiveInReferenceElements = [referenceElement, ...Array.from(referenceElement.querySelectorAll(focusableSelector))].findIndex(
    (el) => el === document.activeElement
  ) !== -1;
  const activeElementIndex = Array.from(focusableElements).findIndex((el) => el === document.activeElement);
  if (key3 === "ArrowDown") {
    if (isActiveInReferenceElements && activeElementIndex === -1 || activeElementIndex === focusableElements.length - 1) {
      focus(focusableElements[0]);
      return;
    }
    if (activeElementIndex !== -1 && activeElementIndex < focusableElements.length - 1) {
      focus(focusableElements[activeElementIndex + 1]);
      return;
    }
  }
  if (key3 === "ArrowUp") {
    if (isActiveInReferenceElements && activeElementIndex === -1 || activeElementIndex === 0) {
      focus(focusableElements[focusableElements.length - 1]);
      return;
    }
    if (activeElementIndex > 0) {
      focus(focusableElements[activeElementIndex - 1]);
    }
  }
  function focus(nextActiveElement) {
    if (beforeFocus && !beforeFocus(document.activeElement, nextActiveElement, isActiveInReferenceElements)) {
      return;
    }
    nextActiveElement.focus();
  }
}
const props$1j = {
  name: String,
  size: [Number, String],
  color: String,
  namespace: {
    type: String,
    default: "var-icon"
  },
  transition: {
    type: [Number, String],
    default: 0
  },
  animationClass: String,
  onClick: defineListenerProp()
};
var __async$k = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const { name: name$1m, n: n$1t, classes: classes$1a } = createNamespace("icon");
function __render__$1r(_ctx, _cache) {
  return vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.isURL(_ctx.name) ? "img" : "i"), {
    class: vue.normalizeClass(
      _ctx.classes(
        _ctx.n(),
        [_ctx.namespace !== _ctx.n(), _ctx.namespace],
        `${_ctx.namespace}--set`,
        [_ctx.isURL(_ctx.name), _ctx.n("image"), `${_ctx.namespace}-${_ctx.nextName}`],
        [_ctx.animateInProgress, _ctx.animationClass == null ? _ctx.n("--shrinking") : _ctx.animationClass]
      )
    ),
    style: vue.normalizeStyle({
      color: _ctx.color,
      "transition-duration": `${_ctx.toNumber(_ctx.transition)}ms`,
      width: _ctx.isURL(_ctx.name) ? _ctx.toSizeUnit(_ctx.size) : null,
      height: _ctx.isURL(_ctx.name) ? _ctx.toSizeUnit(_ctx.size) : null,
      fontSize: _ctx.toSizeUnit(_ctx.size)
    }),
    src: _ctx.isURL(_ctx.name) ? _ctx.nextName : null,
    onClick: _ctx.onClick
  }, null, 8, ["class", "style", "src", "onClick"]);
}
const __sfc__$1u = vue.defineComponent({
  name: name$1m,
  props: props$1j,
  setup(props2) {
    const nextName = vue.ref("");
    const animateInProgress = vue.ref(false);
    vue.watch(() => props2.name, handleNameChange, { immediate: true });
    function handleNameChange(newName, oldName) {
      return __async$k(this, null, function* () {
        const { transition } = props2;
        if (oldName == null || toNumber(transition) === 0) {
          nextName.value = newName;
          return;
        }
        animateInProgress.value = true;
        yield vue.nextTick();
        setTimeout(() => {
          if (oldName != null) {
            nextName.value = newName;
          }
          animateInProgress.value = false;
        }, toNumber(transition));
      });
    }
    return {
      nextName,
      animateInProgress,
      n: n$1t,
      classes: classes$1a,
      isURL,
      toNumber,
      toSizeUnit
    };
  }
});
__sfc__$1u.render = __render__$1r;
var stdin_default$5$ = __sfc__$1u;
withInstall(stdin_default$5$);
withPropsDefaultsSetter(stdin_default$5$, props$1j);
const _IconComponent = stdin_default$5$;
var stdin_default$5_ = stdin_default$5$;
const { name: name$1l, n: n$1s, classes: classes$19 } = createNamespace("action-sheet");
function __render__$1q(_ctx, _cache) {
  const _component_var_icon = vue.resolveComponent("var-icon");
  const _component_var_hover_overlay = vue.resolveComponent("var-hover-overlay");
  const _directive_ripple = vue.resolveDirective("ripple");
  const _directive_hover = vue.resolveDirective("hover");
  return vue.withDirectives((vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.classes(_ctx.n("action-item"), _ctx.className, [_ctx.disabled, _ctx.n("--disabled")])),
      style: vue.normalizeStyle({ color: _ctx.color })
    },
    [
      _ctx.icon ? (vue.openBlock(), vue.createBlock(_component_var_icon, {
        key: 0,
        "var-action-sheet-cover": "",
        class: vue.normalizeClass(_ctx.n("action-icon")),
        namespace: _ctx.namespace,
        name: _ctx.icon,
        size: _ctx.iconSize
      }, null, 8, ["class", "namespace", "name", "size"])) : vue.createCommentVNode("v-if", true),
      vue.createElementVNode(
        "div",
        {
          class: vue.normalizeClass(_ctx.n("action-name"))
        },
        vue.toDisplayString(_ctx.name),
        3
        /* TEXT, CLASS */
      ),
      vue.createVNode(_component_var_hover_overlay, {
        hovering: _ctx.disabled ? false : _ctx.hovering
      }, null, 8, ["hovering"])
    ],
    6
    /* CLASS, STYLE */
  )), [
    [_directive_ripple, { disabled: _ctx.disabled }],
    [_directive_hover, _ctx.handleHovering, "desktop"]
  ]);
}
const __sfc__$1t = vue.defineComponent({
  name: name$1l,
  components: {
    VarHoverOverlay: stdin_default$60,
    VarIcon: stdin_default$5_
  },
  directives: { Ripple: stdin_default$63, Hover: stdin_default$62 },
  props: {
    name: String,
    className: String,
    disabled: Boolean,
    color: String,
    namespace: String,
    iconSize: [String, Number],
    icon: String
  },
  setup() {
    const { hovering, handleHovering } = useHoverOverlay();
    return {
      hovering,
      n: n$1s,
      classes: classes$19,
      handleHovering
    };
  }
});
__sfc__$1t.render = __render__$1q;
var stdin_default$5Z = __sfc__$1t;
var __defProp$v = Object.defineProperty;
var __getOwnPropSymbols$v = Object.getOwnPropertySymbols;
var __hasOwnProp$v = Object.prototype.hasOwnProperty;
var __propIsEnum$v = Object.prototype.propertyIsEnumerable;
var __defNormalProp$v = (obj, key3, value) => key3 in obj ? __defProp$v(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$v = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$v.call(b, prop))
      __defNormalProp$v(a, prop, b[prop]);
  if (__getOwnPropSymbols$v)
    for (var prop of __getOwnPropSymbols$v(b)) {
      if (__propIsEnum$v.call(b, prop))
        __defNormalProp$v(a, prop, b[prop]);
    }
  return a;
};
const props$1i = __spreadValues$v({
  show: Boolean,
  title: String,
  actions: {
    type: Array,
    default: () => []
  },
  closeOnClickAction: {
    type: Boolean,
    default: true
  },
  onSelect: defineListenerProp(),
  "onUpdate:show": defineListenerProp()
}, pickProps(props$1l, [
  "overlay",
  "overlayClass",
  "overlayStyle",
  "lockScroll",
  "closeOnClickOverlay",
  "closeOnKeyEscape",
  "safeArea",
  "teleport",
  "onOpen",
  "onClose",
  "onOpened",
  "onClosed",
  "onClickOverlay",
  // internal for function call closes the dialog
  "onRouteChange",
  "onKeyEscape"
]));
const { name: name$1k, n: n$1r, classes: classes$18 } = createNamespace("action-sheet");
function __render__$1p(_ctx, _cache) {
  const _component_var_action_item = vue.resolveComponent("var-action-item");
  const _component_var_popup = vue.resolveComponent("var-popup");
  return vue.openBlock(), vue.createBlock(_component_var_popup, {
    show: _ctx.show,
    "onUpdate:show": _cache[0] || (_cache[0] = ($event) => _ctx.show = $event),
    position: "bottom",
    class: vue.normalizeClass(_ctx.n("popup-radius")),
    overlay: _ctx.overlay,
    "overlay-class": _ctx.overlayClass,
    "overlay-style": _ctx.overlayStyle,
    "lock-scroll": _ctx.lockScroll,
    "close-on-click-overlay": _ctx.closeOnClickOverlay,
    "close-on-key-escape": _ctx.closeOnKeyEscape,
    teleport: _ctx.teleport,
    "safe-area": _ctx.safeArea,
    onOpen: _ctx.onOpen,
    onClose: _ctx.onClose,
    onClosed: _ctx.onClosed,
    onOpened: _ctx.onOpened,
    onRouteChange: _ctx.onRouteChange,
    onKeyEscape: _ctx.onKeyEscape
  }, {
    default: vue.withCtx(() => [
      vue.createElementVNode(
        "div",
        vue.mergeProps({
          class: _ctx.classes(_ctx.n(), _ctx.n("$--box"))
        }, _ctx.$attrs),
        [
          vue.renderSlot(_ctx.$slots, "title", {}, () => {
            var _a;
            return [
              vue.createElementVNode(
                "div",
                {
                  class: vue.normalizeClass(_ctx.n("title"))
                },
                vue.toDisplayString((_a = _ctx.title) != null ? _a : (_ctx.pt ? _ctx.pt : _ctx.t)("actionSheetTitle")),
                3
                /* TEXT, CLASS */
              )
            ];
          }),
          vue.renderSlot(_ctx.$slots, "actions", {}, () => [
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList(_ctx.actions, (action) => {
                return vue.openBlock(), vue.createBlock(_component_var_action_item, {
                  key: action.name,
                  name: action.name,
                  namespace: action.namespace,
                  icon: action.icon,
                  "icon-size": action.iconSize,
                  "class-name": action.className,
                  color: action.color,
                  onClick: ($event) => _ctx.handleSelect(action)
                }, null, 8, ["name", "namespace", "icon", "icon-size", "class-name", "color", "onClick"]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ])
        ],
        16
        /* FULL_PROPS */
      )
    ]),
    _: 3
    /* FORWARDED */
  }, 8, ["show", "class", "overlay", "overlay-class", "overlay-style", "lock-scroll", "close-on-click-overlay", "close-on-key-escape", "teleport", "safe-area", "onOpen", "onClose", "onClosed", "onOpened", "onRouteChange", "onKeyEscape"]);
}
const __sfc__$1s = vue.defineComponent({
  name: name$1k,
  directives: { Ripple: stdin_default$63 },
  components: {
    VarPopup: stdin_default$64,
    VarActionItem: stdin_default$5Z
  },
  inheritAttrs: false,
  props: props$1i,
  setup(props2) {
    const show = useVModel(props2, "show");
    const { t: pt } = injectLocaleProvider();
    function handleSelect(action) {
      if (action.disabled) {
        return;
      }
      const { closeOnClickAction, onSelect } = props2;
      call(onSelect, action);
      if (closeOnClickAction) {
        show.value = false;
      }
    }
    return {
      show,
      pt,
      t,
      n: n$1r,
      classes: classes$18,
      handleSelect
    };
  }
});
__sfc__$1s.render = __render__$1p;
var stdin_default$5Y = __sfc__$1s;
var __defProp$u = Object.defineProperty;
var __getOwnPropSymbols$u = Object.getOwnPropertySymbols;
var __hasOwnProp$u = Object.prototype.hasOwnProperty;
var __propIsEnum$u = Object.prototype.propertyIsEnumerable;
var __defNormalProp$u = (obj, key3, value) => key3 in obj ? __defProp$u(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$u = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$u.call(b, prop))
      __defNormalProp$u(a, prop, b[prop]);
  if (__getOwnPropSymbols$u)
    for (var prop of __getOwnPropSymbols$u(b)) {
      if (__propIsEnum$u.call(b, prop))
        __defNormalProp$u(a, prop, b[prop]);
    }
  return a;
};
let singletonOptions$3;
let defaultOptions$3 = {};
function normalizeOptions$3(options = {}) {
  return __spreadValues$u(__spreadValues$u({}, defaultOptions$3), options);
}
function ActionSheet(options) {
  if (!inBrowser()) {
    return Promise.resolve();
  }
  return new Promise((resolve) => {
    ActionSheet.close();
    const reactiveActionSheetOptions = vue.reactive(normalizeOptions$3(options));
    reactiveActionSheetOptions.teleport = "body";
    singletonOptions$3 = reactiveActionSheetOptions;
    const { unmountInstance } = mountInstance(stdin_default$5Y, reactiveActionSheetOptions, {
      onSelect: (action) => {
        call(reactiveActionSheetOptions.onSelect, action);
        resolve(action);
      },
      onClose: () => {
        call(reactiveActionSheetOptions.onClose);
        resolve("close");
      },
      onClosed: () => {
        call(reactiveActionSheetOptions.onClosed);
        unmountInstance();
        singletonOptions$3 === reactiveActionSheetOptions && (singletonOptions$3 = null);
      },
      onRouteChange: () => {
        unmountInstance();
        singletonOptions$3 === reactiveActionSheetOptions && (singletonOptions$3 = null);
      },
      "onUpdate:show": (value) => {
        reactiveActionSheetOptions.show = value;
      }
    });
    reactiveActionSheetOptions.show = true;
  });
}
ActionSheet.setDefaultOptions = function(options) {
  defaultOptions$3 = options;
};
ActionSheet.resetDefaultOptions = function() {
  defaultOptions$3 = {};
};
ActionSheet.close = function() {
  if (singletonOptions$3 != null) {
    const prevSingletonOptions = singletonOptions$3;
    singletonOptions$3 = null;
    vue.nextTick().then(() => {
      prevSingletonOptions.show = false;
    });
  }
};
ActionSheet.Component = stdin_default$5Y;
withInstall(stdin_default$5Y);
withInstall(stdin_default$5Y, ActionSheet);
withPropsDefaultsSetter(ActionSheet, props$1i);
const _ActionSheetComponent = stdin_default$5Y;
var stdin_default$5X = ActionSheet;
const props$1h = {
  type: {
    type: String,
    default: "info"
  },
  variant: {
    type: String,
    default: "standard"
  },
  color: String,
  title: String,
  message: String,
  closeable: Boolean,
  elevation: {
    type: [Boolean, String, Number],
    default: false
  },
  onClose: defineListenerProp()
};
const { name: name$1j, n: n$1q, classes: classes$17 } = createNamespace("alert");
const iconTypeMap = {
  success: "checkbox-marked-circle",
  warning: "warning",
  info: "information",
  danger: "error"
};
function __render__$1o(_ctx, _cache) {
  const _component_var_icon = vue.resolveComponent("var-icon");
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.classes(_ctx.n(), _ctx.n("$--box"), _ctx.n(`--${_ctx.variant}`), _ctx.n(`--${_ctx.type}`), _ctx.formatElevation(_ctx.elevation, 2))),
      style: vue.normalizeStyle({
        "background-color": _ctx.color
      }),
      role: "alert"
    },
    [
      _ctx.isInternalType || _ctx.$slots["icon"] ? (vue.openBlock(), vue.createElementBlock(
        "div",
        {
          key: 0,
          class: vue.normalizeClass(_ctx.n("icon"))
        },
        [
          vue.renderSlot(_ctx.$slots, "icon", {}, () => [
            _ctx.isInternalType ? (vue.openBlock(), vue.createBlock(_component_var_icon, {
              key: 0,
              name: _ctx.iconTypeMap[_ctx.type]
            }, null, 8, ["name"])) : vue.createCommentVNode("v-if", true)
          ])
        ],
        2
        /* CLASS */
      )) : vue.createCommentVNode("v-if", true),
      vue.renderSlot(_ctx.$slots, "content", {}, () => [
        vue.createElementVNode(
          "div",
          {
            class: vue.normalizeClass(_ctx.n("content"))
          },
          [
            _ctx.title || _ctx.$slots["title"] ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 0,
                class: vue.normalizeClass(_ctx.n("title"))
              },
              [
                vue.renderSlot(_ctx.$slots, "title", {}, () => [
                  vue.createTextVNode(
                    vue.toDisplayString(_ctx.title),
                    1
                    /* TEXT */
                  )
                ])
              ],
              2
              /* CLASS */
            )) : vue.createCommentVNode("v-if", true),
            _ctx.message || _ctx.$slots["default"] ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 1,
                class: vue.normalizeClass(_ctx.n("message"))
              },
              [
                vue.renderSlot(_ctx.$slots, "default", {}, () => [
                  vue.createTextVNode(
                    vue.toDisplayString(_ctx.message),
                    1
                    /* TEXT */
                  )
                ])
              ],
              2
              /* CLASS */
            )) : vue.createCommentVNode("v-if", true)
          ],
          2
          /* CLASS */
        )
      ]),
      _ctx.closeable ? (vue.openBlock(), vue.createElementBlock(
        "div",
        {
          key: 1,
          class: vue.normalizeClass(_ctx.n("close-icon")),
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClose && _ctx.handleClose(...args))
        },
        [
          vue.renderSlot(_ctx.$slots, "close-icon", {}, () => [
            vue.createVNode(_component_var_icon, { name: "close-circle" })
          ])
        ],
        2
        /* CLASS */
      )) : vue.createCommentVNode("v-if", true)
    ],
    6
    /* CLASS, STYLE */
  );
}
const __sfc__$1r = vue.defineComponent({
  name: name$1j,
  components: {
    VarIcon: stdin_default$5_
  },
  props: props$1h,
  setup(props2) {
    const isInternalType = vue.computed(() => ["info", "success", "danger", "warning"].includes(props2.type));
    function handleClose(e) {
      call(props2.onClose, e);
    }
    return {
      n: n$1q,
      classes: classes$17,
      iconTypeMap,
      isInternalType,
      formatElevation,
      handleClose
    };
  }
});
__sfc__$1r.render = __render__$1o;
var stdin_default$5W = __sfc__$1r;
withInstall(stdin_default$5W);
withPropsDefaultsSetter(stdin_default$5W, props$1h);
const _AlertComponent = stdin_default$5W;
var stdin_default$5V = stdin_default$5W;
const props$1g = {
  color: String,
  textColor: String,
  title: String,
  titlePosition: {
    type: String,
    default: "left"
  },
  elevation: {
    type: [Boolean, String, Number],
    default: true
  },
  round: Boolean,
  image: String,
  imageLinearGradient: String,
  safeAreaTop: Boolean,
  border: Boolean,
  zIndex: {
    type: [Number, String],
    default: 1
  },
  fixed: Boolean,
  placeholder: Boolean
};
const { name: name$1i, n: n$1p, classes: classes$16 } = createNamespace("app-bar");
function __render__$1n(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock(
    vue.Fragment,
    null,
    [
      vue.createElementVNode(
        "div",
        vue.mergeProps({
          ref: "appBar",
          class: _ctx.classes(
            _ctx.n(),
            _ctx.n("$--box"),
            [_ctx.safeAreaTop, _ctx.n("--safe-area-top")],
            [_ctx.round, _ctx.n("--round")],
            [_ctx.fixed, _ctx.n("--fixed")],
            [_ctx.border, _ctx.n("--border")],
            _ctx.formatElevation(_ctx.elevation, 3)
          ),
          style: _ctx.rootStyles
        }, _ctx.$attrs),
        [
          vue.createElementVNode(
            "div",
            {
              class: vue.normalizeClass(_ctx.n("toolbar"))
            },
            [
              vue.createElementVNode(
                "div",
                {
                  class: vue.normalizeClass(_ctx.n("left"))
                },
                [
                  vue.renderSlot(_ctx.$slots, "left"),
                  _ctx.titlePosition === "left" ? (vue.openBlock(), vue.createElementBlock(
                    "div",
                    {
                      key: 0,
                      class: vue.normalizeClass(_ctx.n("title")),
                      style: vue.normalizeStyle({ paddingLeft: _ctx.paddingLeft })
                    },
                    [
                      vue.renderSlot(_ctx.$slots, "default", {}, () => [
                        vue.createTextVNode(
                          vue.toDisplayString(_ctx.title),
                          1
                          /* TEXT */
                        )
                      ])
                    ],
                    6
                    /* CLASS, STYLE */
                  )) : vue.createCommentVNode("v-if", true)
                ],
                2
                /* CLASS */
              ),
              _ctx.titlePosition === "center" ? (vue.openBlock(), vue.createElementBlock(
                "div",
                {
                  key: 0,
                  class: vue.normalizeClass(_ctx.n("title"))
                },
                [
                  vue.renderSlot(_ctx.$slots, "default", {}, () => [
                    vue.createTextVNode(
                      vue.toDisplayString(_ctx.title),
                      1
                      /* TEXT */
                    )
                  ])
                ],
                2
                /* CLASS */
              )) : vue.createCommentVNode("v-if", true),
              vue.createElementVNode(
                "div",
                {
                  class: vue.normalizeClass(_ctx.n("right"))
                },
                [
                  _ctx.titlePosition === "right" ? (vue.openBlock(), vue.createElementBlock(
                    "div",
                    {
                      key: 0,
                      class: vue.normalizeClass(_ctx.n("title")),
                      style: vue.normalizeStyle({ paddingRight: _ctx.paddingRight })
                    },
                    [
                      vue.renderSlot(_ctx.$slots, "default", {}, () => [
                        vue.createTextVNode(
                          vue.toDisplayString(_ctx.title),
                          1
                          /* TEXT */
                        )
                      ])
                    ],
                    6
                    /* CLASS, STYLE */
                  )) : vue.createCommentVNode("v-if", true),
                  vue.renderSlot(_ctx.$slots, "right")
                ],
                2
                /* CLASS */
              )
            ],
            2
            /* CLASS */
          ),
          vue.renderSlot(_ctx.$slots, "content")
        ],
        16
        /* FULL_PROPS */
      ),
      _ctx.fixed && _ctx.placeholder ? (vue.openBlock(), vue.createElementBlock(
        "div",
        {
          key: 0,
          class: vue.normalizeClass(_ctx.n("placeholder")),
          style: vue.normalizeStyle({ height: _ctx.placeholderHeight })
        },
        null,
        6
        /* CLASS, STYLE */
      )) : vue.createCommentVNode("v-if", true)
    ],
    64
    /* STABLE_FRAGMENT */
  );
}
const __sfc__$1q = vue.defineComponent({
  name: name$1i,
  props: props$1g,
  setup(props2, { slots }) {
    const appBar = vue.ref(null);
    const paddingLeft = vue.ref();
    const paddingRight = vue.ref();
    const placeholderHeight = vue.ref();
    const rootStyles = vue.computed(() => {
      const { image, color, textColor, imageLinearGradient, zIndex } = props2;
      if (image != null) {
        const gradient = imageLinearGradient ? `linear-gradient(${imageLinearGradient}), ` : "";
        return {
          "background-image": `${gradient}url(${image})`,
          "background-position": "center center",
          "background-size": "cover",
          "z-index": zIndex
        };
      }
      return {
        background: color,
        color: textColor,
        "z-index": zIndex
      };
    });
    onWindowResize(resizePlaceholder);
    onSmartMounted(() => {
      computePadding();
      resizePlaceholder();
    });
    vue.onUpdated(computePadding);
    function computePadding() {
      paddingLeft.value = slots.left ? 0 : void 0;
      paddingRight.value = slots.right ? 0 : void 0;
    }
    function resizePlaceholder() {
      if (!props2.fixed || !props2.placeholder) {
        return;
      }
      const { height } = getRect(appBar.value);
      placeholderHeight.value = toSizeUnit(height);
    }
    return {
      rootStyles,
      paddingLeft,
      paddingRight,
      n: n$1p,
      classes: classes$16,
      formatElevation,
      appBar,
      placeholderHeight
    };
  }
});
__sfc__$1q.render = __render__$1n;
var stdin_default$5U = __sfc__$1q;
withInstall(stdin_default$5U);
withPropsDefaultsSetter(stdin_default$5U, props$1g);
const _AppBarComponent = stdin_default$5U;
var stdin_default$5T = stdin_default$5U;
const props$1f = {
  errorMessage: {
    type: String,
    default: ""
  },
  extraMessage: {
    type: String,
    default: ""
  }
};
const { name: name$1h, n: n$1o } = createNamespace("form-details");
const _hoisted_1$A = { key: 0 };
const _hoisted_2$9 = { key: 0 };
function __render__$1m(_ctx, _cache) {
  return vue.openBlock(), vue.createBlock(vue.Transition, {
    name: _ctx.n()
  }, {
    default: vue.withCtx(() => [
      _ctx.errorMessage || _ctx.extraMessage || _ctx.$slots["extra-message"] ? (vue.openBlock(), vue.createElementBlock(
        "div",
        {
          key: 0,
          class: vue.normalizeClass(_ctx.n())
        },
        [
          vue.createElementVNode(
            "div",
            {
              class: vue.normalizeClass(_ctx.n("error-message"))
            },
            [
              vue.createVNode(vue.Transition, {
                name: _ctx.n("message")
              }, {
                default: vue.withCtx(() => [
                  _ctx.errorMessage ? (vue.openBlock(), vue.createElementBlock(
                    "div",
                    _hoisted_1$A,
                    vue.toDisplayString(_ctx.errorMessage),
                    1
                    /* TEXT */
                  )) : vue.createCommentVNode("v-if", true)
                ]),
                _: 1
                /* STABLE */
              }, 8, ["name"])
            ],
            2
            /* CLASS */
          ),
          vue.createElementVNode(
            "div",
            {
              class: vue.normalizeClass(_ctx.n("extra-message"))
            },
            [
              vue.createVNode(vue.Transition, {
                name: _ctx.n("message")
              }, {
                default: vue.withCtx(() => [
                  vue.renderSlot(_ctx.$slots, "extra-message", {}, () => [
                    _ctx.extraMessage ? (vue.openBlock(), vue.createElementBlock(
                      "div",
                      _hoisted_2$9,
                      vue.toDisplayString(_ctx.extraMessage),
                      1
                      /* TEXT */
                    )) : vue.createCommentVNode("v-if", true)
                  ])
                ]),
                _: 3
                /* FORWARDED */
              }, 8, ["name"])
            ],
            2
            /* CLASS */
          )
        ],
        2
        /* CLASS */
      )) : vue.createCommentVNode("v-if", true)
    ]),
    _: 3
    /* FORWARDED */
  }, 8, ["name"]);
}
const __sfc__$1p = vue.defineComponent({
  name: name$1h,
  props: props$1f,
  setup: () => ({ n: n$1o })
});
__sfc__$1p.render = __render__$1m;
var stdin_default$5S = __sfc__$1p;
withInstall(stdin_default$5S);
withPropsDefaultsSetter(stdin_default$5S, props$1f);
const _FormDetailsComponent = stdin_default$5S;
var stdin_default$5R = stdin_default$5S;
var __defProp$t = Object.defineProperty;
var __defProps$b = Object.defineProperties;
var __getOwnPropDescs$b = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$t = Object.getOwnPropertySymbols;
var __hasOwnProp$t = Object.prototype.hasOwnProperty;
var __propIsEnum$t = Object.prototype.propertyIsEnumerable;
var __defNormalProp$t = (obj, key3, value) => key3 in obj ? __defProp$t(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$t = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$t.call(b, prop))
      __defNormalProp$t(a, prop, b[prop]);
  if (__getOwnPropSymbols$t)
    for (var prop of __getOwnPropSymbols$t(b)) {
      if (__propIsEnum$t.call(b, prop))
        __defNormalProp$t(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$b = (a, b) => __defProps$b(a, __getOwnPropDescs$b(b));
const FORM_BIND_FORM_ITEM_KEY = Symbol("FORM_BIND_FORM_ITEM_KEY");
function useForm() {
  const { parentProvider, index, bindParent } = useParent(FORM_BIND_FORM_ITEM_KEY);
  const instance = vue.getCurrentInstance();
  const bindForm = bindParent ? (formItemProvider) => {
    bindParent(__spreadProps$b(__spreadValues$t({}, formItemProvider), { instance }));
  } : null;
  return {
    index,
    form: parentProvider,
    bindForm
  };
}
function useFormItems() {
  const { childProviders, length, bindChildren } = useChildren(FORM_BIND_FORM_ITEM_KEY);
  return {
    length,
    formItems: childProviders,
    bindFormItems: bindChildren
  };
}
const SWIPE_BIND_SWIPE_ITEM_KEY = Symbol("SWIPE_BIND_SWIPE_ITEM_KEY");
const SWIPE_RESIZE_DISPATCHER_BIND_SWIPE_RESIZE_LISTENER_KEY = Symbol(
  "SWIPE_RESIZE_DISPATCHER_BIND_SWIPE_RESIZE_LISTENER_KEY"
);
function useSwipeItems() {
  const { childProviders, length, bindChildren } = useChildren(
    SWIPE_BIND_SWIPE_ITEM_KEY
  );
  return {
    length,
    swipeItems: childProviders,
    bindSwipeItems: bindChildren
  };
}
function useSwipeResizeListeners() {
  const { childProviders, bindChildren } = useChildren(
    SWIPE_RESIZE_DISPATCHER_BIND_SWIPE_RESIZE_LISTENER_KEY
  );
  return {
    swipeResizeListeners: childProviders,
    bindSwipeResizeListeners: bindChildren
  };
}
function useSwipeResizeDispatcher() {
  const { parentProvider, bindParent } = useParent(
    SWIPE_RESIZE_DISPATCHER_BIND_SWIPE_RESIZE_LISTENER_KEY
  );
  return {
    swipeResizeDispatcher: parentProvider,
    bindSwipeResizeDispatcher: bindParent
  };
}
const props$1e = {
  value: {
    type: null,
    required: true
  },
  id: {
    type: String,
    default: ""
  },
  isFocusing: Boolean,
  size: {
    type: String,
    default: "normal"
  },
  variant: {
    type: String,
    default: "standard"
  },
  placeholder: String,
  line: {
    type: Boolean,
    default: true
  },
  hint: {
    type: Boolean,
    default: true
  },
  hintCenter: {
    type: Boolean,
    default: true
  },
  textColor: String,
  focusColor: String,
  blurColor: String,
  isError: Boolean,
  formDisabled: Boolean,
  disabled: Boolean,
  clearable: Boolean,
  cursor: String,
  composing: Boolean,
  onClick: defineListenerProp(),
  onClear: defineListenerProp()
};
var __async$j = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const { name: name$1g, n: n$1n, classes: classes$15 } = createNamespace("field-decorator");
const _hoisted_1$z = ["for"];
function __render__$1l(_ctx, _cache) {
  const _component_var_icon = vue.resolveComponent("var-icon");
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.classes(_ctx.n(), _ctx.n("$--box"), _ctx.n(`--${_ctx.variant}`), [_ctx.size === "small", _ctx.n("--small")], [_ctx.disabled, _ctx.n("--disabled")])),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    },
    [
      vue.createElementVNode(
        "div",
        {
          class: vue.normalizeClass(
            _ctx.classes(
              _ctx.n("controller"),
              [_ctx.isFocusing, _ctx.n("--focus")],
              [_ctx.isError, _ctx.n("--error")],
              [_ctx.formDisabled || _ctx.disabled, _ctx.n("--disabled")]
            )
          ),
          style: vue.normalizeStyle({
            color: _ctx.color,
            cursor: _ctx.cursor,
            overflow: _ctx.isFloating ? "visible" : "hidden",
            "--field-decorator-middle-offset-left": _ctx.middleOffsetLeft,
            "--field-decorator-middle-offset-width": _ctx.middleOffsetWidth,
            "--field-decorator-middle-offset-height": _ctx.middleOffsetHeight
          })
        },
        [
          vue.createElementVNode(
            "div",
            {
              class: vue.normalizeClass(_ctx.classes(_ctx.n("icon"), [!_ctx.hint, _ctx.n("--icon-non-hint")]))
            },
            [
              vue.renderSlot(_ctx.$slots, "prepend-icon")
            ],
            2
            /* CLASS */
          ),
          vue.createElementVNode(
            "div",
            {
              ref: "middleEl",
              class: vue.normalizeClass(_ctx.classes(_ctx.n("middle"), [!_ctx.hint, _ctx.n("--middle-non-hint")]))
            },
            [
              vue.renderSlot(_ctx.$slots, "default")
            ],
            2
            /* CLASS */
          ),
          _ctx.placeholder && _ctx.hint ? (vue.openBlock(), vue.createElementBlock("label", {
            key: 0,
            class: vue.normalizeClass(
              _ctx.classes(
                _ctx.n("placeholder"),
                _ctx.n("$--ellipsis"),
                [_ctx.isFocusing, _ctx.n("--focus")],
                [_ctx.hintCenter, _ctx.n("--hint-center")],
                [_ctx.formDisabled || _ctx.disabled, _ctx.n("--disabled")],
                [_ctx.isError, _ctx.n("--error")],
                [_ctx.transitionDisabled, _ctx.n("--transition-disabled")],
                _ctx.computePlaceholderState()
              )
            ),
            style: vue.normalizeStyle({
              color: _ctx.color
            }),
            for: _ctx.id
          }, [
            vue.createElementVNode(
              "span",
              null,
              vue.toDisplayString(_ctx.placeholder),
              1
              /* TEXT */
            )
          ], 14, _hoisted_1$z)) : vue.createCommentVNode("v-if", true),
          vue.createElementVNode(
            "div",
            {
              class: vue.normalizeClass(_ctx.classes(_ctx.n("icon"), [!_ctx.hint, _ctx.n("--icon-non-hint")]))
            },
            [
              _ctx.clearable && !_ctx.isEmpty(_ctx.value) ? vue.renderSlot(_ctx.$slots, "clear-icon", {
                key: 0,
                clear: _ctx.handleClear
              }, () => [
                vue.createVNode(_component_var_icon, {
                  class: vue.normalizeClass(_ctx.n("clear-icon")),
                  "var-field-decorator-cover": "",
                  name: "close-circle",
                  onClick: _ctx.handleClear
                }, null, 8, ["class", "onClick"])
              ]) : vue.createCommentVNode("v-if", true),
              vue.renderSlot(_ctx.$slots, "append-icon")
            ],
            2
            /* CLASS */
          )
        ],
        6
        /* CLASS, STYLE */
      ),
      _ctx.line ? (vue.openBlock(), vue.createElementBlock(
        vue.Fragment,
        { key: 0 },
        [
          _ctx.variant === "outlined" ? (vue.openBlock(), vue.createElementBlock(
            "fieldset",
            {
              key: 0,
              class: vue.normalizeClass(
                _ctx.classes(
                  _ctx.n("line"),
                  [_ctx.isFocusing, _ctx.n("--line-focus")],
                  [_ctx.isError, _ctx.n("--line-error")],
                  [_ctx.formDisabled || _ctx.disabled, _ctx.n("--line-disabled")]
                )
              ),
              style: vue.normalizeStyle({ borderColor: _ctx.color })
            },
            [
              vue.createElementVNode(
                "legend",
                {
                  class: vue.normalizeClass(_ctx.classes(_ctx.n("line-legend"), [_ctx.isFloating, _ctx.n("line-legend--hint")])),
                  style: vue.normalizeStyle({ width: _ctx.legendWidth })
                },
                [
                  _ctx.placeholder && _ctx.hint ? (vue.openBlock(), vue.createBlock(vue.Teleport, {
                    key: 0,
                    to: "body"
                  }, [
                    vue.createElementVNode(
                      "span",
                      {
                        ref: "placeholderTextEl",
                        class: vue.normalizeClass(
                          _ctx.classes(_ctx.n("placeholder-text"), _ctx.n("$--ellipsis"), [_ctx.size === "small", _ctx.n("placeholder-text--small")])
                        )
                      },
                      vue.toDisplayString(_ctx.placeholder),
                      3
                      /* TEXT, CLASS */
                    )
                  ])) : vue.createCommentVNode("v-if", true)
                ],
                6
                /* CLASS, STYLE */
              )
            ],
            6
            /* CLASS, STYLE */
          )) : (vue.openBlock(), vue.createElementBlock(
            "div",
            {
              key: 1,
              class: vue.normalizeClass(_ctx.classes(_ctx.n("line"), [_ctx.formDisabled || _ctx.disabled, _ctx.n("--line-disabled")], [_ctx.isError, _ctx.n("--line-error")])),
              style: vue.normalizeStyle({ background: !_ctx.isError ? _ctx.blurColor : void 0 })
            },
            [
              vue.createElementVNode(
                "div",
                {
                  class: vue.normalizeClass(
                    _ctx.classes(
                      _ctx.n("dot"),
                      [_ctx.isFocusing, _ctx.n("--line-focus")],
                      [_ctx.formDisabled || _ctx.disabled, _ctx.n("--line-disabled")],
                      [_ctx.isError, _ctx.n("--line-error")]
                    )
                  ),
                  style: vue.normalizeStyle({ background: !_ctx.isError ? _ctx.focusColor : void 0 })
                },
                null,
                6
                /* CLASS, STYLE */
              )
            ],
            6
            /* CLASS, STYLE */
          ))
        ],
        64
        /* STABLE_FRAGMENT */
      )) : vue.createCommentVNode("v-if", true)
    ],
    2
    /* CLASS */
  );
}
const __sfc__$1o = vue.defineComponent({
  name: name$1g,
  components: { VarIcon: stdin_default$5_ },
  props: props$1e,
  setup(props2) {
    const placeholderTextEl = vue.ref(null);
    const middleEl = vue.ref(null);
    const legendWidth = vue.ref("");
    const middleOffsetLeft = vue.ref("0px");
    const middleOffsetWidth = vue.ref("0px");
    const middleOffsetHeight = vue.ref("0px");
    const transitionDisabled = vue.ref(true);
    const isFloating = vue.computed(() => props2.hint && (!isEmpty(props2.value) || props2.isFocusing));
    const { popup, bindPopup } = usePopup();
    const { bindSwipeResizeDispatcher } = useSwipeResizeDispatcher();
    const color = vue.computed(
      () => !props2.isError ? props2.isFocusing ? props2.focusColor : props2.blurColor : void 0
    );
    onWindowResize(resize);
    onSmartMounted(() => {
      resize();
      vue.nextTick().then(() => {
        transitionDisabled.value = false;
      });
    });
    vue.onUpdated(resize);
    call(bindPopup, null);
    call(bindSwipeResizeDispatcher, {
      onResize() {
        vue.nextTick().then(resize);
      }
    });
    if (popup) {
      vue.watch(
        () => popup.show.value,
        (show) => __async$j(this, null, function* () {
          if (show) {
            yield doubleRaf();
            resize();
          }
        })
      );
    }
    function computePlaceholderState() {
      const { hint, value, composing } = props2;
      if (!hint && (!isEmpty(value) || composing)) {
        return n$1n("--placeholder-hidden");
      }
      if (isFloating.value) {
        return n$1n("--placeholder-hint");
      }
    }
    function handleClear(e) {
      call(props2.onClear, e);
    }
    function handleClick(e) {
      call(props2.onClick, e);
    }
    function resize() {
      middleOffsetLeft.value = `${middleEl.value.offsetLeft}px`;
      middleOffsetWidth.value = `${middleEl.value.offsetWidth}px`;
      middleOffsetHeight.value = `${middleEl.value.offsetHeight}px`;
      if (props2.variant === "outlined" && placeholderTextEl.value) {
        const placeholderTextStyle = getStyle$1(placeholderTextEl.value);
        const placeholderSpace = `var(--field-decorator-outlined-${props2.size}-placeholder-space)`;
        legendWidth.value = `calc(${placeholderTextStyle.width} * 0.75 + ${placeholderSpace} * 2)`;
      }
    }
    return {
      placeholderTextEl,
      middleEl,
      middleOffsetLeft,
      middleOffsetWidth,
      middleOffsetHeight,
      color,
      legendWidth,
      isFloating,
      transitionDisabled,
      resize,
      computePlaceholderState,
      n: n$1n,
      classes: classes$15,
      isEmpty,
      handleClear,
      handleClick
    };
  }
});
__sfc__$1o.render = __render__$1l;
var stdin_default$5Q = __sfc__$1o;
withInstall(stdin_default$5Q);
withPropsDefaultsSetter(stdin_default$5Q, props$1e);
const _FieldDecoratorComponent = stdin_default$5Q;
var stdin_default$5P = stdin_default$5Q;
var __defProp$s = Object.defineProperty;
var __defProps$a = Object.defineProperties;
var __getOwnPropDescs$a = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$s = Object.getOwnPropertySymbols;
var __hasOwnProp$s = Object.prototype.hasOwnProperty;
var __propIsEnum$s = Object.prototype.propertyIsEnumerable;
var __defNormalProp$s = (obj, key3, value) => key3 in obj ? __defProp$s(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$s = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$s.call(b, prop))
      __defNormalProp$s(a, prop, b[prop]);
  if (__getOwnPropSymbols$s)
    for (var prop of __getOwnPropSymbols$s(b)) {
      if (__propIsEnum$s.call(b, prop))
        __defNormalProp$s(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$a = (a, b) => __defProps$a(a, __getOwnPropDescs$a(b));
const props$1d = __spreadProps$a(__spreadValues$s({
  modelValue: String,
  modelModifiers: {
    type: Object,
    default: () => ({})
  },
  type: {
    type: String,
    default: "text"
  },
  textarea: Boolean,
  rows: {
    type: [String, Number],
    default: 8
  },
  maxlength: [String, Number],
  readonly: Boolean,
  resize: Boolean,
  autofocus: Boolean,
  validateTrigger: {
    type: Array,
    default: () => ["onInput", "onClear"]
  },
  rules: [Array, Function, Object],
  enterkeyhint: String,
  onFocus: defineListenerProp(),
  onBlur: defineListenerProp(),
  onInput: defineListenerProp(),
  onChange: defineListenerProp(),
  onClear: defineListenerProp(),
  "onUpdate:modelValue": defineListenerProp()
}, pickProps(props$1e, [
  "size",
  "variant",
  "placeholder",
  "line",
  "hint",
  "textColor",
  "focusColor",
  "blurColor",
  "disabled",
  "clearable",
  "onClick"
])), {
  // internal start
  autocomplete: String,
  isForceFocusingEffect: {
    type: Boolean,
    default: void 0
  },
  isForceErrorEffect: {
    type: Boolean,
    default: void 0
  },
  isShowFormDetails: {
    type: Boolean,
    default: true
  }
  // internal end
});
const { name: name$1f, n: n$1m, classes: classes$14 } = createNamespace("input");
const _hoisted_1$y = ["placeholder", "enterkeyhint"];
const _hoisted_2$8 = ["id", "autocomplete", "disabled", "readonly", "type", "value", "placeholder", "maxlength", "rows", "enterkeyhint", "inputmode"];
const _hoisted_3$4 = ["id", "autocomplete", "disabled", "readonly", "type", "value", "placeholder", "maxlength", "enterkeyhint", "inputmode"];
function __render__$1k(_ctx, _cache) {
  const _component_var_field_decorator = vue.resolveComponent("var-field-decorator");
  const _component_var_form_details = vue.resolveComponent("var-form-details");
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.classes(_ctx.n(), _ctx.n("$--box"))),
      onMousedown: _cache[12] || (_cache[12] = (...args) => _ctx.handleMousedown && _ctx.handleMousedown(...args))
    },
    [
      vue.createVNode(
        _component_var_field_decorator,
        vue.normalizeProps(vue.guardReactiveProps({
          value: _ctx.modelValue,
          id: _ctx.id,
          size: _ctx.size,
          variant: _ctx.variant,
          placeholder: _ctx.placeholder,
          line: _ctx.line,
          hint: _ctx.hint,
          textColor: _ctx.textColor,
          focusColor: _ctx.focusColor,
          blurColor: _ctx.blurColor,
          isFocusing: _ctx.isForceFocusingEffect != null ? _ctx.isForceFocusingEffect : _ctx.isFocusing,
          isError: _ctx.isForceErrorEffect != null ? _ctx.isForceErrorEffect : !!_ctx.errorMessage,
          formDisabled: _ctx.formDisabled,
          disabled: _ctx.disabled,
          clearable: _ctx.clearable,
          cursor: _ctx.cursor,
          composing: _ctx.isComposing,
          hintCenter: !_ctx.textarea,
          onClick: _ctx.handleClick,
          onClear: _ctx.handleClear
        })),
        vue.createSlots({
          "clear-icon": vue.withCtx(({ clear: clear2 }) => [
            vue.renderSlot(_ctx.$slots, "clear-icon", { clear: clear2 })
          ]),
          "append-icon": vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "append-icon")
          ]),
          default: vue.withCtx(() => [
            _ctx.normalizedType === "password" ? (vue.openBlock(), vue.createElementBlock("input", {
              key: 0,
              tabindex: "-1",
              class: vue.normalizeClass(_ctx.n("autocomplete")),
              placeholder: !_ctx.hint ? _ctx.placeholder : void 0,
              style: vue.normalizeStyle({
                "--input-placeholder-color": _ctx.placeholderColor
              }),
              enterkeyhint: _ctx.enterkeyhint
            }, null, 14, _hoisted_1$y)) : vue.createCommentVNode("v-if", true),
            _ctx.textarea ? (vue.openBlock(), vue.createElementBlock("textarea", {
              key: 1,
              id: _ctx.id,
              ref: "el",
              class: vue.normalizeClass(
                _ctx.classes(
                  _ctx.n("input"),
                  _ctx.n("--textarea"),
                  [_ctx.formDisabled || _ctx.disabled, _ctx.n("--disabled")],
                  [_ctx.errorMessage, _ctx.n("--error")],
                  [_ctx.errorMessage, _ctx.n("--caret-error")]
                )
              ),
              autocomplete: _ctx.autocomplete ? _ctx.autocomplete : "new-password",
              disabled: _ctx.formDisabled || _ctx.disabled,
              readonly: _ctx.formReadonly || _ctx.readonly,
              type: _ctx.normalizedType,
              value: _ctx.modelValue,
              placeholder: !_ctx.hint ? _ctx.placeholder : void 0,
              maxlength: _ctx.maxlength,
              rows: _ctx.rows,
              enterkeyhint: _ctx.enterkeyhint,
              inputmode: _ctx.type === "number" ? "decimal" : void 0,
              style: vue.normalizeStyle({
                color: !_ctx.errorMessage ? _ctx.textColor : void 0,
                caretColor: !_ctx.errorMessage ? _ctx.focusColor : void 0,
                resize: _ctx.resize ? "vertical" : "none",
                "--input-placeholder-color": _ctx.placeholderColor
              }),
              onFocus: _cache[0] || (_cache[0] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
              onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
              onInput: _cache[2] || (_cache[2] = (...args) => _ctx.handleInput && _ctx.handleInput(...args)),
              onChange: _cache[3] || (_cache[3] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
              onCompositionstart: _cache[4] || (_cache[4] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),
              onCompositionend: _cache[5] || (_cache[5] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args))
            }, null, 46, _hoisted_2$8)) : (vue.openBlock(), vue.createElementBlock("input", {
              key: 2,
              id: _ctx.id,
              ref: "el",
              class: vue.normalizeClass(
                _ctx.classes(
                  _ctx.n("input"),
                  [_ctx.formDisabled || _ctx.disabled, _ctx.n("--disabled")],
                  [_ctx.errorMessage, _ctx.n("--error")],
                  [_ctx.errorMessage, _ctx.n("--caret-error")]
                )
              ),
              autocomplete: _ctx.autocomplete ? _ctx.autocomplete : "new-password",
              disabled: _ctx.formDisabled || _ctx.disabled,
              readonly: _ctx.formReadonly || _ctx.readonly,
              type: _ctx.normalizedType,
              value: _ctx.modelValue,
              placeholder: !_ctx.hint ? _ctx.placeholder : void 0,
              maxlength: _ctx.maxlength,
              enterkeyhint: _ctx.enterkeyhint,
              inputmode: _ctx.type === "number" ? "decimal" : void 0,
              style: vue.normalizeStyle({
                color: !_ctx.errorMessage ? _ctx.textColor : void 0,
                caretColor: !_ctx.errorMessage ? _ctx.focusColor : void 0,
                "--input-placeholder-color": _ctx.placeholderColor
              }),
              onFocus: _cache[6] || (_cache[6] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
              onBlur: _cache[7] || (_cache[7] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
              onInput: _cache[8] || (_cache[8] = (...args) => _ctx.handleInput && _ctx.handleInput(...args)),
              onChange: _cache[9] || (_cache[9] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
              onCompositionstart: _cache[10] || (_cache[10] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),
              onCompositionend: _cache[11] || (_cache[11] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args))
            }, null, 46, _hoisted_3$4))
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          _ctx.$slots["prepend-icon"] ? {
            name: "prepend-icon",
            fn: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "prepend-icon")
            ]),
            key: "0"
          } : void 0
        ]),
        1040
        /* FULL_PROPS, DYNAMIC_SLOTS */
      ),
      _ctx.isShowFormDetails ? (vue.openBlock(), vue.createBlock(_component_var_form_details, {
        key: 0,
        "error-message": _ctx.errorMessage,
        "extra-message": _ctx.maxlengthText
      }, vue.createSlots({
        _: 2
        /* DYNAMIC */
      }, [
        _ctx.$slots["extra-message"] ? {
          name: "extra-message",
          fn: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "extra-message")
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["error-message", "extra-message"])) : vue.createCommentVNode("v-if", true)
    ],
    34
    /* CLASS, NEED_HYDRATION */
  );
}
const __sfc__$1n = vue.defineComponent({
  name: name$1f,
  components: {
    VarFormDetails: stdin_default$5R,
    VarFieldDecorator: stdin_default$5P
  },
  props: props$1d,
  setup(props2) {
    const id = useClientId();
    const el = vue.ref(null);
    const isFocusing = vue.ref(false);
    const isComposing = vue.ref(false);
    const { bindForm, form } = useForm();
    const {
      errorMessage,
      validateWithTrigger: vt,
      validate: v,
      // expose
      resetValidation
    } = useValidation();
    const cursor = vue.computed(() => props2.disabled || props2.readonly ? "" : "text");
    const normalizedType = vue.computed(() => {
      if (props2.type === "number") {
        return "text";
      }
      return props2.type;
    });
    const maxlengthText = vue.computed(() => {
      const { maxlength, modelValue } = props2;
      if (!maxlength) {
        return "";
      }
      if (isEmpty(modelValue)) {
        return `0 / ${maxlength}`;
      }
      return `${String(modelValue).length}/${maxlength}`;
    });
    const placeholderColor = vue.computed(() => {
      const { hint, blurColor, focusColor } = props2;
      if (hint) {
        return void 0;
      }
      if (errorMessage.value) {
        return "var(--field-decorator-error-color)";
      }
      if (isFocusing.value) {
        return focusColor || "var(--field-decorator-focus-color)";
      }
      return blurColor || "var(--field-decorator-placeholder-color, var(--field-decorator-blur-color))";
    });
    const inputProvider = {
      reset,
      validate,
      resetValidation
    };
    call(bindForm, inputProvider);
    onSmartMounted(() => {
      if (props2.autofocus) {
        focus();
      }
    });
    function validateWithTrigger(trigger) {
      vue.nextTick(() => {
        const { validateTrigger, rules, modelValue } = props2;
        vt(validateTrigger, trigger, rules, modelValue);
      });
    }
    function handleFocus(e) {
      isFocusing.value = true;
      call(props2.onFocus, e);
      validateWithTrigger("onFocus");
    }
    function handleBlur(e) {
      isFocusing.value = false;
      call(props2.onBlur, e);
      validateWithTrigger("onBlur");
    }
    function updateValue(e) {
      const target = e.target;
      let { value } = target;
      if (props2.type === "number") {
        value = formatNumber(value);
      }
      const targetValue = withMaxlength(value);
      if (targetValue === props2.modelValue) {
        target.value = targetValue;
      }
      return targetValue;
    }
    function handleCompositionStart() {
      isComposing.value = true;
    }
    function handleCompositionEnd(e) {
      if (!isComposing.value) {
        return;
      }
      isComposing.value = false;
      e.target.dispatchEvent(new Event("input"));
    }
    function handleInput(e) {
      if (isComposing.value) {
        return;
      }
      const value = updateValue(e);
      call(props2["onUpdate:modelValue"], value);
      call(props2.onInput, value, e);
      validateWithTrigger("onInput");
    }
    function handleChange(e) {
      const value = withTrim(updateValue(e));
      if (props2.modelModifiers.trim) {
        call(props2["onUpdate:modelValue"], value);
      }
      call(props2.onChange, value, e);
      validateWithTrigger("onChange");
    }
    function handleClear() {
      const { disabled, readonly, clearable, onClear } = props2;
      if ((form == null ? void 0 : form.disabled.value) || (form == null ? void 0 : form.readonly.value) || disabled || readonly || !clearable) {
        return;
      }
      call(props2["onUpdate:modelValue"], "");
      call(onClear, "");
      validateWithTrigger("onClear");
    }
    function handleClick(e) {
      const { disabled, onClick } = props2;
      if ((form == null ? void 0 : form.disabled.value) || disabled) {
        return;
      }
      call(onClick, e);
      validateWithTrigger("onClick");
    }
    function formatNumber(value) {
      const minusIndex = value.indexOf("-");
      const dotIndex = value.indexOf(".");
      if (minusIndex > -1) {
        value = minusIndex === 0 ? "-" + value.replace(/-/g, "") : value.replace(/-/g, "");
      }
      if (dotIndex > -1) {
        value = value.slice(0, dotIndex + 1) + value.slice(dotIndex).replace(/\./g, "");
      }
      return value.replace(/[^-0-9.]/g, "");
    }
    function withTrim(value) {
      return props2.modelModifiers.trim ? value.trim() : value;
    }
    function withMaxlength(value) {
      return props2.maxlength ? value.slice(0, toNumber(props2.maxlength)) : value;
    }
    function handleMousedown(e) {
      const { disabled } = props2;
      if ((form == null ? void 0 : form.disabled.value) || disabled || e.target === el.value) {
        return;
      }
      focus();
      preventDefault(e);
    }
    function reset() {
      call(props2["onUpdate:modelValue"], "");
      resetValidation();
    }
    function validate() {
      return v(props2.rules, props2.modelValue);
    }
    function focus() {
      var _a;
      (_a = el.value) == null ? void 0 : _a.focus();
    }
    function blur() {
      el.value.blur();
    }
    return {
      el,
      id,
      isFocusing,
      isComposing,
      errorMessage,
      placeholderColor,
      normalizedType,
      cursor,
      maxlengthText,
      formDisabled: form == null ? void 0 : form.disabled,
      formReadonly: form == null ? void 0 : form.readonly,
      n: n$1m,
      classes: classes$14,
      isEmpty,
      handleFocus,
      handleBlur,
      handleInput,
      handleChange,
      handleClear,
      handleClick,
      handleCompositionStart,
      handleCompositionEnd,
      handleMousedown,
      validate,
      resetValidation,
      reset,
      focus,
      blur
    };
  }
});
__sfc__$1n.render = __render__$1k;
var stdin_default$5O = __sfc__$1n;
withInstall(stdin_default$5O);
withPropsDefaultsSetter(stdin_default$5O, props$1d);
const _InputComponent = stdin_default$5O;
var stdin_default$5N = stdin_default$5O;
const props$1c = {
  modelValue: {
    type: [String, Number, Boolean, Object, Array],
    default: false
  },
  checkedValue: {
    type: [String, Number, Boolean, Object, Array],
    default: true
  },
  uncheckedValue: {
    type: [String, Number, Boolean, Object, Array],
    default: false
  },
  checkedColor: String,
  uncheckedColor: String,
  disabled: Boolean,
  readonly: Boolean,
  indeterminate: Boolean,
  iconSize: [String, Number],
  ripple: {
    type: Boolean,
    default: true
  },
  validateTrigger: {
    type: Array,
    default: () => ["onChange"]
  },
  rules: [Array, Function, Object],
  onClick: defineListenerProp(),
  onChange: defineListenerProp(),
  "onUpdate:modelValue": defineListenerProp(),
  "onUpdate:indeterminate": defineListenerProp()
};
const CHECKBOX_GROUP_BIND_CHECKBOX_KEY = Symbol("CHECKBOX_GROUP_BIND_CHECKBOX_KEY");
function useCheckboxes() {
  const { bindChildren, childProviders, length } = useChildren(
    CHECKBOX_GROUP_BIND_CHECKBOX_KEY
  );
  return {
    length,
    checkboxes: childProviders,
    bindCheckboxes: bindChildren
  };
}
function useCheckboxGroup() {
  const { bindParent, parentProvider, index } = useParent(
    CHECKBOX_GROUP_BIND_CHECKBOX_KEY
  );
  return {
    index,
    checkboxGroup: parentProvider,
    bindCheckboxGroup: bindParent
  };
}
const { name: name$1e, n: n$1l, classes: classes$13 } = createNamespace("checkbox");
const _hoisted_1$x = ["tabindex"];
function __render__$1j(_ctx, _cache) {
  const _component_var_icon = vue.resolveComponent("var-icon");
  const _component_var_hover_overlay = vue.resolveComponent("var-hover-overlay");
  const _component_var_form_details = vue.resolveComponent("var-form-details");
  const _directive_hover = vue.resolveDirective("hover");
  const _directive_ripple = vue.resolveDirective("ripple");
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.n("wrap"))
    },
    [
      vue.createElementVNode(
        "div",
        {
          class: vue.normalizeClass(_ctx.n()),
          onClick: _cache[3] || (_cache[3] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
        },
        [
          vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", {
            ref: "action",
            class: vue.normalizeClass(
              _ctx.classes(
                _ctx.n("action"),
                [_ctx.checked || _ctx.isIndeterminate, _ctx.n("--checked"), _ctx.n("--unchecked")],
                [_ctx.errorMessage || _ctx.checkboxGroupErrorMessage, _ctx.n("--error")],
                [_ctx.formDisabled || _ctx.disabled, _ctx.n("--disabled")]
              )
            ),
            style: vue.normalizeStyle({ color: _ctx.checked || _ctx.isIndeterminate ? _ctx.checkedColor : _ctx.uncheckedColor }),
            tabindex: _ctx.disabled || _ctx.formDisabled ? void 0 : "0",
            onFocus: _cache[0] || (_cache[0] = ($event) => _ctx.isFocusing = true),
            onBlur: _cache[1] || (_cache[1] = ($event) => _ctx.isFocusing = false)
          }, [
            _ctx.isIndeterminate ? vue.renderSlot(_ctx.$slots, "indeterminate-icon", { key: 0 }, () => [
              vue.createVNode(_component_var_icon, {
                class: vue.normalizeClass(_ctx.n("icon")),
                name: "minus-box",
                size: _ctx.iconSize,
                "var-checkbox-cover": ""
              }, null, 8, ["class", "size"])
            ]) : vue.createCommentVNode("v-if", true),
            _ctx.checked && !_ctx.isIndeterminate ? vue.renderSlot(_ctx.$slots, "checked-icon", { key: 1 }, () => [
              vue.createVNode(_component_var_icon, {
                class: vue.normalizeClass(_ctx.n("icon")),
                name: "checkbox-marked",
                size: _ctx.iconSize,
                "var-checkbox-cover": ""
              }, null, 8, ["class", "size"])
            ]) : vue.createCommentVNode("v-if", true),
            !_ctx.checked && !_ctx.isIndeterminate ? vue.renderSlot(_ctx.$slots, "unchecked-icon", { key: 2 }, () => [
              vue.createVNode(_component_var_icon, {
                class: vue.normalizeClass(_ctx.n("icon")),
                name: "checkbox-blank-outline",
                size: _ctx.iconSize,
                "var-checkbox-cover": ""
              }, null, 8, ["class", "size"])
            ]) : vue.createCommentVNode("v-if", true),
            vue.createVNode(_component_var_hover_overlay, {
              hovering: !_ctx.disabled && !_ctx.formDisabled && _ctx.hovering,
              focusing: !_ctx.disabled && !_ctx.formDisabled && _ctx.isFocusing
            }, null, 8, ["hovering", "focusing"])
          ], 46, _hoisted_1$x)), [
            [_directive_hover, _ctx.handleHovering, "desktop"],
            [_directive_ripple, { disabled: _ctx.formReadonly || _ctx.readonly || _ctx.formDisabled || _ctx.disabled || !_ctx.ripple }]
          ]),
          _ctx.$slots.default ? (vue.openBlock(), vue.createElementBlock(
            "div",
            {
              key: 0,
              class: vue.normalizeClass(
                _ctx.classes(
                  _ctx.n("text"),
                  [_ctx.errorMessage || _ctx.checkboxGroupErrorMessage, _ctx.n("--error")],
                  [_ctx.formDisabled || _ctx.disabled, _ctx.n("--disabled")]
                )
              ),
              onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleTextClick && _ctx.handleTextClick(...args))
            },
            [
              vue.renderSlot(_ctx.$slots, "default", { checked: _ctx.checked })
            ],
            2
            /* CLASS */
          )) : vue.createCommentVNode("v-if", true)
        ],
        2
        /* CLASS */
      ),
      vue.createVNode(_component_var_form_details, { "error-message": _ctx.errorMessage }, null, 8, ["error-message"])
    ],
    2
    /* CLASS */
  );
}
const __sfc__$1m = vue.defineComponent({
  name: name$1e,
  directives: { Ripple: stdin_default$63, Hover: stdin_default$62 },
  components: {
    VarIcon: stdin_default$5_,
    VarFormDetails: stdin_default$5R,
    VarHoverOverlay: stdin_default$60
  },
  props: props$1c,
  setup(props2) {
    const action = vue.ref(null);
    const isFocusing = vue.ref(false);
    const value = useVModel(props2, "modelValue");
    const isIndeterminate = useVModel(props2, "indeterminate");
    const checked = vue.computed(() => value.value === props2.checkedValue);
    const checkedValue = vue.computed(() => props2.checkedValue);
    const { checkboxGroup, bindCheckboxGroup } = useCheckboxGroup();
    const { hovering, handleHovering } = useHoverOverlay();
    const { form, bindForm } = useForm();
    const {
      errorMessage,
      validateWithTrigger: vt,
      validate: v,
      // expose
      resetValidation
    } = useValidation();
    const checkboxProvider = {
      checkedValue,
      checked,
      sync,
      validate,
      resetValidation,
      reset
    };
    call(bindCheckboxGroup, checkboxProvider);
    call(bindForm, checkboxProvider);
    useEventListener(() => window, "keydown", handleKeydown);
    useEventListener(() => window, "keyup", handleKeyup);
    function validateWithTrigger(trigger) {
      vue.nextTick(() => {
        const { validateTrigger, rules, modelValue } = props2;
        vt(validateTrigger, trigger, rules, modelValue);
      });
    }
    function change(changedValue) {
      const { checkedValue: checkedValue2, onChange } = props2;
      value.value = changedValue;
      call(onChange, value.value, isIndeterminate.value);
      validateWithTrigger("onChange");
      changedValue === checkedValue2 ? checkboxGroup == null ? void 0 : checkboxGroup.onChecked(checkedValue2) : checkboxGroup == null ? void 0 : checkboxGroup.onUnchecked(checkedValue2);
    }
    function handleClick(e) {
      const { disabled, readonly, checkedValue: checkedValue2, uncheckedValue, onClick } = props2;
      if ((form == null ? void 0 : form.disabled.value) || disabled) {
        return;
      }
      call(onClick, e);
      if ((form == null ? void 0 : form.readonly.value) || readonly) {
        return;
      }
      if (isIndeterminate.value === true) {
        isIndeterminate.value = false;
        call(props2.onChange, value.value, isIndeterminate.value);
        validateWithTrigger("onChange");
        return;
      }
      const maximum = checkboxGroup ? checkboxGroup.checkedCount.value >= Number(checkboxGroup.max.value) : false;
      if (!checked.value && maximum) {
        return;
      }
      change(checked.value ? uncheckedValue : checkedValue2);
    }
    function handleTextClick() {
      action.value.focus();
    }
    function sync(values) {
      const { checkedValue: checkedValue2, uncheckedValue } = props2;
      value.value = values.includes(checkedValue2) ? checkedValue2 : uncheckedValue;
    }
    function reset() {
      value.value = props2.uncheckedValue;
      resetValidation();
    }
    function toggle(changedValue) {
      const { checkedValue: checkedValue2, uncheckedValue } = props2;
      const shouldReverse = ![checkedValue2, uncheckedValue].includes(changedValue);
      if (shouldReverse) {
        changedValue = checked.value ? uncheckedValue : checkedValue2;
      }
      change(changedValue);
    }
    function handleKeydown(event) {
      if (!isFocusing.value) {
        return;
      }
      const { key: key3 } = event;
      if (key3 === "Enter" || key3 === " ") {
        preventDefault(event);
      }
      if (key3 === "Enter") {
        action.value.click();
      }
    }
    function handleKeyup(event) {
      if (!isFocusing.value) {
        return;
      }
      if (event.key === " ") {
        preventDefault(event);
        action.value.click();
      }
    }
    function validate() {
      return v(props2.rules, props2.modelValue);
    }
    return {
      action,
      isFocusing,
      isIndeterminate,
      checked,
      errorMessage,
      checkboxGroupErrorMessage: checkboxGroup == null ? void 0 : checkboxGroup.errorMessage,
      formDisabled: form == null ? void 0 : form.disabled,
      formReadonly: form == null ? void 0 : form.readonly,
      hovering,
      n: n$1l,
      classes: classes$13,
      handleHovering,
      handleClick,
      handleTextClick,
      toggle,
      reset,
      validate,
      resetValidation
    };
  }
});
__sfc__$1m.render = __render__$1j;
var stdin_default$5M = __sfc__$1m;
withInstall(stdin_default$5M);
withPropsDefaultsSetter(stdin_default$5M, props$1c);
const _CheckboxComponent = stdin_default$5M;
var stdin_default$5L = stdin_default$5M;
const props$1b = {
  label: {},
  value: {},
  disabled: Boolean,
  ripple: {
    type: Boolean,
    default: true
  },
  // internal start
  option: Object,
  childrenTrigger: Boolean,
  highlight: Boolean,
  onKeyArrowX: defineListenerProp()
  // internal end
};
const MENU_SELECT_BIND_MENU_OPTION_KEY = Symbol("MENU_SELECT_BIND_MENU_OPTION_KEY");
function useMenuOptions() {
  const { length, childProviders, bindChildren } = useChildren(
    MENU_SELECT_BIND_MENU_OPTION_KEY
  );
  return {
    length,
    menuOptions: childProviders,
    bindMenuOptions: bindChildren
  };
}
function useMenuSelect() {
  const { index, parentProvider, bindParent } = useParent(
    MENU_SELECT_BIND_MENU_OPTION_KEY
  );
  assert(!!bindParent, "MenuOption", "<var-menu-option/> must in <var-menu-select/>");
  return {
    index,
    menuSelect: parentProvider,
    bindMenuSelect: bindParent
  };
}
var __async$i = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const { name: name$1d, n: n$1k, classes: classes$12 } = createNamespace("menu-option");
const _hoisted_1$w = ["tabindex"];
function __render__$1i(_ctx, _cache) {
  const _component_var_checkbox = vue.resolveComponent("var-checkbox");
  const _component_maybe_v_node = vue.resolveComponent("maybe-v-node");
  const _component_var_icon = vue.resolveComponent("var-icon");
  const _component_var_hover_overlay = vue.resolveComponent("var-hover-overlay");
  const _directive_ripple = vue.resolveDirective("ripple");
  const _directive_hover = vue.resolveDirective("hover");
  return vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", {
    ref: "root",
    class: vue.normalizeClass(
      _ctx.classes(
        _ctx.n(),
        _ctx.n("$--box"),
        _ctx.n(`--${_ctx.size}`),
        [_ctx.optionSelected, _ctx.n("--selected-color")],
        [_ctx.disabled, _ctx.n("--disabled")],
        [_ctx.childrenTrigger, _ctx.n("--children-trigger")]
      )
    ),
    tabindex: _ctx.disabled ? void 0 : "-1",
    onClick: _cache[3] || (_cache[3] = (...args) => _ctx.handleClick && _ctx.handleClick(...args)),
    onFocus: _cache[4] || (_cache[4] = ($event) => _ctx.isFocusing = true),
    onBlur: _cache[5] || (_cache[5] = ($event) => _ctx.isFocusing = false)
  }, [
    vue.createElementVNode(
      "div",
      {
        class: vue.normalizeClass(_ctx.classes(_ctx.n("cover"), [_ctx.optionSelected, _ctx.n("--selected-background")]))
      },
      null,
      2
      /* CLASS */
    ),
    _ctx.multiple ? (vue.openBlock(), vue.createBlock(_component_var_checkbox, {
      key: 0,
      ref: "checkbox",
      modelValue: _ctx.optionSelected,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.optionSelected = $event),
      indeterminate: _ctx.optionIndeterminate,
      "onUpdate:indeterminate": _cache[1] || (_cache[1] = ($event) => _ctx.optionIndeterminate = $event),
      disabled: _ctx.disabled,
      onClick: _cache[2] || (_cache[2] = vue.withModifiers(() => {
      }, ["stop"])),
      onChange: _ctx.handleSelect
    }, null, 8, ["modelValue", "indeterminate", "disabled", "onChange"])) : vue.createCommentVNode("v-if", true),
    vue.renderSlot(_ctx.$slots, "default", {}, () => [
      vue.createElementVNode(
        "div",
        {
          class: vue.normalizeClass(_ctx.classes(_ctx.n("text")))
        },
        [
          vue.createVNode(_component_maybe_v_node, {
            is: _ctx.labelVNode,
            class: vue.normalizeClass(_ctx.n("$--ellipsis"))
          }, null, 8, ["is", "class"])
        ],
        2
        /* CLASS */
      )
    ]),
    _ctx.childrenTrigger ? (vue.openBlock(), vue.createElementBlock(
      "div",
      {
        key: 1,
        class: vue.normalizeClass(_ctx.n("arrow"))
      },
      [
        vue.createVNode(_component_var_icon, {
          "var-menu-option-cover": "",
          class: vue.normalizeClass(_ctx.n("arrow-icon")),
          name: "chevron-right"
        }, null, 8, ["class"])
      ],
      2
      /* CLASS */
    )) : vue.createCommentVNode("v-if", true),
    vue.createVNode(_component_var_hover_overlay, {
      hovering: (_ctx.hovering || _ctx.highlight) && !_ctx.disabled,
      focusing: _ctx.isFocusing && !_ctx.disabled
    }, null, 8, ["hovering", "focusing"])
  ], 42, _hoisted_1$w)), [
    [_directive_ripple, { disabled: _ctx.disabled || !_ctx.ripple }],
    [_directive_hover, _ctx.handleHovering, "desktop"]
  ]);
}
const __sfc__$1l = vue.defineComponent({
  name: name$1d,
  directives: { Ripple: stdin_default$63, Hover: stdin_default$62 },
  components: {
    VarCheckbox: stdin_default$5L,
    VarHoverOverlay: stdin_default$60,
    VarIcon: stdin_default$5_,
    MaybeVNode
  },
  props: props$1b,
  setup(props2) {
    const root = vue.ref();
    const checkbox = vue.ref();
    const isFocusing = vue.ref(false);
    const optionSelected = vue.ref(false);
    const optionIndeterminate = vue.ref(false);
    const selected = vue.computed(() => optionSelected.value);
    const indeterminate = vue.computed(() => optionIndeterminate.value);
    const value = vue.computed(() => props2.value);
    const disabled = vue.computed(() => props2.disabled);
    const ripple = vue.computed(() => props2.ripple);
    const { menuSelect, bindMenuSelect } = useMenuSelect();
    const { size, multiple, onSelect, computeLabel } = menuSelect;
    const { hovering, handleHovering } = useHoverOverlay();
    const labelVNode = vue.computed(
      () => {
        var _a;
        return isFunction(props2.label) ? props2.label(
          (_a = props2.option) != null ? _a : {
            label: props2.label,
            value: props2.value,
            disabled: props2.disabled,
            ripple: props2.ripple
          },
          optionSelected.value
        ) : props2.label;
      }
    );
    const menuOptionProvider = {
      label: labelVNode,
      value,
      selected,
      disabled,
      ripple,
      indeterminate,
      sync
    };
    vue.watch([() => props2.label, () => props2.value], computeLabel);
    bindMenuSelect(menuOptionProvider);
    useEventListener(() => window, "keydown", handleKeydown);
    useEventListener(() => window, "keyup", handleKeyup);
    function handleClick() {
      if (props2.disabled) {
        return;
      }
      if (!multiple.value && props2.childrenTrigger) {
        return;
      }
      if (multiple.value && optionIndeterminate.value) {
        optionIndeterminate.value = false;
        optionSelected.value = false;
        onSelect(menuOptionProvider);
        return;
      }
      if (multiple.value && !optionIndeterminate.value) {
        optionSelected.value = !optionSelected.value;
      }
      onSelect(menuOptionProvider);
    }
    function handleKeydown(event) {
      var _a;
      if (!isFocusing.value && !((_a = checkbox.value) == null ? void 0 : _a.isFocusing)) {
        return;
      }
      if (event.key === "ArrowRight" || event.key === "ArrowLeft") {
        preventDefault(event);
        call(props2.onKeyArrowX, event.key);
      }
      if (!isFocusing.value) {
        return;
      }
      if (event.key === " " || event.key === "Enter") {
        preventDefault(event);
      }
      if (event.key === "Enter") {
        root.value.click();
      }
    }
    function handleKeyup(event) {
      if (!isFocusing.value) {
        return;
      }
      if (event.key === " ") {
        preventDefault(event);
        root.value.click();
      }
    }
    function handleSelect() {
      return __async$i(this, null, function* () {
        yield vue.nextTick();
        onSelect(menuOptionProvider);
      });
    }
    function sync(checked, indeterminate2) {
      optionSelected.value = checked;
      if (isBoolean(indeterminate2)) {
        optionIndeterminate.value = indeterminate2;
      }
    }
    return {
      root,
      checkbox,
      optionSelected,
      optionIndeterminate,
      size,
      multiple,
      hovering,
      isFocusing,
      labelVNode,
      n: n$1k,
      classes: classes$12,
      handleHovering,
      handleClick,
      handleSelect
    };
  }
});
__sfc__$1l.render = __render__$1i;
var stdin_default$5K = __sfc__$1l;
withInstall(stdin_default$5K);
withPropsDefaultsSetter(stdin_default$5K, props$1b);
const _MenuOptionComponent = stdin_default$5K;
var stdin_default$5J = stdin_default$5K;
const props$1a = {
  show: Boolean,
  disabled: Boolean,
  trigger: {
    type: String,
    default: "click"
  },
  reference: [String, Object],
  placement: {
    type: String,
    default: "cover-top-start"
  },
  strategy: {
    type: String,
    default: "absolute"
  },
  offsetX: {
    type: [Number, String],
    default: 0
  },
  offsetY: {
    type: [Number, String],
    default: 0
  },
  teleport: {
    type: [String, Object, Boolean],
    default: "body"
  },
  sameWidth: Boolean,
  elevation: {
    type: [Boolean, String, Number],
    default: true
  },
  defaultStyle: {
    type: Boolean,
    default: true
  },
  popoverClass: String,
  closeOnClickReference: Boolean,
  closeOnKeyEscape: {
    type: Boolean,
    default: true
  },
  onOpen: defineListenerProp(),
  onOpened: defineListenerProp(),
  onClose: defineListenerProp(),
  onClosed: defineListenerProp(),
  onClickOutside: defineListenerProp(),
  "onUpdate:show": defineListenerProp(),
  // internal start
  cascadeOptimization: Boolean
  // internal end
};
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start$1 = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start$1, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start$1, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
function getVariation(placement) {
  return placement.split("-")[1];
}
var max$1 = Math.max;
var min$1 = Math.min;
var round$1 = Math.round;
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x = _ref.x, y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round$1(x * dpr) / dpr || 0,
    y: round$1(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  if (process.env.NODE_ENV !== "production") {
    var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
  }
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
const computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round$1(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round$1(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max$1(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max$1(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle(body || html).direction === "rtl") {
    x += max$1(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max$1(rect.top, accRect.top);
    accRect.right = min$1(rect.right, accRect.right);
    accRect.bottom = min$1(rect.bottom, accRect.bottom);
    accRect.left = max$1(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start$1:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key3) {
    hashMap[key3] = value;
    return hashMap;
  }, {});
}
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key3) {
      var multiply = [right, bottom].indexOf(key3) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key3) >= 0 ? "y" : "x";
      overflowOffsets[key3] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
    if (process.env.NODE_ENV !== "production") {
      console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
    }
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name2 = _ref.name;
  if (state.modifiersData[name2]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start$1;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check2) {
      return check2;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check2) {
            return check2;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name2]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
const flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name2 = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name2] = data;
}
const offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round$1(rect.width) / element.offsetWidth || 1;
  var scaleY = round$1(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return [].concat(args).reduce(function(p, c) {
    return p.replace(/%s/, c);
  }, str);
}
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function validateModifiers(modifiers) {
  modifiers.forEach(function(modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index, self2) {
      return self2.indexOf(value) === index;
    }).forEach(function(key3) {
      switch (key3) {
        case "name":
          if (typeof modifier.name !== "string") {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
          }
          break;
        case "enabled":
          if (typeof modifier.enabled !== "boolean") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
          }
          break;
        case "phase":
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
          }
          break;
        case "fn":
          if (typeof modifier.fn !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "effect":
          if (modifier.effect != null && typeof modifier.effect !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "requires":
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
          }
          break;
        case "requiresIfExists":
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
          }
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {
            return '"' + s + '"';
          }).join(", ") + '; but "' + key3 + '" was provided.');
      }
      modifier.requires && modifier.requires.forEach(function(requirement) {
        if (modifiers.find(function(mod2) {
          return mod2.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}
function uniqueBy(arr, fn2) {
  var identifiers = /* @__PURE__ */ new Set();
  return arr.filter(function(item) {
    var identifier = fn2(item);
    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key3) {
    return merged[key3];
  });
}
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions2;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions2, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        if (process.env.NODE_ENV !== "production") {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
            var name2 = _ref.name;
            return name2;
          });
          validateModifiers(modifiers);
          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function(_ref2) {
              var name2 = _ref2.name;
              return name2 === "flip";
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          var _getComputedStyle = getComputedStyle(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
          if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
        }
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          if (process.env.NODE_ENV !== "production") {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (process.env.NODE_ENV !== "production") {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name2 = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name: name2,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      if (process.env.NODE_ENV !== "production") {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name2 = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect2 = _ref3.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state,
            name: name2,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var passive = {
  passive: true
};
function effect$1(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
const eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect$1,
  data: {}
};
function popperOffsets(_ref) {
  var state = _ref.state, name2 = _ref.name;
  state.modifiersData[name2] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
const popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name2) {
    var style = state.styles[name2] || {};
    var attributes = state.attributes[name2] || {};
    var element = state.elements[name2];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name3) {
      var value = attributes[name3];
      if (value === false) {
        element.removeAttribute(name3);
      } else {
        element.setAttribute(name3, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name2) {
      var element = state.elements[name2];
      var attributes = state.attributes[name2] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name2) ? state.styles[name2] : initialStyles[name2]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
const applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
var __defProp$r = Object.defineProperty;
var __defProps$9 = Object.defineProperties;
var __getOwnPropDescs$9 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$r = Object.getOwnPropertySymbols;
var __hasOwnProp$r = Object.prototype.hasOwnProperty;
var __propIsEnum$r = Object.prototype.propertyIsEnumerable;
var __defNormalProp$r = (obj, key3, value) => key3 in obj ? __defProp$r(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$r = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$r.call(b, prop))
      __defNormalProp$r(a, prop, b[prop]);
  if (__getOwnPropSymbols$r)
    for (var prop of __getOwnPropSymbols$r(b)) {
      if (__propIsEnum$r.call(b, prop))
        __defNormalProp$r(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$9 = (a, b) => __defProps$9(a, __getOwnPropDescs$9(b));
var __async$h = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function usePopover(options) {
  const host = vue.ref(null);
  const popover = vue.ref(null);
  const referenceSize = vue.ref({ width: 0, height: 0 });
  const show = useVModel(options, "show", {
    passive: true,
    defaultValue: false,
    emit(_event, value) {
      if (value) {
        call(options.onOpen);
      } else {
        call(options.onClose);
      }
    }
  });
  const { zIndex } = useZIndex(() => show.value, 1);
  useStack(() => show.value, zIndex);
  let popoverInstance = null;
  let reference2 = void 0;
  let enterPopover = false;
  let enterReference = false;
  let allowClose = true;
  useEventListener(() => window, "keydown", handleKeydown);
  vue.watch(() => [options.offsetX, options.offsetY, options.placement, options.strategy], resize);
  vue.watch(() => options.disabled, close);
  vue.watch(
    () => show.value,
    (newValue) => {
      if (newValue) {
        resize();
      }
    }
  );
  onWindowResize(resize);
  vue.onMounted(createPopperInstance);
  vue.onUnmounted(destroyPopperInstance);
  function createPopperInstance() {
    const reference22 = getReference();
    popoverInstance = createPopper(reference22, popover.value, getPopperOptions());
    reference22.addEventListener("mouseenter", handleReferenceMouseenter);
    reference22.addEventListener("mouseleave", handleReferenceMouseleave);
    reference22.addEventListener("click", handleReferenceClick);
    document.addEventListener("click", handleClickOutside);
  }
  function destroyPopperInstance() {
    const reference22 = getReference();
    if (reference22) {
      reference22.removeEventListener("mouseenter", handleReferenceMouseenter);
      reference22.removeEventListener("mouseleave", handleReferenceMouseleave);
      reference22.removeEventListener("click", handleReferenceClick);
    }
    popoverInstance.destroy();
    document.removeEventListener("click", handleClickOutside);
  }
  function computeReferenceSize() {
    const reference22 = getReference();
    if (!reference22) {
      return;
    }
    const { width, height } = getStyle$1(reference22);
    referenceSize.value = {
      width: toPxNum(width),
      height: toPxNum(height)
    };
  }
  function getTransformOrigin() {
    switch (options.placement) {
      case "top":
      case "cover-bottom":
        return "bottom";
      case "top-start":
      case "right-end":
      case "cover-bottom-start":
        return "bottom left";
      case "top-end":
      case "left-end":
      case "cover-bottom-end":
        return "bottom right";
      case "bottom":
      case "cover-top":
        return "top";
      case "bottom-start":
      case "right-start":
      case "cover-top-start":
        return "top left";
      case "bottom-end":
      case "left-start":
      case "cover-top-end":
        return "top right";
      case "left":
      case "cover-right":
        return "right";
      case "right":
      case "cover-left":
        return "left";
    }
  }
  function handleReferenceMouseenter() {
    if (options.trigger !== "hover") {
      return;
    }
    enterReference = true;
    open();
  }
  function handleReferenceMouseleave() {
    return __async$h(this, null, function* () {
      if (options.trigger !== "hover") {
        return;
      }
      enterReference = false;
      yield doubleRaf();
      if (enterPopover) {
        return;
      }
      close();
    });
  }
  function handlePopoverMouseenter() {
    if (options.trigger !== "hover") {
      return;
    }
    enterPopover = true;
    if (options.cascadeOptimization) {
      allowClose = false;
    }
  }
  function handlePopoverMouseleave() {
    return __async$h(this, null, function* () {
      if (options.trigger !== "hover") {
        return;
      }
      enterPopover = false;
      yield doubleRaf();
      if (enterReference) {
        return;
      }
      close();
    });
  }
  function handleReferenceClick() {
    if (options.trigger !== "click") {
      return;
    }
    if (options.closeOnClickReference && show.value) {
      close();
      return;
    }
    open();
  }
  function handleClickOutside(e) {
    const reference22 = getReference();
    if (reference22 && !reference22.contains(e.target)) {
      if (options.trigger !== "click") {
        return;
      }
      handlePopoverClose();
      call(options.onClickOutside, e);
    }
  }
  function handlePopoverClose() {
    close();
  }
  function handleClosed() {
    resize();
    call(options.onClosed);
  }
  function getPosition() {
    const { offsetX, offsetY, placement } = options;
    computeReferenceSize();
    const offset2 = {
      x: toPxNum(offsetX),
      y: toPxNum(offsetY)
    };
    switch (placement) {
      case "cover-top":
        return {
          placement: "bottom",
          skidding: offset2.x,
          distance: offset2.y - referenceSize.value.height
        };
      case "cover-top-start":
        return {
          placement: "bottom-start",
          skidding: offset2.x,
          distance: offset2.y - referenceSize.value.height
        };
      case "cover-top-end":
        return {
          placement: "bottom-end",
          skidding: offset2.x,
          distance: offset2.y - referenceSize.value.height
        };
      case "cover-bottom":
        return {
          placement: "top",
          skidding: offset2.x,
          distance: -offset2.y - referenceSize.value.height
        };
      case "cover-bottom-start":
        return {
          placement: "top-start",
          skidding: offset2.x,
          distance: -offset2.y - referenceSize.value.height
        };
      case "cover-bottom-end":
        return {
          placement: "top-end",
          skidding: offset2.x,
          distance: -offset2.y - referenceSize.value.height
        };
      case "cover-left":
        return {
          placement: "right",
          skidding: offset2.y,
          distance: offset2.x - referenceSize.value.width
        };
      case "cover-right":
        return {
          placement: "left",
          skidding: offset2.y,
          distance: -offset2.x - referenceSize.value.width
        };
      case "left":
      case "left-start":
      case "left-end":
        return {
          placement,
          skidding: offset2.y,
          distance: -offset2.x
        };
      case "top":
      case "top-start":
      case "top-end":
        return {
          placement,
          skidding: offset2.x,
          distance: -offset2.y
        };
      case "bottom":
      case "bottom-start":
      case "bottom-end":
        return {
          placement,
          skidding: offset2.x,
          distance: offset2.y
        };
      case "right":
      case "right-start":
      case "right-end":
        return {
          placement,
          skidding: offset2.y,
          distance: offset2.x
        };
    }
  }
  function getPopperOptions() {
    const { placement, skidding, distance } = getPosition();
    const modifiers = [
      __spreadProps$9(__spreadValues$r({}, flip$1), {
        enabled: show.value
      }),
      __spreadProps$9(__spreadValues$r({}, offset$1), {
        options: {
          offset: [skidding, distance]
        }
      }),
      __spreadProps$9(__spreadValues$r({}, computeStyles$1), {
        options: {
          adaptive: false,
          gpuAcceleration: false
        },
        enabled: show.value
      }),
      {
        name: "applyTransformOrigin",
        enabled: show.value,
        phase: "beforeWrite",
        fn({ state }) {
          state.styles.popper.transformOrigin = getTransformOrigin();
        }
      }
    ];
    return {
      placement,
      modifiers,
      strategy: options.strategy
    };
  }
  function getReference() {
    var _a, _b;
    const targetReference = (_a = reference2 != null ? reference2 : options.reference) != null ? _a : host.value;
    if (isString(targetReference)) {
      return (_b = host.value) == null ? void 0 : _b.querySelector(targetReference);
    }
    return targetReference;
  }
  function setAllowClose(value) {
    allowClose = value;
  }
  function setReference(newReference) {
    destroyPopperInstance();
    reference2 = newReference;
    createPopperInstance();
  }
  function handleKeydown(event) {
    const { closeOnKeyEscape = false } = options;
    if (event.key === "Escape" && closeOnKeyEscape && show.value) {
      preventDefault(event);
      close();
    }
  }
  function resize() {
    popoverInstance.setOptions(getPopperOptions());
  }
  function open() {
    if (options.disabled) {
      return;
    }
    show.value = true;
    call(options["onUpdate:show"], true);
  }
  function close() {
    if (!allowClose) {
      return;
    }
    show.value = false;
    call(options["onUpdate:show"], false);
  }
  return {
    show,
    popover,
    zIndex,
    host,
    referenceSize,
    handlePopoverClose,
    handlePopoverMouseenter,
    handlePopoverMouseleave,
    handleClosed,
    setReference,
    setAllowClose,
    resize,
    open,
    close
  };
}
const { name: name$1c, n: n$1j, classes: classes$11 } = createNamespace("menu");
function __render__$1h(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      ref: "host",
      class: vue.normalizeClass(_ctx.classes(_ctx.n(), _ctx.n("$--box")))
    },
    [
      vue.renderSlot(_ctx.$slots, "default"),
      (vue.openBlock(), vue.createBlock(vue.Teleport, {
        to: _ctx.teleport === false ? void 0 : _ctx.teleport,
        disabled: _ctx.teleportDisabled || _ctx.teleport === false
      }, [
        vue.createVNode(vue.Transition, {
          name: _ctx.n(),
          onAfterEnter: _ctx.onOpened,
          onAfterLeave: _ctx.handleClosed,
          persisted: ""
        }, {
          default: vue.withCtx(() => [
            vue.withDirectives(vue.createElementVNode(
              "div",
              {
                ref: "popover",
                style: vue.normalizeStyle({
                  zIndex: _ctx.zIndex,
                  width: _ctx.sameWidth ? _ctx.toSizeUnit(Math.ceil(_ctx.referenceSize.width)) : void 0
                }),
                class: vue.normalizeClass(
                  _ctx.classes(
                    _ctx.n("menu"),
                    _ctx.n("$--box"),
                    _ctx.popoverClass,
                    [_ctx.defaultStyle, _ctx.n("--menu-background-color")],
                    [_ctx.defaultStyle, _ctx.formatElevation(_ctx.elevation, 3)]
                  )
                ),
                onClick: _cache[0] || (_cache[0] = vue.withModifiers(() => {
                }, ["stop"])),
                onMouseenter: _cache[1] || (_cache[1] = (...args) => _ctx.handlePopoverMouseenter && _ctx.handlePopoverMouseenter(...args)),
                onMouseleave: _cache[2] || (_cache[2] = (...args) => _ctx.handlePopoverMouseleave && _ctx.handlePopoverMouseleave(...args))
              },
              [
                vue.renderSlot(_ctx.$slots, "menu")
              ],
              38
              /* CLASS, STYLE, NEED_HYDRATION */
            ), [
              [vue.vShow, _ctx.show]
            ])
          ]),
          _: 3
          /* FORWARDED */
        }, 8, ["name", "onAfterEnter", "onAfterLeave"])
      ], 8, ["to", "disabled"]))
    ],
    2
    /* CLASS */
  );
}
const __sfc__$1k = vue.defineComponent({
  name: name$1c,
  props: props$1a,
  setup(props2) {
    const { disabled: teleportDisabled } = useTeleport();
    const {
      popover,
      host,
      referenceSize,
      show,
      zIndex,
      handlePopoverMouseenter,
      handlePopoverMouseleave,
      handlePopoverClose,
      handleClosed,
      setAllowClose,
      // expose
      open,
      // expose
      close,
      // expose
      resize,
      // expose
      setReference
    } = usePopover(props2);
    function allowClose() {
      setAllowClose(true);
    }
    return {
      popover,
      host,
      referenceSize,
      show,
      zIndex,
      teleportDisabled,
      allowClose,
      formatElevation,
      toSizeUnit,
      n: n$1j,
      classes: classes$11,
      handlePopoverMouseenter,
      handlePopoverMouseleave,
      handlePopoverClose,
      handleClosed,
      resize,
      open,
      close,
      setReference
    };
  }
});
__sfc__$1k.render = __render__$1h;
var stdin_default$5I = __sfc__$1k;
withInstall(stdin_default$5I);
withPropsDefaultsSetter(stdin_default$5I, props$1a);
const _MenuComponent = stdin_default$5I;
var stdin_default$5H = stdin_default$5I;
function useSelectController(options) {
  const {
    multiple: multipleGetter,
    modelValue: modelValueGetter,
    optionProviders: optionProvidersGetter,
    optionProvidersLength: optionProvidersLengthGetter,
    optionIsIndeterminate
  } = options;
  const label = vue.ref("");
  const labels = vue.ref([]);
  vue.watch(modelValueGetter, syncOptions, { deep: true });
  vue.watch(optionProvidersLengthGetter, syncOptions);
  function computeLabel() {
    const multiple = multipleGetter();
    const modelValue = modelValueGetter();
    if (multiple) {
      labels.value = modelValue.map(findLabel);
    }
    if (!multiple && !isEmpty(modelValue)) {
      label.value = findLabel(modelValue);
    }
    if (!multiple && isEmpty(modelValue)) {
      label.value = "";
    }
  }
  function findLabel(targetValue) {
    var _a;
    const options2 = optionProvidersGetter();
    let option = options2.find(({ value }) => value.value === targetValue);
    if (!option) {
      option = options2.find(({ label: label2 }) => label2.value === targetValue);
    }
    return (_a = option == null ? void 0 : option.label.value) != null ? _a : "";
  }
  function getOptionProviderKey({ value, label: label2 }) {
    var _a;
    return (_a = value.value) != null ? _a : label2.value;
  }
  function getSelectedValue(option) {
    const multiple = multipleGetter();
    const options2 = optionProvidersGetter();
    return multiple ? options2.filter(({ selected }) => selected.value).map(getOptionProviderKey) : getOptionProviderKey(option);
  }
  function syncOptions() {
    const multiple = multipleGetter();
    const modelValue = modelValueGetter();
    const options2 = optionProvidersGetter();
    if (multiple) {
      options2.forEach(
        (option) => option.sync(
          modelValue.includes(getOptionProviderKey(option)),
          optionIsIndeterminate ? optionIsIndeterminate(option) : void 0
        )
      );
    } else {
      options2.forEach((option) => option.sync(modelValue === getOptionProviderKey(option)));
    }
    computeLabel();
  }
  return {
    label,
    labels,
    getOptionProviderKey,
    computeLabel,
    getSelectedValue
  };
}
var __defProp$q = Object.defineProperty;
var __defProps$8 = Object.defineProperties;
var __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$q = Object.getOwnPropertySymbols;
var __hasOwnProp$q = Object.prototype.hasOwnProperty;
var __propIsEnum$q = Object.prototype.propertyIsEnumerable;
var __defNormalProp$q = (obj, key3, value) => key3 in obj ? __defProp$q(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$q = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$q.call(b, prop))
      __defNormalProp$q(a, prop, b[prop]);
  if (__getOwnPropSymbols$q)
    for (var prop of __getOwnPropSymbols$q(b)) {
      if (__propIsEnum$q.call(b, prop))
        __defNormalProp$q(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$8 = (a, b) => __defProps$8(a, __getOwnPropDescs$8(b));
const props$19 = __spreadProps$8(__spreadValues$q({
  modelValue: {
    type: [String, Number, Boolean, Array],
    default: void 0
  },
  options: {
    type: Array,
    default: () => []
  },
  labelKey: {
    type: String,
    default: "label"
  },
  valueKey: {
    type: String,
    default: "value"
  },
  childrenKey: {
    type: String,
    default: "children"
  },
  size: {
    type: String,
    default: "normal"
  },
  multiple: Boolean,
  scrollable: Boolean,
  closeOnSelect: {
    type: Boolean,
    default: true
  },
  "onUpdate:modelValue": defineListenerProp(),
  onSelect: defineListenerProp()
}, pickProps(props$1a, [
  "show",
  "disabled",
  "trigger",
  "reference",
  "placement",
  "strategy",
  "offsetX",
  "offsetY",
  "teleport",
  "sameWidth",
  "elevation",
  "popoverClass",
  "closeOnClickReference",
  "onOpen",
  "onOpened",
  "onClose",
  "onClosed",
  "onClickOutside",
  "onUpdate:show"
])), {
  // internal start
  onKeyEscape: defineListenerProp()
  // internal end
});
var __defProp$p = Object.defineProperty;
var __getOwnPropSymbols$p = Object.getOwnPropertySymbols;
var __hasOwnProp$p = Object.prototype.hasOwnProperty;
var __propIsEnum$p = Object.prototype.propertyIsEnumerable;
var __defNormalProp$p = (obj, key3, value) => key3 in obj ? __defProp$p(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$p = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$p.call(b, prop))
      __defNormalProp$p(a, prop, b[prop]);
  if (__getOwnPropSymbols$p)
    for (var prop of __getOwnPropSymbols$p(b)) {
      if (__propIsEnum$p.call(b, prop))
        __defNormalProp$p(a, prop, b[prop]);
    }
  return a;
};
var __async$g = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const { name: name$1b, n: n$1i } = createNamespace("menu-children");
const _hoisted_1$v = { ref: "menuOptions" };
function __render__$1g(_ctx, _cache) {
  const _component_var_menu_option = vue.resolveComponent("var-menu-option");
  const _component_var_menu_children = vue.resolveComponent("var-menu-children");
  const _component_var_menu = vue.resolveComponent("var-menu");
  return vue.openBlock(), vue.createBlock(_component_var_menu, {
    ref: "menu",
    show: _ctx.show,
    "onUpdate:show": _cache[1] || (_cache[1] = ($event) => _ctx.show = $event),
    trigger: "hover",
    placement: "right-start",
    "cascade-optimization": "",
    "var-menu-children-cover": "",
    class: vue.normalizeClass(_ctx.n()),
    disabled: _ctx.disabled,
    teleport: false,
    "close-on-click-reference": false
  }, vue.createSlots({
    default: vue.withCtx(() => [
      vue.createVNode(_component_var_menu_option, {
        ref: "trigger",
        "children-trigger": "",
        label: _ctx.option[_ctx.labelKey],
        value: _ctx.option[_ctx.valueKey],
        option: _ctx.option,
        ripple: _ctx.option.ripple,
        disabled: _ctx.option.disabled,
        highlight: _ctx.highlightOptions.some((_option) => _option.value === _ctx.option.value),
        onKeyArrowX: _ctx.handleArrowRight,
        onMouseenter: _ctx.handleMouseenter
      }, null, 8, ["label", "value", "option", "ripple", "disabled", "highlight", "onKeyArrowX", "onMouseenter"])
    ]),
    _: 2
    /* DYNAMIC */
  }, [
    _ctx.options.length ? {
      name: "menu",
      fn: vue.withCtx(() => [
        vue.createElementVNode(
          "div",
          _hoisted_1$v,
          [
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList(_ctx.options, (menuOption) => {
                return vue.openBlock(), vue.createElementBlock(
                  vue.Fragment,
                  {
                    key: menuOption[_ctx.valueKey]
                  },
                  [
                    menuOption[_ctx.childrenKey] ? (vue.openBlock(), vue.createBlock(_component_var_menu_children, {
                      key: 0,
                      ref_for: true,
                      ref: "menuChildren",
                      "parent-show": _ctx.show,
                      option: menuOption,
                      options: menuOption[_ctx.childrenKey],
                      "highlight-options": _ctx.highlightOptions,
                      disabled: menuOption.disabled,
                      onKeyArrowX: _ctx.handleArrowLeft,
                      onKeyArrowRightOpen: ($event) => _ctx.allowChildrenClose(menuOption),
                      onMouseenter: ($event) => _ctx.allowChildrenClose(menuOption)
                    }, null, 8, ["parent-show", "option", "options", "highlight-options", "disabled", "onKeyArrowX", "onKeyArrowRightOpen", "onMouseenter"])) : (vue.openBlock(), vue.createBlock(_component_var_menu_option, {
                      key: 1,
                      label: menuOption[_ctx.labelKey],
                      value: menuOption[_ctx.valueKey],
                      option: menuOption,
                      ripple: menuOption.ripple,
                      disabled: menuOption.disabled,
                      onKeyArrowX: _ctx.handleArrowLeft,
                      onMouseenter: _cache[0] || (_cache[0] = ($event) => _ctx.allowChildrenClose())
                    }, null, 8, ["label", "value", "option", "ripple", "disabled", "onKeyArrowX"]))
                  ],
                  64
                  /* STABLE_FRAGMENT */
                );
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ],
          512
          /* NEED_PATCH */
        )
      ]),
      key: "0"
    } : void 0
  ]), 1032, ["show", "class", "disabled"]);
}
const __sfc__$1j = vue.defineComponent({
  name: name$1b,
  components: {
    VarMenu: stdin_default$5I,
    VarMenuOption: stdin_default$5K
  },
  props: __spreadValues$p({
    parentShow: Boolean,
    disabled: Boolean,
    option: {
      type: Object,
      required: true
    },
    highlightOptions: pickProps(props$19, "options"),
    onKeyArrowX: defineListenerProp(),
    onKeyArrowRightOpen: defineListenerProp(),
    onMouseenter: defineListenerProp()
  }, pickProps(props$19, ["options", "valueKey", "labelKey", "childrenKey"])),
  setup(props2) {
    const show = vue.ref(false);
    const menu = vue.ref();
    const trigger = vue.ref();
    const menuOptions = vue.ref();
    const menuChildren = vue.ref();
    vue.watch(
      () => props2.parentShow,
      (value) => {
        if (!value) {
          show.value = false;
        }
      },
      { immediate: true }
    );
    function handleArrowRight(key3) {
      return __async$g(this, null, function* () {
        var _a;
        call(props2.onKeyArrowX, key3);
        if (key3 !== "ArrowRight") {
          return;
        }
        call(props2.onKeyArrowRightOpen);
        (_a = menu.value) == null ? void 0 : _a.open();
        yield raf();
        focusChildElementByKey(menu.value.$el, menuOptions.value, "ArrowDown");
      });
    }
    function handleArrowLeft(key3) {
      var _a;
      if (key3 !== "ArrowLeft") {
        return;
      }
      allowClose();
      close();
      (_a = trigger.value) == null ? void 0 : _a.$el.focus();
    }
    function close() {
      var _a;
      (_a = menu.value) == null ? void 0 : _a.close();
    }
    function allowClose() {
      var _a;
      (_a = menu.value) == null ? void 0 : _a.allowClose();
    }
    function allowChildrenClose(option) {
      var _a;
      (_a = menuChildren.value) == null ? void 0 : _a.forEach((child) => {
        child.allowClose();
        if (option == null) {
          child.close();
          return;
        }
        if (child.option.value === option.value) {
          return;
        }
        child.close();
      });
    }
    function handleMouseenter() {
      call(props2.onMouseenter);
    }
    return {
      show,
      menu,
      trigger,
      menuOptions,
      menuChildren,
      n: n$1i,
      close,
      handleArrowLeft,
      handleArrowRight,
      handleMouseenter,
      allowClose,
      allowChildrenClose
    };
  }
});
__sfc__$1j.render = __render__$1g;
var stdin_default$5G = __sfc__$1j;
var __defProp$o = Object.defineProperty;
var __defProps$7 = Object.defineProperties;
var __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$o = Object.getOwnPropertySymbols;
var __hasOwnProp$o = Object.prototype.hasOwnProperty;
var __propIsEnum$o = Object.prototype.propertyIsEnumerable;
var __defNormalProp$o = (obj, key3, value) => key3 in obj ? __defProp$o(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$o = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$o.call(b, prop))
      __defNormalProp$o(a, prop, b[prop]);
  if (__getOwnPropSymbols$o)
    for (var prop of __getOwnPropSymbols$o(b)) {
      if (__propIsEnum$o.call(b, prop))
        __defNormalProp$o(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$7 = (a, b) => __defProps$7(a, __getOwnPropDescs$7(b));
const { name: name$1a, n: n$1h, classes: classes$10 } = createNamespace("menu-select");
function __render__$1f(_ctx, _cache) {
  const _component_var_menu_children = vue.resolveComponent("var-menu-children");
  const _component_var_menu_option = vue.resolveComponent("var-menu-option");
  const _component_var_menu = vue.resolveComponent("var-menu");
  return vue.openBlock(), vue.createBlock(_component_var_menu, {
    ref: "menu",
    show: _ctx.show,
    "onUpdate:show": _cache[1] || (_cache[1] = ($event) => _ctx.show = $event),
    tabindex: "-1",
    class: vue.normalizeClass(_ctx.n()),
    disabled: _ctx.disabled,
    trigger: _ctx.trigger,
    reference: _ctx.reference,
    placement: _ctx.placement,
    strategy: _ctx.strategy,
    "offset-x": _ctx.offsetX,
    "offset-y": _ctx.offsetY,
    teleport: _ctx.teleport,
    "same-width": _ctx.sameWidth,
    elevation: _ctx.elevation,
    "default-style": false,
    "popover-class": _ctx.popoverClass,
    "close-on-click-reference": _ctx.closeOnClickReference,
    "close-on-key-escape": false,
    onOpen: _ctx.onOpen,
    onOpened: _ctx.onOpened,
    onClose: _ctx.onClose,
    onClosed: _ctx.onClosed,
    onClickOutside: _ctx.onClickOutside
  }, {
    menu: vue.withCtx(() => [
      vue.createElementVNode(
        "div",
        {
          ref: "menuOptionsRef",
          class: vue.normalizeClass(_ctx.classes(_ctx.n("menu"), _ctx.formatElevation(_ctx.elevation, 3), [_ctx.scrollable, _ctx.n("--scrollable")]))
        },
        [
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList(_ctx.options, (option) => {
              return vue.openBlock(), vue.createElementBlock(
                vue.Fragment,
                {
                  key: option[_ctx.valueKey]
                },
                [
                  option[_ctx.childrenKey] ? (vue.openBlock(), vue.createBlock(_component_var_menu_children, {
                    key: 0,
                    ref_for: true,
                    ref: "menuChildren",
                    "parent-show": _ctx.show,
                    option,
                    options: option[_ctx.childrenKey],
                    "highlight-options": _ctx.highlightOptions,
                    disabled: option.disabled,
                    onKeyArrowRightOpen: ($event) => _ctx.allowChildrenClose(option),
                    onMouseenter: ($event) => _ctx.allowChildrenClose(option)
                  }, null, 8, ["parent-show", "option", "options", "highlight-options", "disabled", "onKeyArrowRightOpen", "onMouseenter"])) : (vue.openBlock(), vue.createBlock(_component_var_menu_option, {
                    key: 1,
                    label: option[_ctx.labelKey],
                    value: option[_ctx.valueKey],
                    option,
                    ripple: option.ripple,
                    disabled: option.disabled,
                    onMouseenter: _cache[0] || (_cache[0] = ($event) => _ctx.allowChildrenClose())
                  }, null, 8, ["label", "value", "option", "ripple", "disabled"]))
                ],
                64
                /* STABLE_FRAGMENT */
              );
            }),
            128
            /* KEYED_FRAGMENT */
          )),
          vue.renderSlot(_ctx.$slots, "options")
        ],
        2
        /* CLASS */
      )
    ]),
    default: vue.withCtx(() => [
      vue.renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
    /* FORWARDED */
  }, 8, ["show", "class", "disabled", "trigger", "reference", "placement", "strategy", "offset-x", "offset-y", "teleport", "same-width", "elevation", "popover-class", "close-on-click-reference", "onOpen", "onOpened", "onClose", "onClosed", "onClickOutside"]);
}
const __sfc__$1i = vue.defineComponent({
  name: name$1a,
  components: { VarMenu: stdin_default$5H, VarMenuOption: stdin_default$5J, VarMenuChildren: stdin_default$5G },
  props: props$19,
  setup(props2) {
    const show = useVModel(props2, "show");
    const menu = vue.ref();
    const menuOptionsRef = vue.ref();
    const menuChildren = vue.ref();
    const enhancedOptions = vue.computed(() => enhance(props2.options));
    const { menuOptions, length, bindMenuOptions } = useMenuOptions();
    const { computeLabel, getSelectedValue, getOptionProviderKey } = useSelectController({
      modelValue: () => props2.modelValue,
      multiple: () => props2.multiple,
      optionProviders: () => menuOptions,
      optionProvidersLength: () => length.value,
      optionIsIndeterminate(optionProvider) {
        var _a;
        const enhancedOption = getEnhancedOption(optionProvider.value.value);
        if (!enhancedOption) {
          return false;
        }
        const children = ((_a = enhancedOption._children) != null ? _a : []).filter((option) => !option.disabled);
        const selectedChildren = children.filter((option) => props2.modelValue.includes(option.value));
        return selectedChildren.length > 0 && selectedChildren.length < children.length;
      }
    });
    const highlightOptions = vue.computed(() => {
      const { multiple, modelValue } = props2;
      if (multiple) {
        return [];
      }
      const selectedOption = enhancedOptions.value.find((option) => option.value === modelValue);
      const highlightOptions2 = [];
      let parent = selectedOption == null ? void 0 : selectedOption._parent;
      while (parent) {
        highlightOptions2.push(parent);
        parent = parent._parent;
      }
      return highlightOptions2;
    });
    const menuSelectProvider = {
      size: vue.computed(() => props2.size),
      multiple: vue.computed(() => props2.multiple),
      computeLabel,
      onSelect
    };
    bindMenuOptions(menuSelectProvider);
    useEventListener(() => window, "keydown", handleKeydown);
    function getEnhancedOption(value) {
      return enhancedOptions.value.find((option) => option.value === value);
    }
    function getOptionProvider(value) {
      return menuOptions.find((optionProvider) => optionProvider.value.value === value);
    }
    function getOptionChildren(option) {
      return option[props2.childrenKey];
    }
    function flatten(options) {
      const flattenOptions = [];
      baseFlatten(options);
      function baseFlatten(options2) {
        options2.forEach((option) => {
          flattenOptions.push(option);
          const children = getOptionChildren(option);
          if (children) {
            baseFlatten(children);
          }
        });
      }
      return flattenOptions;
    }
    function enhance(options) {
      function baseEnhance(options2, parent) {
        return options2.map((option) => {
          option = __spreadProps$7(__spreadValues$o({}, option), { _rawOption: option });
          if (parent) {
            option._parent = parent;
          }
          const children = getOptionChildren(option);
          if (children) {
            const enhancedChildren = baseEnhance(children, option);
            option[props2.childrenKey] = enhancedChildren;
            option._children = flatten(enhancedChildren);
          }
          return option;
        });
      }
      return flatten(baseEnhance(options));
    }
    function onSelect(optionProvider) {
      var _a, _b;
      const { multiple, closeOnSelect } = props2;
      const { value, label, selected, disabled, ripple } = optionProvider;
      const enhancedOption = getEnhancedOption(value.value);
      if (enhancedOption) {
        const childrenValues = ((_a = enhancedOption._children) != null ? _a : []).filter((option) => !option.disabled).map((option) => option.value);
        if (multiple && selected.value) {
          menuOptions.forEach((optionProvider2) => {
            if (childrenValues.includes(optionProvider2.value.value)) {
              optionProvider2.sync(true, false);
            }
          });
          broadcastParentOption(enhancedOption);
        }
        if (multiple && !selected.value) {
          menuOptions.forEach((optionProvider2) => {
            if (childrenValues.includes(optionProvider2.value.value)) {
              optionProvider2.sync(false, false);
            }
          });
          broadcastParentOption(enhancedOption);
        }
      }
      const selectedValue = getSelectedValue(optionProvider);
      const selectedOption = (_b = enhancedOption == null ? void 0 : enhancedOption._rawOption) != null ? _b : {
        value: value.value,
        label: label.value,
        disabled: disabled.value,
        ripple: ripple.value
      };
      call(props2.onSelect, getOptionProviderKey(optionProvider), selectedOption);
      call(props2["onUpdate:modelValue"], selectedValue);
      if (!multiple && closeOnSelect) {
        menu.value.$el.focus();
        close();
      }
    }
    function broadcastParentOption(enhancedOption) {
      let parentOption = enhancedOption._parent;
      while (parentOption) {
        const parentOptionProvider = getOptionProvider(parentOption.value);
        const parentOptionChildren = getOptionChildren(parentOption).filter((option) => !option.disabled);
        const isAllChildrenUnselected = parentOptionChildren.every((option) => {
          const optionProvider = getOptionProvider(option.value);
          return !optionProvider.selected.value;
        });
        const isAllChildrenSelected = parentOptionChildren.every((option) => {
          const optionProvider = getOptionProvider(option.value);
          return optionProvider.selected.value;
        });
        if (isAllChildrenUnselected) {
          parentOptionProvider.sync(false, false);
        } else if (isAllChildrenSelected) {
          parentOptionProvider.sync(true, false);
        } else {
          parentOptionProvider.sync(false, true);
        }
        parentOption = parentOption._parent;
      }
    }
    function handleKeydown(event) {
      if (props2.disabled || !show.value) {
        return;
      }
      const { key: key3 } = event;
      if (["Escape", "ArrowDown", "ArrowUp"].includes(key3)) {
        preventDefault(event);
      }
      if (key3 === "Escape") {
        menu.value.$el.focus();
        close();
        call(props2.onKeyEscape);
        return;
      }
      if (key3 === "ArrowDown" || key3 === "ArrowUp") {
        focusChildElementByKey(
          menu.value.$el,
          menuOptionsRef.value,
          key3,
          (activeElement, nextActiveElement, isActiveInReferenceElements) => {
            if (isActiveInReferenceElements) {
              return true;
            }
            return getActiveElementParent(activeElement) === getActiveElementParent(nextActiveElement);
          }
        );
      }
    }
    function getActiveElementParent(activeElement) {
      var _a, _b, _c;
      if (activeElement.classList.contains("var-menu-option--children-trigger")) {
        return (_a = activeElement.parentNode) == null ? void 0 : _a.parentNode;
      }
      if (activeElement.classList.contains("var-checkbox__action")) {
        const optionElement = (_c = (_b = activeElement.parentNode) == null ? void 0 : _b.parentNode) == null ? void 0 : _c.parentNode;
        if (optionElement) {
          return getActiveElementParent(optionElement);
        }
      }
      return activeElement.parentNode;
    }
    function allowChildrenClose(option) {
      var _a;
      (_a = menuChildren.value) == null ? void 0 : _a.forEach((child) => {
        child.allowClose();
        if (option == null) {
          child.close();
          return;
        }
        if (child.option.value === option.value) {
          return;
        }
        child.close();
      });
    }
    function open() {
      var _a;
      (_a = menu.value) == null ? void 0 : _a.open();
    }
    function close() {
      var _a;
      (_a = menu.value) == null ? void 0 : _a.close();
    }
    function resize() {
      var _a;
      (_a = menu.value) == null ? void 0 : _a.resize();
    }
    function setReference(reference2) {
      var _a;
      (_a = menu.value) == null ? void 0 : _a.setReference(reference2);
    }
    return {
      show,
      menu,
      menuOptionsRef,
      menuChildren,
      highlightOptions,
      n: n$1h,
      classes: classes$10,
      allowChildrenClose,
      formatElevation,
      open,
      close,
      resize,
      setReference
    };
  }
});
__sfc__$1i.render = __render__$1f;
var stdin_default$5F = __sfc__$1i;
withInstall(stdin_default$5F);
withPropsDefaultsSetter(stdin_default$5F, props$19);
const _MenuSelectComponent = stdin_default$5F;
var stdin_default$5E = stdin_default$5F;
var __defProp$n = Object.defineProperty;
var __getOwnPropSymbols$n = Object.getOwnPropertySymbols;
var __hasOwnProp$n = Object.prototype.hasOwnProperty;
var __propIsEnum$n = Object.prototype.propertyIsEnumerable;
var __defNormalProp$n = (obj, key3, value) => key3 in obj ? __defProp$n(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$n = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$n.call(b, prop))
      __defNormalProp$n(a, prop, b[prop]);
  if (__getOwnPropSymbols$n)
    for (var prop of __getOwnPropSymbols$n(b)) {
      if (__propIsEnum$n.call(b, prop))
        __defNormalProp$n(a, prop, b[prop]);
    }
  return a;
};
const props$18 = __spreadValues$n({
  modelValue: String,
  options: {
    type: Array,
    default: () => []
  },
  labelKey: {
    type: String,
    default: "label"
  },
  valueKey: {
    type: String,
    default: "value"
  },
  maxlength: [String, Number],
  readonly: Boolean,
  disabled: Boolean,
  validateTrigger: {
    type: Array,
    default: () => ["onInput", "onClear", "onChange"]
  },
  getShow: Function,
  rules: [Array, Function, Object],
  onFocus: defineListenerProp(),
  onBlur: defineListenerProp(),
  onInput: defineListenerProp(),
  onChange: defineListenerProp(),
  onClear: defineListenerProp(),
  onClick: defineListenerProp(),
  "onUpdate:modelValue": defineListenerProp()
}, pickProps(props$1d, [
  "size",
  "variant",
  "placeholder",
  "enterkeyhint",
  "line",
  "hint",
  "textColor",
  "focusColor",
  "blurColor",
  "clearable"
]));
var __async$f = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const { name: name$19, n: n$1g } = createNamespace("auto-complete");
const _hoisted_1$u = ["tabindex"];
function __render__$1e(_ctx, _cache) {
  const _component_var_input = vue.resolveComponent("var-input");
  const _component_var_menu_option = vue.resolveComponent("var-menu-option");
  const _component_var_menu_select = vue.resolveComponent("var-menu-select");
  const _component_var_form_details = vue.resolveComponent("var-form-details");
  return vue.openBlock(), vue.createElementBlock("div", {
    ref: "root",
    class: vue.normalizeClass(_ctx.n()),
    tabindex: _ctx.disabled || _ctx.formDisabled ? void 0 : "0",
    onFocusin: _cache[2] || (_cache[2] = (...args) => _ctx.focus && _ctx.focus(...args)),
    onClick: _cache[3] || (_cache[3] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    vue.createVNode(_component_var_menu_select, {
      show: _ctx.isShowMenuSelect,
      "onUpdate:show": _cache[1] || (_cache[1] = ($event) => _ctx.isShowMenuSelect = $event),
      "same-width": "",
      "auto-complete-cover": "",
      scrollable: "",
      trigger: "manual",
      placement: "bottom",
      disabled: _ctx.disabled || _ctx.formDisabled || _ctx.readonly || _ctx.formReadonly,
      class: vue.normalizeClass(_ctx.n("menu-select")),
      "popover-class": _ctx.variant === "standard" ? _ctx.n("--standard-menu-margin") : void 0,
      "onUpdate:modelValue": _ctx.handleAutoComplete,
      onKeyEscape: _ctx.handleKeyEscape
    }, {
      options: vue.withCtx(() => [
        vue.createElementVNode(
          "div",
          {
            class: vue.normalizeClass(_ctx.n("options"))
          },
          [
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList(_ctx.viewOptions, (option) => {
                return vue.openBlock(), vue.createBlock(_component_var_menu_option, {
                  key: option[_ctx.valueKey],
                  label: option[_ctx.labelKey],
                  value: option[_ctx.valueKey],
                  option,
                  disabled: option.disabled
                }, null, 8, ["label", "value", "option", "disabled"]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ],
          2
          /* CLASS */
        )
      ]),
      default: vue.withCtx(() => [
        vue.createVNode(_component_var_input, vue.mergeProps({ ref: "input" }, {
          maxlength: _ctx.maxlength,
          enterkeyhint: _ctx.enterkeyhint,
          placeholder: _ctx.placeholder,
          size: _ctx.size,
          variant: _ctx.variant,
          line: _ctx.line,
          hint: _ctx.hint,
          textColor: _ctx.textColor,
          focusColor: _ctx.focusColor,
          blurColor: _ctx.blurColor,
          readonly: _ctx.readonly,
          disabled: _ctx.disabled,
          clearable: _ctx.clearable
        }, {
          modelValue: _ctx.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.value = $event),
          autocomplete: "off",
          "is-force-focusing-effect": _ctx.isFocusing,
          "is-force-error-effect": !!_ctx.errorMessage,
          "is-show-form-details": false,
          onInput: _ctx.handleInput,
          onBlur: _ctx.handleBlur,
          onClear: _ctx.handleClear,
          onChange: _ctx.handleChange
        }), vue.createSlots({
          _: 2
          /* DYNAMIC */
        }, [
          _ctx.$slots["prepend-icon"] ? {
            name: "prepend-icon",
            fn: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "prepend-icon")
            ]),
            key: "0"
          } : void 0,
          _ctx.$slots["append-icon"] ? {
            name: "append-icon",
            fn: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "append-icon")
            ]),
            key: "1"
          } : void 0,
          _ctx.$slots["clear-icon"] ? {
            name: "clear-icon",
            fn: vue.withCtx(({ clear: clear2 }) => [
              vue.renderSlot(_ctx.$slots, "clear-icon", { clear: clear2 })
            ]),
            key: "2"
          } : void 0,
          _ctx.$slots["extra-message"] ? {
            name: "extra-message",
            fn: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "extra-message")
            ]),
            key: "3"
          } : void 0
        ]), 1040, ["modelValue", "is-force-focusing-effect", "is-force-error-effect", "onInput", "onBlur", "onClear", "onChange"])
      ]),
      _: 3
      /* FORWARDED */
    }, 8, ["show", "disabled", "class", "popover-class", "onUpdate:modelValue", "onKeyEscape"]),
    vue.createVNode(_component_var_form_details, {
      "error-message": _ctx.errorMessage,
      "extra-message": _ctx.maxlengthText
    }, null, 8, ["error-message", "extra-message"])
  ], 42, _hoisted_1$u);
}
const __sfc__$1h = vue.defineComponent({
  name: name$19,
  components: {
    VarInput: stdin_default$5N,
    VarMenuSelect: stdin_default$5E,
    VarMenuOption: stdin_default$5J,
    VarFormDetails: stdin_default$5R
  },
  props: props$18,
  setup(props2) {
    const root = vue.ref();
    const input = vue.ref();
    const isFocusing = vue.ref(false);
    const value = useVModel(props2, "modelValue");
    const viewOptions = vue.ref([]);
    const isShowMenuSelect = vue.ref(false);
    const maxlengthText = vue.computed(() => {
      const { maxlength } = props2;
      if (!maxlength) {
        return "";
      }
      if (isEmpty(value.value)) {
        return `0 / ${maxlength}`;
      }
      return `${String(value.value).length}/${maxlength}`;
    });
    const {
      errorMessage,
      validateWithTrigger: vt,
      validate: v,
      // expose
      resetValidation
    } = useValidation();
    const { bindForm, form } = useForm();
    let clearing = false;
    const autoCompleteProvider = {
      reset,
      resetValidation,
      validate
    };
    useClickOutside(
      () => root.value,
      "click",
      () => {
        if (clearing) {
          clearing = false;
          return;
        }
        blur();
      }
    );
    vue.watch(() => [props2.options, isFocusing.value], changeMenuState);
    call(bindForm, autoCompleteProvider);
    useEventListener(() => window, "keydown", handleKeydown);
    function reset() {
      call(props2["onUpdate:modelValue"], "");
      resetValidation();
    }
    function validate() {
      return v(props2.rules, props2.modelValue);
    }
    function focus() {
      if (isFocusing.value || props2.disabled || (form == null ? void 0 : form.disabled.value)) {
        return;
      }
      isFocusing.value = true;
      input.value.focus();
      call(props2.onFocus);
      validateWithTrigger("onFocus");
    }
    function blur() {
      if (!isFocusing.value) {
        return;
      }
      isFocusing.value = false;
      isShowMenuSelect.value = false;
      input.value.blur();
      call(props2.onBlur);
      validateWithTrigger("onBlur");
    }
    function handleBlur() {
      if (isShowMenuSelect.value) {
        return;
      }
      blur();
    }
    function validateWithTrigger(trigger) {
      vue.nextTick(() => {
        const { validateTrigger, rules, modelValue } = props2;
        vt(validateTrigger, trigger, rules, modelValue);
      });
    }
    function handleKeydown(event) {
      return __async$f(this, null, function* () {
        var _a;
        if ((form == null ? void 0 : form.disabled.value) || (form == null ? void 0 : form.readonly.value) || props2.disabled || props2.readonly || !isFocusing.value || !isShowMenuSelect.value) {
          return;
        }
        const { key: key3 } = event;
        if (key3 === "Tab") {
          preventDefault(event);
          root.value.focus();
          isShowMenuSelect.value = false;
          return;
        }
        if (!["ArrowUp", "ArrowDown", "Enter"].includes(key3)) {
          input.value.focus();
          return;
        }
        if (key3 === "Enter") {
          yield raf();
          (_a = input.value) == null ? void 0 : _a.focus();
        }
      });
    }
    function changeMenuState() {
      if (isFocusing.value) {
        isShowMenuSelect.value = getShowMenuSelect(value.value);
      }
      if (isShowMenuSelect.value) {
        viewOptions.value = props2.options;
      }
    }
    function handleInput(newValue, event) {
      changeMenuState();
      call(props2.onInput, newValue, event);
      validateWithTrigger("onInput");
    }
    function handleClear() {
      clearing = true;
      changeMenuState();
      call(props2.onClear, value.value);
      validateWithTrigger("onClear");
    }
    function handleClick(event) {
      if (props2.disabled || (form == null ? void 0 : form.disabled.value)) {
        return;
      }
      call(props2.onClick, event);
      validateWithTrigger("onClick");
    }
    function handleChange(newValue) {
      call(props2.onChange, newValue);
      validateWithTrigger("onChange");
    }
    function handleAutoComplete(newValue) {
      return __async$f(this, null, function* () {
        var _a;
        if (props2.maxlength != null) {
          newValue = newValue.slice(0, toNumber(props2.maxlength));
        }
        if (newValue !== value.value) {
          value.value = newValue;
          call(props2.onChange, newValue);
          validateWithTrigger("onChange");
        }
        yield raf();
        (_a = input.value) == null ? void 0 : _a.focus();
      });
    }
    function handleKeyEscape() {
      input.value.focus();
    }
    function getShowMenuSelect(newValue) {
      if (props2.disabled || props2.readonly || (form == null ? void 0 : form.disabled.value) || (form == null ? void 0 : form.readonly.value)) {
        return false;
      }
      return props2.options.length > 0 && (props2.getShow != null ? props2.getShow(newValue) : newValue.length > 0);
    }
    return {
      root,
      input,
      value,
      isShowMenuSelect,
      viewOptions,
      isFocusing,
      formDisabled: form == null ? void 0 : form.disabled,
      formReadonly: form == null ? void 0 : form.readonly,
      errorMessage,
      maxlengthText,
      n: n$1g,
      handleInput,
      handleClear,
      handleClick,
      handleChange,
      handleBlur,
      handleKeyEscape,
      handleAutoComplete,
      reset,
      validate,
      resetValidation,
      blur,
      focus
    };
  }
});
__sfc__$1h.render = __render__$1e;
var stdin_default$5D = __sfc__$1h;
withInstall(stdin_default$5D);
withPropsDefaultsSetter(stdin_default$5D, props$18);
const _AutoCompleteComponent = stdin_default$5D;
var stdin_default$5C = stdin_default$5D;
const isHTMLSupportImage = (val) => {
  if (!isString(val)) {
    return false;
  }
  return val.startsWith("data:image") || /\.(png|jpg|gif|jpeg|svg|webp|ico)$/i.test(val);
};
const isHTMLSupportVideo = (val) => {
  if (!isString(val)) {
    return false;
  }
  return val.startsWith("data:video") || /\.(mp4|webm|ogg)$/.test(val);
};
const createCache = (max2) => {
  const cache = [];
  return {
    cache,
    has(key3) {
      return this.cache.includes(key3);
    },
    add(key3) {
      if (this.has(key3)) {
        return;
      }
      this.cache.length === max2 && cache.shift();
      this.cache.push(key3);
    },
    remove(key3) {
      this.has(key3) && removeItem(this.cache, key3);
    },
    clear() {
      this.cache.length = 0;
    }
  };
};
const linear = (value) => value;
const cubic = (value) => value ** 3;
const easeInOutCubic = (value) => value < 0.5 ? cubic(value * 2) / 2 : 1 - cubic((1 - value) * 2) / 2;
const padStart$1 = (str, maxLength, fillString = "") => {
  if (str === void 0) {
    str = "";
  }
  if (str.length >= maxLength) {
    return str;
  }
  const len = maxLength - str.length;
  const repeatCount = Math.floor(len / fillString.length);
  return fillString.repeat(repeatCount) + fillString.slice(0, len % fillString.length) + str;
};
var __defProp$m = Object.defineProperty;
var __getOwnPropSymbols$m = Object.getOwnPropertySymbols;
var __hasOwnProp$m = Object.prototype.hasOwnProperty;
var __propIsEnum$m = Object.prototype.propertyIsEnumerable;
var __defNormalProp$m = (obj, key3, value) => key3 in obj ? __defProp$m(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$m = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$m.call(b, prop))
      __defNormalProp$m(a, prop, b[prop]);
  if (__getOwnPropSymbols$m)
    for (var prop of __getOwnPropSymbols$m(b)) {
      if (__propIsEnum$m.call(b, prop))
        __defNormalProp$m(a, prop, b[prop]);
    }
  return a;
};
var __async$e = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const BACKGROUND_IMAGE_ARG_NAME = "background-image";
const LAZY_LOADING = "lazy-loading";
const LAZY_ERROR = "lazy-error";
const LAZY_ATTEMPT = "lazy-attempt";
const EVENTS = ["scroll", "wheel", "mousewheel", "resize", "animationend", "transitionend", "touchmove"];
const PIXEL = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
const lazyElements = [];
const listenTargets = [];
const imageCache = createCache(100);
const defaultLazyOptions = {
  loading: PIXEL,
  error: PIXEL,
  attempt: 3,
  throttleWait: 300,
  events: EVENTS
};
let checkAllWithThrottle = throttle(checkAll, defaultLazyOptions.throttleWait);
function setSRC(el, src) {
  if (el._lazy.arg === BACKGROUND_IMAGE_ARG_NAME) {
    el.style.backgroundImage = `url(${src})`;
  } else {
    el.setAttribute("src", src);
  }
}
function setLoading(el) {
  el._lazy.loading && setSRC(el, el._lazy.loading);
  checkAll();
}
function setError(el) {
  el._lazy.error && setSRC(el, el._lazy.error);
  el._lazy.state = "error";
  clear(el);
  checkAll();
}
function setSuccess(el, attemptSRC) {
  setSRC(el, attemptSRC);
  el._lazy.state = "success";
  clear(el);
  checkAll();
}
function bindEvents(listenTarget) {
  var _a;
  if (listenTargets.includes(listenTarget)) {
    return;
  }
  listenTargets.push(listenTarget);
  (_a = defaultLazyOptions.events) == null ? void 0 : _a.forEach((event) => {
    listenTarget.addEventListener(event, checkAllWithThrottle, { passive: true });
  });
}
function unbindEvents() {
  listenTargets.forEach((listenTarget) => {
    var _a;
    (_a = defaultLazyOptions.events) == null ? void 0 : _a.forEach((event) => {
      listenTarget.removeEventListener(event, checkAllWithThrottle);
    });
  });
  listenTargets.length = 0;
}
function createLazy(el, binding) {
  var _a, _b;
  const lazyOptions = {
    loading: (_a = el.getAttribute(LAZY_LOADING)) != null ? _a : defaultLazyOptions.loading,
    error: (_b = el.getAttribute(LAZY_ERROR)) != null ? _b : defaultLazyOptions.error,
    attempt: el.getAttribute(LAZY_ATTEMPT) ? Number(el.getAttribute(LAZY_ATTEMPT)) : defaultLazyOptions.attempt
  };
  el._lazy = __spreadValues$m({
    src: binding.value,
    arg: binding.arg,
    currentAttempt: 0,
    state: "pending",
    attemptLock: false
  }, lazyOptions);
  setSRC(el, PIXEL);
  call(defaultLazyOptions.filter, el._lazy);
}
function createImage(el, attemptSRC) {
  const image = new Image();
  image.src = attemptSRC;
  el._lazy.preloadImage = image;
  image.addEventListener("load", () => {
    el._lazy.attemptLock = false;
    imageCache.add(attemptSRC);
    setSuccess(el, attemptSRC);
  });
  image.addEventListener("error", () => {
    el._lazy.attemptLock = false;
    el._lazy.currentAttempt >= el._lazy.attempt ? setError(el) : attemptLoad(el);
  });
}
function attemptLoad(el) {
  if (el._lazy.attemptLock) {
    return;
  }
  el._lazy.attemptLock = true;
  el._lazy.currentAttempt++;
  const { src: attemptSRC } = el._lazy;
  if (imageCache.has(attemptSRC)) {
    setSuccess(el, attemptSRC);
    el._lazy.attemptLock = false;
    return;
  }
  setLoading(el);
  createImage(el, attemptSRC);
}
function check(el) {
  return __async$e(this, null, function* () {
    yield doubleRaf();
    if (inViewport(el)) {
      attemptLoad(el);
    }
  });
}
function checkAll() {
  lazyElements.forEach((el) => check(el));
}
function add$1(el) {
  return __async$e(this, null, function* () {
    !lazyElements.includes(el) && lazyElements.push(el);
    getAllParentScroller(el).forEach(bindEvents);
    yield check(el);
  });
}
function clear(el) {
  removeItem(lazyElements, el);
  lazyElements.length === 0 && unbindEvents();
}
function diff(el, binding) {
  const { src, arg } = el._lazy;
  return src !== binding.value || arg !== binding.arg;
}
function mounted(el, binding) {
  return __async$e(this, null, function* () {
    createLazy(el, binding);
    yield add$1(el);
  });
}
function updated(el, binding) {
  return __async$e(this, null, function* () {
    if (!diff(el, binding)) {
      lazyElements.includes(el) && (yield check(el));
      return;
    }
    yield mounted(el, binding);
  });
}
function mergeLazyOptions(lazyOptions = {}) {
  const { events, loading, error: error2, attempt, throttleWait, filter } = lazyOptions;
  defaultLazyOptions.events = events != null ? events : defaultLazyOptions.events;
  defaultLazyOptions.loading = loading != null ? loading : defaultLazyOptions.loading;
  defaultLazyOptions.error = error2 != null ? error2 : defaultLazyOptions.error;
  defaultLazyOptions.attempt = attempt != null ? attempt : defaultLazyOptions.attempt;
  defaultLazyOptions.throttleWait = throttleWait != null ? throttleWait : defaultLazyOptions.throttleWait;
  defaultLazyOptions.filter = filter;
}
const Lazy = {
  mounted,
  unmounted: clear,
  updated,
  install(app, lazyOptions) {
    mergeLazyOptions(lazyOptions);
    checkAllWithThrottle = throttle(checkAll, defaultLazyOptions.throttleWait);
    app.directive("lazy", this);
  }
};
const _LazyComponent = Lazy;
var stdin_default$5B = Lazy;
const props$17 = {
  round: {
    type: Boolean,
    default: true
  },
  size: {
    type: [String, Number],
    default: "normal"
  },
  alt: String,
  color: String,
  src: String,
  fit: {
    type: String,
    default: "cover"
  },
  bordered: Boolean,
  borderColor: String,
  loading: String,
  error: String,
  lazy: Boolean,
  hoverable: Boolean,
  onClick: defineListenerProp(),
  onLoad: defineListenerProp(),
  onError: defineListenerProp()
};
const isInternalSize$1 = (size) => ["mini", "small", "normal", "large"].includes(size);
const { name: name$18, n: n$1f, classes: classes$$ } = createNamespace("avatar");
const _hoisted_1$t = ["src", "alt", "lazy-loading", "lazy-error"];
const _hoisted_2$7 = ["src", "alt"];
function __render__$1d(_ctx, _cache) {
  const _directive_lazy = vue.resolveDirective("lazy");
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      ref: "avatarElement",
      class: vue.normalizeClass(
        _ctx.classes(
          _ctx.n(),
          _ctx.n("$--box"),
          [_ctx.isInternalSize(_ctx.size), _ctx.n(`--${_ctx.size}`)],
          [_ctx.round, _ctx.n("--round")],
          [_ctx.bordered, _ctx.n("--bordered")],
          [_ctx.hoverable, _ctx.n("--hoverable")]
        )
      ),
      style: vue.normalizeStyle({
        width: !_ctx.isInternalSize(_ctx.size) ? _ctx.toSizeUnit(_ctx.size) : void 0,
        height: !_ctx.isInternalSize(_ctx.size) ? _ctx.toSizeUnit(_ctx.size) : void 0,
        borderColor: _ctx.borderColor,
        backgroundColor: _ctx.color
      }),
      onClick: _cache[3] || (_cache[3] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    },
    [
      _ctx.src ? (vue.openBlock(), vue.createElementBlock(
        vue.Fragment,
        { key: 0 },
        [
          _ctx.lazy ? vue.withDirectives((vue.openBlock(), vue.createElementBlock("img", {
            key: 0,
            role: "img",
            class: vue.normalizeClass(_ctx.n("image")),
            src: _ctx.src,
            alt: _ctx.alt,
            style: vue.normalizeStyle({ objectFit: _ctx.fit }),
            "lazy-loading": _ctx.loading,
            "lazy-error": _ctx.error,
            onLoad: _cache[0] || (_cache[0] = (...args) => _ctx.handleLoad && _ctx.handleLoad(...args))
          }, null, 46, _hoisted_1$t)), [
            [_directive_lazy, _ctx.src]
          ]) : (vue.openBlock(), vue.createElementBlock("img", {
            key: 1,
            role: "img",
            class: vue.normalizeClass(_ctx.n("image")),
            src: _ctx.src,
            alt: _ctx.alt,
            style: vue.normalizeStyle({ objectFit: _ctx.fit }),
            onLoad: _cache[1] || (_cache[1] = (...args) => _ctx.handleLoad && _ctx.handleLoad(...args)),
            onError: _cache[2] || (_cache[2] = (...args) => _ctx.handleError && _ctx.handleError(...args))
          }, null, 46, _hoisted_2$7))
        ],
        64
        /* STABLE_FRAGMENT */
      )) : (vue.openBlock(), vue.createElementBlock(
        "div",
        {
          key: 1,
          ref: "textElement",
          class: vue.normalizeClass(_ctx.n("text")),
          style: vue.normalizeStyle({ transform: `scale(${_ctx.scale})` })
        },
        [
          vue.renderSlot(_ctx.$slots, "default")
        ],
        6
        /* CLASS, STYLE */
      ))
    ],
    6
    /* CLASS, STYLE */
  );
}
const __sfc__$1g = vue.defineComponent({
  name: name$18,
  directives: { Lazy: stdin_default$5B },
  props: props$17,
  setup(props2) {
    const avatarElement = vue.ref(null);
    const textElement = vue.ref(null);
    const scale = vue.ref(1);
    onSmartMounted(getScale);
    vue.onUpdated(getScale);
    function getScale() {
      if (!avatarElement.value || !textElement.value) {
        scale.value = 1;
        return;
      }
      const avatarElementWidth = avatarElement.value.offsetWidth;
      const textElementWidth = textElement.value.offsetWidth;
      if (avatarElementWidth > textElementWidth) {
        scale.value = 1;
      } else {
        scale.value = avatarElementWidth / textElementWidth;
      }
    }
    function handleLoad(e) {
      const el = e.currentTarget;
      const { lazy, onLoad, onError } = props2;
      if (lazy) {
        el._lazy.state === "success" && call(onLoad, e);
        el._lazy.state === "error" && call(onError, e);
      } else {
        call(onLoad, e);
      }
    }
    function handleError(e) {
      call(props2.onError, e);
    }
    function handleClick(e) {
      call(props2.onClick, e);
    }
    return {
      avatarElement,
      textElement,
      scale,
      n: n$1f,
      classes: classes$$,
      isInternalSize: isInternalSize$1,
      toSizeUnit,
      handleLoad,
      handleError,
      handleClick
    };
  }
});
__sfc__$1g.render = __render__$1d;
var stdin_default$5A = __sfc__$1g;
withInstall(stdin_default$5A);
withPropsDefaultsSetter(stdin_default$5A, props$17);
const _AvatarComponent = stdin_default$5A;
var stdin_default$5z = stdin_default$5A;
const props$16 = {
  offset: [Number, String],
  vertical: Boolean
};
const { name: name$17, n: n$1e, classes: classes$_ } = createNamespace("avatar-group");
function __render__$1c(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.classes(_ctx.n(), [_ctx.vertical, _ctx.n("--column"), _ctx.n("--row")])),
      style: vue.normalizeStyle(_ctx.rootStyles)
    },
    [
      vue.renderSlot(_ctx.$slots, "default")
    ],
    6
    /* CLASS, STYLE */
  );
}
const __sfc__$1f = vue.defineComponent({
  name: name$17,
  props: props$16,
  setup(props2) {
    const rootStyles = vue.computed(() => {
      if (props2.offset == null) {
        return {};
      }
      return {
        "--avatar-group-offset": toSizeUnit(props2.offset)
      };
    });
    return {
      rootStyles,
      n: n$1e,
      classes: classes$_
    };
  }
});
__sfc__$1f.render = __render__$1c;
var stdin_default$5y = __sfc__$1f;
withInstall(stdin_default$5y);
withPropsDefaultsSetter(stdin_default$5y, props$16);
const _AvatarGroupComponent = stdin_default$5y;
var stdin_default$5x = stdin_default$5y;
const props$15 = {
  type: {
    type: String,
    default: "circle"
  },
  radius: [String, Number],
  size: {
    type: String,
    default: "normal"
  },
  color: String,
  description: String,
  loading: Boolean
};
const { name: name$16, n: n$1d, classes: classes$Z } = createNamespace("loading");
function __render__$1b(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.n())
    },
    [
      _ctx.$slots.default ? (vue.openBlock(), vue.createElementBlock(
        "div",
        {
          key: 0,
          class: vue.normalizeClass(_ctx.classes(_ctx.n("content"), [_ctx.loading, _ctx.n("content--active")]))
        },
        [
          vue.renderSlot(_ctx.$slots, "default"),
          _ctx.loading ? (vue.openBlock(), vue.createElementBlock(
            "div",
            {
              key: 0,
              class: vue.normalizeClass(_ctx.n("content-mask"))
            },
            null,
            2
            /* CLASS */
          )) : vue.createCommentVNode("v-if", true)
        ],
        2
        /* CLASS */
      )) : vue.createCommentVNode("v-if", true),
      _ctx.isShow ? (vue.openBlock(), vue.createElementBlock(
        "div",
        {
          key: 1,
          class: vue.normalizeClass(_ctx.classes(_ctx.n("$--box"), _ctx.n("body"), [_ctx.$slots.default, _ctx.n("inside")]))
        },
        [
          _ctx.type === "circle" ? (vue.openBlock(), vue.createElementBlock(
            "div",
            {
              key: 0,
              class: vue.normalizeClass(_ctx.n("circle"))
            },
            [
              vue.createElementVNode(
                "span",
                {
                  class: vue.normalizeClass(_ctx.classes(_ctx.n("circle-block"), _ctx.n(`circle-block--${_ctx.size}`))),
                  style: vue.normalizeStyle({
                    width: _ctx.multiplySizeUnit(_ctx.radius, 2),
                    height: _ctx.multiplySizeUnit(_ctx.radius, 2),
                    color: _ctx.color
                  })
                },
                _cache[0] || (_cache[0] = [
                  vue.createElementVNode(
                    "svg",
                    { viewBox: "25 25 50 50" },
                    [
                      vue.createElementVNode("circle", {
                        cx: "50",
                        cy: "50",
                        r: "20",
                        fill: "none"
                      })
                    ],
                    -1
                    /* HOISTED */
                  )
                ]),
                6
                /* CLASS, STYLE */
              )
            ],
            2
            /* CLASS */
          )) : vue.createCommentVNode("v-if", true),
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList(_ctx.loadingTypeDict, (nums, key3) => {
              return vue.openBlock(), vue.createElementBlock(
                vue.Fragment,
                { key: key3 },
                [
                  _ctx.type === key3 ? (vue.openBlock(), vue.createElementBlock(
                    "div",
                    {
                      key: 0,
                      class: vue.normalizeClass(_ctx.classes(_ctx.n(key3), _ctx.n(`${key3}--${_ctx.size}`)))
                    },
                    [
                      (vue.openBlock(true), vue.createElementBlock(
                        vue.Fragment,
                        null,
                        vue.renderList(nums, (num) => {
                          return vue.openBlock(), vue.createElementBlock(
                            "div",
                            {
                              key: num + key3,
                              style: vue.normalizeStyle({ backgroundColor: _ctx.color }),
                              class: vue.normalizeClass(_ctx.classes(_ctx.n(`${key3}-item`), _ctx.n(`${key3}-item--${_ctx.size}`)))
                            },
                            null,
                            6
                            /* CLASS, STYLE */
                          );
                        }),
                        128
                        /* KEYED_FRAGMENT */
                      ))
                    ],
                    2
                    /* CLASS */
                  )) : vue.createCommentVNode("v-if", true)
                ],
                64
                /* STABLE_FRAGMENT */
              );
            }),
            128
            /* KEYED_FRAGMENT */
          )),
          _ctx.$slots.description || _ctx.description ? (vue.openBlock(), vue.createElementBlock(
            "div",
            {
              key: 1,
              class: vue.normalizeClass(_ctx.classes(_ctx.n("description"), _ctx.n(`description--${_ctx.size}`))),
              style: vue.normalizeStyle({ color: _ctx.color })
            },
            [
              vue.renderSlot(_ctx.$slots, "description", {}, () => [
                vue.createTextVNode(
                  vue.toDisplayString(_ctx.description),
                  1
                  /* TEXT */
                )
              ])
            ],
            6
            /* CLASS, STYLE */
          )) : vue.createCommentVNode("v-if", true)
        ],
        2
        /* CLASS */
      )) : vue.createCommentVNode("v-if", true)
    ],
    2
    /* CLASS */
  );
}
const __sfc__$1e = vue.defineComponent({
  name: name$16,
  props: props$15,
  setup(props2, { slots }) {
    const isShow = vue.computed(() => {
      if (!call(slots.default)) {
        return true;
      }
      return props2.loading;
    });
    const loadingTypeDict = {
      wave: 5,
      cube: 4,
      rect: 8,
      disappear: 3
    };
    return {
      loadingTypeDict,
      isShow,
      n: n$1d,
      classes: classes$Z,
      multiplySizeUnit
    };
  }
});
__sfc__$1e.render = __render__$1b;
var stdin_default$5w = __sfc__$1e;
withInstall(stdin_default$5w);
withPropsDefaultsSetter(stdin_default$5w, props$15);
const _LoadingComponent = stdin_default$5w;
var stdin_default$5v = stdin_default$5w;
var __defProp$l = Object.defineProperty;
var __defProps$6 = Object.defineProperties;
var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$l = Object.getOwnPropertySymbols;
var __hasOwnProp$l = Object.prototype.hasOwnProperty;
var __propIsEnum$l = Object.prototype.propertyIsEnumerable;
var __defNormalProp$l = (obj, key3, value) => key3 in obj ? __defProp$l(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$l = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$l.call(b, prop))
      __defNormalProp$l(a, prop, b[prop]);
  if (__getOwnPropSymbols$l)
    for (var prop of __getOwnPropSymbols$l(b)) {
      if (__propIsEnum$l.call(b, prop))
        __defNormalProp$l(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));
const props$14 = {
  type: String,
  nativeType: {
    type: String,
    default: "button"
  },
  size: String,
  loading: Boolean,
  round: Boolean,
  block: Boolean,
  text: Boolean,
  outline: Boolean,
  disabled: Boolean,
  autoLoading: Boolean,
  iconContainer: Boolean,
  ripple: {
    type: Boolean,
    default: true
  },
  focusable: {
    type: Boolean,
    default: true
  },
  color: String,
  textColor: String,
  elevation: {
    type: [Boolean, Number, String],
    default: true
  },
  loadingRadius: [Number, String],
  loadingType: pickProps(props$15, "type"),
  loadingSize: __spreadProps$6(__spreadValues$l({}, pickProps(props$15, "size")), {
    default: void 0
  }),
  loadingColor: __spreadProps$6(__spreadValues$l({}, pickProps(props$15, "color")), {
    default: "currentColor"
  }),
  onClick: defineListenerProp(),
  onTouchstart: defineListenerProp()
};
const BUTTON_GROUP_BIND_BUTTON_KEY = Symbol("BUTTON_GROUP_BIND_BUTTON_KEY");
function useButtons() {
  const { bindChildren, childProviders, length } = useChildren(BUTTON_GROUP_BIND_BUTTON_KEY);
  return {
    length,
    buttons: childProviders,
    bindButtons: bindChildren
  };
}
function useButtonGroup() {
  const { bindParent, parentProvider, index } = useParent(BUTTON_GROUP_BIND_BUTTON_KEY);
  return {
    index,
    buttonGroup: parentProvider,
    bindButtonGroup: bindParent
  };
}
const { name: name$15, n: n$1c, classes: classes$Y } = createNamespace("button");
const _hoisted_1$s = ["tabindex", "type", "disabled"];
function __render__$1a(_ctx, _cache) {
  const _component_var_loading = vue.resolveComponent("var-loading");
  const _component_var_hover_overlay = vue.resolveComponent("var-hover-overlay");
  const _directive_ripple = vue.resolveDirective("ripple");
  const _directive_hover = vue.resolveDirective("hover");
  return vue.withDirectives((vue.openBlock(), vue.createElementBlock("button", {
    class: vue.normalizeClass(
      _ctx.classes(
        _ctx.n(),
        _ctx.n("$--box"),
        _ctx.n(`--${_ctx.states.size}`),
        [_ctx.block, `${_ctx.n("$--flex")} ${_ctx.n("--block")}`, _ctx.n("$--inline-flex")],
        [!_ctx.states.text, _ctx.states.elevation],
        [!_ctx.states.iconContainer && !_ctx.states.text, _ctx.n(`--${_ctx.states.type}`)],
        [_ctx.states.text, `${_ctx.n("--text")} ${_ctx.n(`--text-${_ctx.states.type}`)}`],
        [_ctx.states.iconContainer, _ctx.n(`--icon-container-${_ctx.states.type}`)],
        [_ctx.round, _ctx.n("--round")],
        [_ctx.states.outline, _ctx.n("--outline")],
        [_ctx.loading || _ctx.pending, _ctx.n("--loading")],
        [_ctx.disabled, _ctx.n("--disabled")],
        [_ctx.states.text && _ctx.disabled, _ctx.n("--text-disabled")]
      )
    ),
    tabindex: _ctx.focusable ? void 0 : "-1",
    style: vue.normalizeStyle({
      color: _ctx.states.textColor,
      background: _ctx.states.color
    }),
    type: _ctx.nativeType,
    disabled: _ctx.disabled,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args)),
    onTouchstart: _cache[1] || (_cache[1] = (...args) => _ctx.handleTouchstart && _ctx.handleTouchstart(...args)),
    onFocus: _cache[2] || (_cache[2] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
    onBlur: _cache[3] || (_cache[3] = ($event) => _ctx.isFocusing = false)
  }, [
    _ctx.loading || _ctx.pending ? (vue.openBlock(), vue.createBlock(_component_var_loading, {
      key: 0,
      class: vue.normalizeClass(_ctx.n("loading")),
      "var-button-cover": "",
      color: _ctx.loadingColor,
      type: _ctx.loadingType,
      size: _ctx.loadingSize || _ctx.states.size,
      radius: _ctx.loadingRadius
    }, null, 8, ["class", "color", "type", "size", "radius"])) : vue.createCommentVNode("v-if", true),
    vue.createElementVNode(
      "div",
      {
        class: vue.normalizeClass(_ctx.classes(_ctx.n("content"), [_ctx.loading || _ctx.pending, _ctx.n("--hidden")]))
      },
      [
        vue.renderSlot(_ctx.$slots, "default")
      ],
      2
      /* CLASS */
    ),
    vue.createVNode(_component_var_hover_overlay, {
      hovering: _ctx.disabled || _ctx.loading || _ctx.pending ? false : _ctx.hovering,
      focusing: _ctx.disabled || _ctx.loading || _ctx.pending ? false : _ctx.isFocusing
    }, null, 8, ["hovering", "focusing"])
  ], 46, _hoisted_1$s)), [
    [_directive_ripple, { disabled: _ctx.disabled || !_ctx.ripple || _ctx.loading || _ctx.pending }],
    [_directive_hover, _ctx.handleHovering, "desktop"]
  ]);
}
const __sfc__$1d = vue.defineComponent({
  name: name$15,
  components: {
    VarLoading: stdin_default$5v,
    VarHoverOverlay: stdin_default$60
  },
  directives: { Ripple: stdin_default$63, Hover: stdin_default$62 },
  props: props$14,
  setup(props2) {
    const isFocusing = vue.ref(false);
    const pending = vue.ref(false);
    const { buttonGroup } = useButtonGroup();
    const { hovering, handleHovering } = useHoverOverlay();
    const states = vue.computed(() => {
      var _a, _b, _c, _d, _e, _f;
      if (!buttonGroup) {
        return {
          elevation: formatElevation(props2.elevation, 2),
          type: (_a = props2.type) != null ? _a : "default",
          size: (_b = props2.size) != null ? _b : "normal",
          color: props2.color,
          text: props2.text,
          textColor: props2.textColor,
          outline: props2.outline,
          iconContainer: props2.iconContainer
        };
      }
      const { type, size, color, textColor, mode } = buttonGroup;
      return {
        elevation: "",
        type: (_c = props2.type) != null ? _c : type.value,
        size: (_d = props2.size) != null ? _d : size.value,
        color: (_e = props2.color) != null ? _e : color.value,
        textColor: (_f = props2.textColor) != null ? _f : textColor.value,
        text: mode.value === "text" || mode.value === "outline",
        outline: mode.value === "outline",
        iconContainer: mode.value === "icon-container"
      };
    });
    function attemptAutoLoading(result) {
      if (props2.autoLoading) {
        pending.value = true;
        Promise.all(normalizeToArray(result)).then(() => {
          pending.value = false;
        }).catch(() => {
          pending.value = false;
        });
      }
    }
    function handleClick(e) {
      const { loading, disabled, onClick } = props2;
      if (!onClick || loading || disabled || pending.value) {
        return;
      }
      attemptAutoLoading(call(onClick, e));
    }
    function handleTouchstart(e) {
      const { loading, disabled, onTouchstart } = props2;
      if (!onTouchstart || loading || disabled || pending.value) {
        return;
      }
      attemptAutoLoading(call(onTouchstart, e));
    }
    function handleFocus() {
      if (!props2.focusable) {
        return;
      }
      isFocusing.value = true;
    }
    return {
      pending,
      states,
      hovering,
      isFocusing,
      n: n$1c,
      classes: classes$Y,
      handleHovering,
      handleClick,
      handleTouchstart,
      handleFocus
    };
  }
});
__sfc__$1d.render = __render__$1a;
var stdin_default$5u = __sfc__$1d;
withInstall(stdin_default$5u);
withPropsDefaultsSetter(stdin_default$5u, props$14);
const _ButtonComponent = stdin_default$5u;
var stdin_default$5t = stdin_default$5u;
const props$13 = {
  visibilityHeight: {
    type: [Number, String],
    default: 200
  },
  duration: {
    type: Number,
    default: 300
  },
  right: [Number, String],
  elevation: {
    type: [Boolean, Number, String],
    default: true
  },
  bottom: [Number, String],
  target: [String, Object],
  onClick: defineListenerProp()
};
const { name: name$14, n: n$1b, classes: classes$X } = createNamespace("back-top");
function __render__$19(_ctx, _cache) {
  const _component_var_icon = vue.resolveComponent("var-icon");
  const _component_var_button = vue.resolveComponent("var-button");
  return vue.openBlock(), vue.createBlock(vue.Teleport, {
    to: "body",
    disabled: _ctx.disabled
  }, [
    vue.createElementVNode(
      "div",
      vue.mergeProps({
        ref: "backTopEl",
        class: _ctx.classes(_ctx.n(), [_ctx.show, _ctx.n("--active")]),
        style: {
          right: _ctx.toSizeUnit(_ctx.right),
          bottom: _ctx.toSizeUnit(_ctx.bottom)
        }
      }, _ctx.$attrs, {
        onClick: _cache[0] || (_cache[0] = vue.withModifiers((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["stop"]))
      }),
      [
        vue.renderSlot(_ctx.$slots, "default", {}, () => [
          vue.createVNode(_component_var_button, {
            elevation: _ctx.elevation,
            type: "primary",
            "var-back-top-cover": ""
          }, {
            default: vue.withCtx(() => [
              vue.createVNode(_component_var_icon, { name: "chevron-up" })
            ]),
            _: 1
            /* STABLE */
          }, 8, ["elevation"])
        ])
      ],
      16
      /* FULL_PROPS */
    )
  ], 8, ["disabled"]);
}
const __sfc__$1c = vue.defineComponent({
  name: name$14,
  components: {
    VarButton: stdin_default$5t,
    VarIcon: stdin_default$5_
  },
  inheritAttrs: false,
  props: props$13,
  setup(props2) {
    const show = vue.ref(false);
    const backTopEl = vue.ref(null);
    const disabled = vue.ref(true);
    let scroller;
    const handleScroll = throttle(() => {
      setBackTopVisibility();
    }, 200);
    vue.onMounted(() => {
      setScroller();
      addScrollerEventListener();
      setBackTopVisibility();
      disabled.value = false;
    });
    vue.onActivated(addScrollerEventListener);
    onSmartUnmounted(removeScrollerEventListener);
    function setBackTopVisibility() {
      show.value = getScrollTop(scroller) >= toPxNum(props2.visibilityHeight);
    }
    function handleClick(event) {
      call(props2.onClick, event);
      const left2 = getScrollLeft(scroller);
      scrollTo(scroller, {
        left: left2,
        duration: props2.duration,
        animation: easeInOutCubic
      });
    }
    function setScroller() {
      scroller = props2.target ? getTarget(props2.target, "BackTop") : getParentScroller(backTopEl.value);
    }
    function addScrollerEventListener() {
      scroller.addEventListener("scroll", handleScroll);
    }
    function removeScrollerEventListener() {
      if (!scroller) {
        return;
      }
      scroller.removeEventListener("scroll", handleScroll);
    }
    return {
      disabled,
      show,
      backTopEl,
      toSizeUnit,
      n: n$1b,
      classes: classes$X,
      handleClick
    };
  }
});
__sfc__$1c.render = __render__$19;
var stdin_default$5s = __sfc__$1c;
withInstall(stdin_default$5s);
withPropsDefaultsSetter(stdin_default$5s, props$13);
const _BackTopComponent = stdin_default$5s;
var stdin_default$5r = stdin_default$5s;
const props$12 = {
  type: {
    type: String,
    default: "default"
  },
  position: {
    type: String,
    default: "right-top"
  },
  hidden: Boolean,
  value: {
    type: [String, Number],
    default: 0
  },
  maxValue: [String, Number],
  dot: Boolean,
  icon: pickProps(props$1j, "name"),
  namespace: pickProps(props$1j, "namespace"),
  color: String,
  offsetX: {
    type: [String, Number],
    default: 0
  },
  offsetY: {
    type: [String, Number],
    default: 0
  }
};
var __defProp$k = Object.defineProperty;
var __getOwnPropSymbols$k = Object.getOwnPropertySymbols;
var __hasOwnProp$k = Object.prototype.hasOwnProperty;
var __propIsEnum$k = Object.prototype.propertyIsEnumerable;
var __defNormalProp$k = (obj, key3, value) => key3 in obj ? __defProp$k(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$k = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$k.call(b, prop))
      __defNormalProp$k(a, prop, b[prop]);
  if (__getOwnPropSymbols$k)
    for (var prop of __getOwnPropSymbols$k(b)) {
      if (__propIsEnum$k.call(b, prop))
        __defNormalProp$k(a, prop, b[prop]);
    }
  return a;
};
const { name: name$13, n: n$1a, classes: classes$W } = createNamespace("badge");
const _hoisted_1$r = { key: 0 };
function __render__$18(_ctx, _cache) {
  const _component_var_icon = vue.resolveComponent("var-icon");
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.classes(_ctx.n(), _ctx.n("$--box")))
    },
    [
      vue.renderSlot(_ctx.$slots, "default"),
      vue.createVNode(vue.Transition, {
        name: _ctx.n("$-badge-fade"),
        persisted: ""
      }, {
        default: vue.withCtx(() => [
          vue.withDirectives(vue.createElementVNode(
            "span",
            vue.mergeProps({
              class: _ctx.classes(
                _ctx.n("content"),
                _ctx.n(`--${_ctx.type}`),
                [_ctx.$slots.default, _ctx.n(`--${_ctx.position}`), _ctx.n("--offset")],
                [_ctx.dot, _ctx.n("--dot")],
                [_ctx.icon, _ctx.n("--icon")]
              ),
              style: __spreadValues$k({ background: _ctx.color }, _ctx.offsetStyle)
            }, _ctx.$attrs),
            [
              _ctx.icon ? (vue.openBlock(), vue.createBlock(_component_var_icon, {
                key: 0,
                class: vue.normalizeClass(_ctx.n("icon")),
                "var-badge-cover": "",
                name: _ctx.icon,
                namespace: _ctx.namespace
              }, null, 8, ["class", "name", "namespace"])) : vue.createCommentVNode("v-if", true),
              vue.renderSlot(_ctx.$slots, "value", {}, () => [
                !_ctx.icon && !_ctx.dot ? (vue.openBlock(), vue.createElementBlock(
                  "span",
                  _hoisted_1$r,
                  vue.toDisplayString(_ctx.value),
                  1
                  /* TEXT */
                )) : vue.createCommentVNode("v-if", true)
              ])
            ],
            16
            /* FULL_PROPS */
          ), [
            [vue.vShow, !_ctx.hidden]
          ])
        ]),
        _: 3
        /* FORWARDED */
      }, 8, ["name"])
    ],
    2
    /* CLASS */
  );
}
const __sfc__$1b = vue.defineComponent({
  name: name$13,
  components: { VarIcon: stdin_default$5_ },
  inheritAttrs: false,
  props: props$12,
  setup(props2) {
    const value = vue.computed(() => {
      const { value: value2, maxValue } = props2;
      return value2 != null && maxValue != null && toNumber(value2) > toNumber(maxValue) ? `${maxValue}+` : value2;
    });
    const offsetStyle = vue.computed(() => ({
      [`--badge-offset-y`]: toSizeUnit(props2.offsetY),
      [`--badge-offset-x`]: toSizeUnit(props2.offsetX)
    }));
    return {
      value,
      offsetStyle,
      n: n$1a,
      classes: classes$W
    };
  }
});
__sfc__$1b.render = __render__$18;
var stdin_default$5q = __sfc__$1b;
withInstall(stdin_default$5q);
withPropsDefaultsSetter(stdin_default$5q, props$12);
const _BadgeComponent = stdin_default$5q;
var stdin_default$5p = stdin_default$5q;
const props$11 = {
  active: {
    type: [Number, String],
    default: 0
  },
  zIndex: {
    type: [Number, String],
    default: 1
  },
  fixed: Boolean,
  border: Boolean,
  variant: Boolean,
  safeArea: Boolean,
  activeColor: String,
  inactiveColor: String,
  placeholder: Boolean,
  fabProps: Object,
  onChange: defineListenerProp(),
  onBeforeChange: defineListenerProp(),
  onFabClick: defineListenerProp(),
  "onUpdate:active": defineListenerProp()
};
const BOTTOM_NAVIGATION_BIND_BOTTOM_NAVIGATION_ITEM_KEY = Symbol(
  "BOTTOM_NAVIGATION_BIND_BOTTOM_NAVIGATION_ITEM_KEY"
);
function useBottomNavigationItems() {
  const { childProviders, length, bindChildren } = useChildren(
    BOTTOM_NAVIGATION_BIND_BOTTOM_NAVIGATION_ITEM_KEY
  );
  return {
    length,
    bottomNavigationItems: childProviders,
    bindBottomNavigationItem: bindChildren
  };
}
var __defProp$j = Object.defineProperty;
var __getOwnPropSymbols$j = Object.getOwnPropertySymbols;
var __hasOwnProp$j = Object.prototype.hasOwnProperty;
var __propIsEnum$j = Object.prototype.propertyIsEnumerable;
var __defNormalProp$j = (obj, key3, value) => key3 in obj ? __defProp$j(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$j = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$j.call(b, prop))
      __defNormalProp$j(a, prop, b[prop]);
  if (__getOwnPropSymbols$j)
    for (var prop of __getOwnPropSymbols$j(b)) {
      if (__propIsEnum$j.call(b, prop))
        __defNormalProp$j(a, prop, b[prop]);
    }
  return a;
};
const { name: name$12, n: n$19, classes: classes$V } = createNamespace("bottom-navigation");
const { n: nItem } = createNamespace("bottom-navigation-item");
const RIGHT_HALF_SPACE_CLASS = nItem("--right-half-space");
const LEFT_HALF_SPACE_CLASS = nItem("--left-half-space");
const RIGHT_SPACE_CLASS = nItem("--right-space");
const defaultFabProps = {
  type: "primary"
};
function __render__$17(_ctx, _cache) {
  const _component_var_button = vue.resolveComponent("var-button");
  return vue.openBlock(), vue.createElementBlock(
    vue.Fragment,
    null,
    [
      vue.createElementVNode(
        "div",
        vue.mergeProps({
          ref: "bottomNavigationDom",
          class: _ctx.classes(
            _ctx.n(),
            _ctx.n("$--box"),
            [_ctx.fixed, _ctx.n("--fixed")],
            [_ctx.border, _ctx.n("--border")],
            [_ctx.safeArea, _ctx.n("--safe-area")],
            [_ctx.variant, _ctx.n("--variant")]
          ),
          style: `z-index:${_ctx.zIndex}`
        }, _ctx.$attrs),
        [
          vue.renderSlot(_ctx.$slots, "default"),
          _ctx.$slots.fab ? (vue.openBlock(), vue.createBlock(_component_var_button, vue.mergeProps({
            key: 0,
            class: _ctx.classes(_ctx.n("fab"), [_ctx.length % 2, _ctx.n("--fab-right"), _ctx.n("--fab-center")]),
            "var-bottom-navigation__fab": ""
          }, _ctx.fabProps, { onClick: _ctx.handleFabClick }), {
            default: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "fab")
            ]),
            _: 3
            /* FORWARDED */
          }, 16, ["class", "onClick"])) : vue.createCommentVNode("v-if", true)
        ],
        16
        /* FULL_PROPS */
      ),
      _ctx.fixed && _ctx.placeholder ? (vue.openBlock(), vue.createElementBlock(
        "div",
        {
          key: 0,
          class: vue.normalizeClass(_ctx.n("placeholder")),
          style: vue.normalizeStyle({ height: _ctx.placeholderHeight })
        },
        null,
        6
        /* CLASS, STYLE */
      )) : vue.createCommentVNode("v-if", true)
    ],
    64
    /* STABLE_FRAGMENT */
  );
}
const __sfc__$1a = vue.defineComponent({
  name: name$12,
  components: { VarButton: stdin_default$5t },
  props: props$11,
  setup(props2, { slots }) {
    const bottomNavigationDom = vue.ref(null);
    const active = vue.computed(() => props2.active);
    const activeColor = vue.computed(() => props2.activeColor);
    const inactiveColor = vue.computed(() => props2.inactiveColor);
    const variant = vue.computed(() => props2.variant);
    const placeholderHeight = vue.ref();
    const fabProps = vue.ref({});
    const { length, bottomNavigationItems, bindBottomNavigationItem } = useBottomNavigationItems();
    const bottomNavigationProvider = {
      active,
      activeColor,
      inactiveColor,
      variant,
      onToggle
    };
    bindBottomNavigationItem(bottomNavigationProvider);
    vue.watch(() => length.value, matchBoundary);
    vue.watch(
      () => props2.fabProps,
      (newValue) => {
        fabProps.value = __spreadValues$j(__spreadValues$j({}, defaultFabProps), newValue);
      },
      { immediate: true, deep: true }
    );
    onWindowResize(resizePlaceholder);
    onSmartMounted(() => {
      resizePlaceholder();
      if (!slots.fab) {
        return;
      }
      addMarginClass(length.value);
    });
    vue.onUpdated(() => {
      removeMarginClass();
      if (!slots.fab) {
        return;
      }
      addMarginClass(length.value);
    });
    function matchBoundary() {
      if (length.value === 0 || matchName() || matchIndex()) {
        return;
      }
      handleActiveIndex();
    }
    function matchName() {
      return bottomNavigationItems.find(({ name: name2 }) => active.value === name2.value);
    }
    function matchIndex() {
      return bottomNavigationItems.find(({ index }) => active.value === index.value);
    }
    function handleActiveIndex() {
      if (!isNumber(active.value)) {
        return;
      }
      if (active.value < 0) {
        call(props2["onUpdate:active"], 0);
      } else if (active.value > length.value - 1) {
        call(props2["onUpdate:active"], length.value - 1);
      }
    }
    function onToggle(changedValue) {
      if (active.value === changedValue) {
        return;
      }
      props2.onBeforeChange ? handleBeforeChange(changedValue) : handleChange(changedValue);
    }
    function handleBeforeChange(changedValue) {
      const results = normalizeToArray(call(props2.onBeforeChange, changedValue));
      Promise.all(results).then((results2) => {
        if (results2.every(Boolean)) {
          handleChange(changedValue);
        }
      });
    }
    function handleChange(changedValue) {
      call(props2["onUpdate:active"], changedValue);
      call(props2.onChange, changedValue);
    }
    function removeMarginClass() {
      const bottomNavigationItems2 = getBottomNavigationItems();
      bottomNavigationItems2.forEach((dom) => {
        dom.classList.remove(RIGHT_HALF_SPACE_CLASS, LEFT_HALF_SPACE_CLASS, RIGHT_SPACE_CLASS);
      });
    }
    function addMarginClass(length2) {
      const bottomNavigationItems2 = getBottomNavigationItems();
      const itemsNum = bottomNavigationItems2.length;
      const isEven = length2 % 2 === 0;
      bottomNavigationItems2.forEach((bottomNavigationItem, i) => {
        handleMarginClass(isEven, bottomNavigationItem, i, itemsNum);
      });
    }
    function handleMarginClass(isEven, dom, i, length2) {
      const isLast = i === length2 - 1;
      if (!isEven && isLast) {
        dom.classList.add(RIGHT_SPACE_CLASS);
        return;
      }
      const isFabLeft = i === length2 / 2 - 1;
      const isFabRight = i === length2 / 2;
      if (isFabLeft) {
        dom.classList.add(RIGHT_HALF_SPACE_CLASS);
      } else if (isFabRight) {
        dom.classList.add(LEFT_HALF_SPACE_CLASS);
      }
    }
    function getBottomNavigationItems() {
      return Array.from(bottomNavigationDom.value.querySelectorAll(`.${nItem()}`));
    }
    function handleFabClick() {
      call(props2.onFabClick);
    }
    function resizePlaceholder() {
      if (!props2.fixed || !props2.placeholder) {
        return;
      }
      const { height } = getRect(bottomNavigationDom.value);
      placeholderHeight.value = toSizeUnit(height);
    }
    return {
      length,
      bottomNavigationDom,
      fabProps,
      placeholderHeight,
      n: n$19,
      classes: classes$V,
      handleFabClick
    };
  }
});
__sfc__$1a.render = __render__$17;
var stdin_default$5o = __sfc__$1a;
withInstall(stdin_default$5o);
withPropsDefaultsSetter(stdin_default$5o, props$11);
const _BottomNavigationComponent = stdin_default$5o;
var stdin_default$5n = stdin_default$5o;
const props$10 = {
  name: String,
  label: String,
  icon: pickProps(props$1j, "name"),
  namespace: pickProps(props$1j, "namespace"),
  badge: {
    type: [Boolean, Object],
    default: false
  },
  onClick: defineListenerProp()
};
function useBottomNavigation() {
  const { parentProvider, index, bindParent } = useParent(
    BOTTOM_NAVIGATION_BIND_BOTTOM_NAVIGATION_ITEM_KEY
  );
  assert(!!bindParent, "BottomNavigationItem", "<var-bottom-navigation-item/> must in <var-bottom-navigation/>");
  return {
    index,
    bottomNavigation: parentProvider,
    bindBottomNavigation: bindParent
  };
}
const { name: name$11, n: n$18, classes: classes$U } = createNamespace("bottom-navigation-item");
const defaultBadgeProps = {
  type: "danger",
  dot: true
};
function __render__$16(_ctx, _cache) {
  const _component_var_icon = vue.resolveComponent("var-icon");
  const _component_var_badge = vue.resolveComponent("var-badge");
  const _directive_ripple = vue.resolveDirective("ripple");
  return vue.withDirectives((vue.openBlock(), vue.createElementBlock(
    "button",
    {
      class: vue.normalizeClass(_ctx.classes(_ctx.n(), _ctx.n("$--box"), [_ctx.variant, _ctx.n("--variant-padding")], [_ctx.isActive && !_ctx.variant, _ctx.n("--active")])),
      style: vue.normalizeStyle({
        color: _ctx.isActive ? _ctx.activeColor : _ctx.inactiveColor
      }),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    },
    [
      vue.createElementVNode(
        "div",
        {
          class: vue.normalizeClass(
            _ctx.classes(
              _ctx.n("icon-container"),
              [_ctx.variant, _ctx.n("--variant-icon-container")],
              [_ctx.isActive && _ctx.variant, _ctx.n("--variant-active")]
            )
          )
        },
        [
          _ctx.badge ? (vue.openBlock(), vue.createBlock(_component_var_badge, vue.mergeProps({ key: 0 }, _ctx.badgeProps, {
            class: _ctx.n("badge"),
            "var-bottom-navigation-item-cover": ""
          }), {
            default: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "icon", { active: _ctx.isActive }, () => [
                _ctx.icon ? (vue.openBlock(), vue.createBlock(_component_var_icon, {
                  key: 0,
                  name: _ctx.icon,
                  namespace: _ctx.namespace,
                  class: vue.normalizeClass(_ctx.n("icon")),
                  "var-bottom-navigation-item-cover": ""
                }, null, 8, ["name", "namespace", "class"])) : vue.createCommentVNode("v-if", true)
              ])
            ]),
            _: 3
            /* FORWARDED */
          }, 16, ["class"])) : vue.renderSlot(_ctx.$slots, "icon", {
            key: 1,
            active: _ctx.isActive
          }, () => [
            _ctx.icon ? (vue.openBlock(), vue.createBlock(_component_var_icon, {
              key: 0,
              name: _ctx.icon,
              namespace: _ctx.namespace,
              class: vue.normalizeClass(_ctx.n("icon")),
              "var-bottom-navigation-item-cover": ""
            }, null, 8, ["name", "namespace", "class"])) : vue.createCommentVNode("v-if", true)
          ])
        ],
        2
        /* CLASS */
      ),
      vue.createElementVNode(
        "span",
        {
          class: vue.normalizeClass(_ctx.n("label"))
        },
        [
          vue.renderSlot(_ctx.$slots, "default", {}, () => [
            vue.createTextVNode(
              vue.toDisplayString(_ctx.label),
              1
              /* TEXT */
            )
          ])
        ],
        2
        /* CLASS */
      )
    ],
    6
    /* CLASS, STYLE */
  )), [
    [_directive_ripple]
  ]);
}
const __sfc__$19 = vue.defineComponent({
  name: name$11,
  components: {
    VarBadge: stdin_default$5p,
    VarIcon: stdin_default$5_
  },
  directives: { Ripple: stdin_default$63 },
  props: props$10,
  setup(props2) {
    const name2 = vue.computed(() => props2.name);
    const isActive = vue.computed(() => [name2.value, index.value].includes(active.value));
    const badgeProps = vue.computed(() => props2.badge === true ? defaultBadgeProps : props2.badge);
    const { index, bottomNavigation, bindBottomNavigation } = useBottomNavigation();
    const { active, activeColor, inactiveColor, variant } = bottomNavigation;
    const bottomNavigationItemProvider = {
      name: name2,
      index
    };
    bindBottomNavigation(bottomNavigationItemProvider);
    function handleClick() {
      var _a;
      const active2 = (_a = name2.value) != null ? _a : index.value;
      call(props2.onClick, active2);
      call(bottomNavigation.onToggle, active2);
    }
    return {
      activeColor,
      inactiveColor,
      badgeProps,
      isActive,
      variant,
      n: n$18,
      classes: classes$U,
      handleClick
    };
  }
});
__sfc__$19.render = __render__$16;
var stdin_default$5m = __sfc__$19;
withInstall(stdin_default$5m);
withPropsDefaultsSetter(stdin_default$5m, props$10);
const _BottomNavigationItemComponent = stdin_default$5m;
var stdin_default$5l = stdin_default$5m;
const props$$ = {
  separator: String,
  onClick: defineListenerProp()
};
const BREADCRUMBS_BIND_BREADCRUMB_ITEM_KEY = Symbol("BREADCRUMBS_BIND_BREADCRUMB_KEY");
function useBreadcrumbsList() {
  const { childProviders, bindChildren, length } = useChildren(
    BREADCRUMBS_BIND_BREADCRUMB_ITEM_KEY
  );
  return {
    length,
    breadcrumbList: childProviders,
    bindBreadcrumbList: bindChildren
  };
}
function useBreadcrumb() {
  const { parentProvider, bindParent, index } = useParent(
    BREADCRUMBS_BIND_BREADCRUMB_ITEM_KEY
  );
  assert(!!bindParent, "Breadcrumb", "<var-breadcrumb/> must in <var-breadcrumbs/>");
  return {
    index,
    breadcrumb: parentProvider,
    bindBreadcrumb: bindParent
  };
}
const { name: name$10, n: n$17, classes: classes$T } = createNamespace("breadcrumb");
function __render__$15(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.n())
    },
    [
      vue.createElementVNode(
        "div",
        {
          class: vue.normalizeClass(_ctx.classes(_ctx.n("content"), [!_ctx.isLast, _ctx.n("--active")])),
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
        },
        [
          vue.renderSlot(_ctx.$slots, "default")
        ],
        2
        /* CLASS */
      ),
      !_ctx.isLast ? vue.renderSlot(_ctx.$slots, "separator", { key: 0 }, () => {
        var _a;
        return [
          vue.createElementVNode(
            "div",
            {
              class: vue.normalizeClass(_ctx.n("separator")),
              "aria-hidden": "true"
            },
            vue.toDisplayString((_a = _ctx.separator) != null ? _a : _ctx.parentSeparator),
            3
            /* TEXT, CLASS */
          )
        ];
      }) : vue.createCommentVNode("v-if", true)
    ],
    2
    /* CLASS */
  );
}
const __sfc__$18 = vue.defineComponent({
  name: name$10,
  props: props$$,
  setup(props2) {
    const { index, breadcrumb, bindBreadcrumb } = useBreadcrumb();
    const isLast = vue.computed(() => index.value === breadcrumb.length.value - 1);
    const parentSeparator = vue.computed(() => breadcrumb.separator.value);
    bindBreadcrumb(null);
    function handleClick(e) {
      if (isLast.value) {
        return;
      }
      call(props2.onClick, e);
    }
    return {
      n: n$17,
      classes: classes$T,
      isLast,
      parentSeparator,
      handleClick
    };
  }
});
__sfc__$18.render = __render__$15;
var stdin_default$5k = __sfc__$18;
withInstall(stdin_default$5k);
withPropsDefaultsSetter(stdin_default$5k, props$$);
const _BreadcrumbComponent = stdin_default$5k;
var stdin_default$5j = stdin_default$5k;
const props$_ = {
  separator: {
    type: String,
    default: "/"
  }
};
const { name: name$$, n: n$16 } = createNamespace("breadcrumbs");
function __render__$14(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.n()),
      role: "navigation",
      "aria-label": "Breadcrumbs"
    },
    [
      vue.renderSlot(_ctx.$slots, "default")
    ],
    2
    /* CLASS */
  );
}
const __sfc__$17 = vue.defineComponent({
  name: name$$,
  props: props$_,
  setup(props2) {
    const separator = vue.computed(() => props2.separator);
    const { bindBreadcrumbList, length } = useBreadcrumbsList();
    const breadcrumbsProvider = {
      length,
      separator
    };
    bindBreadcrumbList(breadcrumbsProvider);
    return { n: n$16 };
  }
});
__sfc__$17.render = __render__$14;
var stdin_default$5i = __sfc__$17;
withInstall(stdin_default$5i);
withPropsDefaultsSetter(stdin_default$5i, props$_);
const _BreadcrumbsComponent = stdin_default$5i;
var stdin_default$5h = stdin_default$5i;
const props$Z = {
  type: {
    type: String,
    default: "default"
  },
  size: {
    type: String,
    default: "normal"
  },
  color: String,
  textColor: String,
  mode: {
    type: String,
    default: "normal"
  },
  elevation: {
    type: [Boolean, Number, String],
    default: true
  },
  vertical: Boolean
};
const { name: name$_, n: n$15, classes: classes$S } = createNamespace("button-group");
function __render__$13(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(
        _ctx.classes(
          _ctx.n(),
          _ctx.n("$--box"),
          [_ctx.mode, `${_ctx.n(`--mode-${_ctx.mode}`)}`],
          [_ctx.vertical, _ctx.n("--vertical"), _ctx.n("--horizontal")],
          [_ctx.mode === "normal", _ctx.formatElevation(_ctx.elevation, 2)]
        )
      )
    },
    [
      vue.renderSlot(_ctx.$slots, "default")
    ],
    2
    /* CLASS */
  );
}
const __sfc__$16 = vue.defineComponent({
  name: name$_,
  props: props$Z,
  setup(props2) {
    const { bindButtons } = useButtons();
    const buttonGroupProvider = {
      elevation: vue.computed(() => props2.elevation),
      type: vue.computed(() => props2.type),
      size: vue.computed(() => props2.size),
      color: vue.computed(() => props2.color),
      textColor: vue.computed(() => props2.textColor),
      mode: vue.computed(() => props2.mode)
    };
    bindButtons(buttonGroupProvider);
    return {
      n: n$15,
      classes: classes$S,
      formatElevation
    };
  }
});
__sfc__$16.render = __render__$13;
var stdin_default$5g = __sfc__$16;
withInstall(stdin_default$5g);
withPropsDefaultsSetter(stdin_default$5g, props$Z);
const _ButtonGroupComponent = stdin_default$5g;
var stdin_default$5f = stdin_default$5g;
const props$Y = {
  src: String,
  fit: {
    type: String,
    default: "cover"
  },
  imageHeight: [String, Number],
  imageWidth: [String, Number],
  variant: {
    type: String,
    default: "standard"
  },
  layout: {
    type: String,
    default: "column"
  },
  floating: Boolean,
  floatingDuration: {
    type: Number,
    default: 250
  },
  alt: String,
  title: String,
  subtitle: String,
  description: String,
  elevation: {
    type: [Boolean, Number, String],
    default: true
  },
  ripple: Boolean,
  onClick: defineListenerProp(),
  "onUpdate:floating": defineListenerProp(),
  /**
   * @deprecated use outlined variant instead
   */
  outline: Boolean
};
var __async$d = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const { name: name$Z, n: n$14, classes: classes$R } = createNamespace("card");
const RIPPLE_DELAY = 500;
const _hoisted_1$q = ["src", "alt"];
function __render__$12(_ctx, _cache) {
  const _component_var_icon = vue.resolveComponent("var-icon");
  const _component_var_button = vue.resolveComponent("var-button");
  const _directive_ripple = vue.resolveDirective("ripple");
  return vue.withDirectives((vue.openBlock(), vue.createElementBlock(
    "div",
    {
      ref: "card",
      class: vue.normalizeClass(
        _ctx.classes(
          _ctx.n(),
          [_ctx.isRow, _ctx.n("--layout-row")],
          [_ctx.variant === "outlined" || _ctx.outline, _ctx.n("--outline")],
          [_ctx.variant === "filled", _ctx.n("--filled")],
          [_ctx.variant === "standard" || _ctx.outline, _ctx.formatElevation(_ctx.elevation, 1)]
        )
      ),
      style: vue.normalizeStyle({
        zIndex: _ctx.floated ? _ctx.zIndex : void 0
      }),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    },
    [
      vue.createElementVNode(
        "div",
        {
          ref: "cardFloater",
          class: vue.normalizeClass(_ctx.n("floater")),
          style: vue.normalizeStyle({
            width: _ctx.floaterWidth,
            height: _ctx.floaterHeight,
            top: _ctx.floaterTop,
            left: _ctx.floaterLeft,
            overflow: _ctx.floaterOverflow,
            position: _ctx.floaterPosition,
            zIndex: _ctx.floated ? _ctx.zIndex : void 0,
            background: _ctx.outline && !_ctx.floated ? "transparent" : void 0,
            transition: _ctx.floated ? `background-color ${_ctx.floatingDuration}ms, color ${_ctx.floatingDuration}ms, width ${_ctx.floatingDuration}ms, height ${_ctx.floatingDuration}ms, top ${_ctx.floatingDuration}ms, left ${_ctx.floatingDuration}ms` : void 0
          })
        },
        [
          vue.renderSlot(_ctx.$slots, "image", {}, () => [
            _ctx.src ? (vue.openBlock(), vue.createElementBlock("img", {
              key: 0,
              class: vue.normalizeClass(_ctx.n("image")),
              style: vue.normalizeStyle({
                objectFit: _ctx.fit,
                height: _ctx.toSizeUnit(_ctx.imageHeight),
                width: _ctx.toSizeUnit(_ctx.imageWidth)
              }),
              src: _ctx.src,
              alt: _ctx.alt
            }, null, 14, _hoisted_1$q)) : vue.createCommentVNode("v-if", true)
          ]),
          vue.createElementVNode(
            "div",
            {
              class: vue.normalizeClass(_ctx.n("container"))
            },
            [
              vue.renderSlot(_ctx.$slots, "title", {
                slotClass: _ctx.n("title")
              }, () => [
                _ctx.title ? (vue.openBlock(), vue.createElementBlock(
                  "div",
                  {
                    key: 0,
                    class: vue.normalizeClass(_ctx.n("title"))
                  },
                  vue.toDisplayString(_ctx.title),
                  3
                  /* TEXT, CLASS */
                )) : vue.createCommentVNode("v-if", true)
              ]),
              vue.renderSlot(_ctx.$slots, "subtitle", {
                slotClass: _ctx.n("subtitle")
              }, () => [
                _ctx.subtitle ? (vue.openBlock(), vue.createElementBlock(
                  "div",
                  {
                    key: 0,
                    class: vue.normalizeClass(_ctx.n("subtitle"))
                  },
                  vue.toDisplayString(_ctx.subtitle),
                  3
                  /* TEXT, CLASS */
                )) : vue.createCommentVNode("v-if", true)
              ]),
              _ctx.$slots.default ? (vue.openBlock(), vue.createElementBlock(
                "div",
                {
                  key: 0,
                  class: vue.normalizeClass(_ctx.n("content"))
                },
                [
                  vue.renderSlot(_ctx.$slots, "default")
                ],
                2
                /* CLASS */
              )) : vue.createCommentVNode("v-if", true),
              vue.renderSlot(_ctx.$slots, "description", {
                slotClass: _ctx.n("description")
              }, () => [
                _ctx.description ? (vue.openBlock(), vue.createElementBlock(
                  "div",
                  {
                    key: 0,
                    class: vue.normalizeClass(_ctx.n("description"))
                  },
                  vue.toDisplayString(_ctx.description),
                  3
                  /* TEXT, CLASS */
                )) : vue.createCommentVNode("v-if", true)
              ]),
              _ctx.$slots.extra ? (vue.openBlock(), vue.createElementBlock(
                "div",
                {
                  key: 1,
                  class: vue.normalizeClass(_ctx.n("footer"))
                },
                [
                  vue.renderSlot(_ctx.$slots, "extra")
                ],
                2
                /* CLASS */
              )) : vue.createCommentVNode("v-if", true),
              _ctx.$slots["floating-content"] && !_ctx.isRow ? (vue.openBlock(), vue.createElementBlock(
                "div",
                {
                  key: 2,
                  class: vue.normalizeClass(_ctx.n("floating-content")),
                  style: vue.normalizeStyle({
                    height: _ctx.contentHeight,
                    opacity: _ctx.opacity,
                    transition: `opacity ${_ctx.floatingDuration * 2}ms`
                  })
                },
                [
                  vue.renderSlot(_ctx.$slots, "floating-content")
                ],
                6
                /* CLASS, STYLE */
              )) : vue.createCommentVNode("v-if", true)
            ],
            2
            /* CLASS */
          ),
          _ctx.showFloatingButtons ? (vue.openBlock(), vue.createElementBlock(
            "div",
            {
              key: 0,
              class: vue.normalizeClass(_ctx.classes(_ctx.n("floating-buttons"), _ctx.n("$--box"))),
              style: vue.normalizeStyle({
                zIndex: _ctx.zIndex,
                opacity: _ctx.opacity,
                transition: `opacity ${_ctx.floatingDuration * 2}ms`
              })
            },
            [
              vue.renderSlot(_ctx.$slots, "close-button", {}, () => [
                vue.createVNode(_component_var_button, {
                  "var-card-cover": "",
                  class: vue.normalizeClass(_ctx.classes(_ctx.n("close-button"), _ctx.n("$-elevation--6"))),
                  onClick: vue.withModifiers(_ctx.close, ["stop"])
                }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(_component_var_icon, {
                      "var-card-cover": "",
                      name: "window-close",
                      class: vue.normalizeClass(_ctx.n("close-button-icon"))
                    }, null, 8, ["class"])
                  ]),
                  _: 1
                  /* STABLE */
                }, 8, ["class", "onClick"])
              ])
            ],
            6
            /* CLASS, STYLE */
          )) : vue.createCommentVNode("v-if", true)
        ],
        6
        /* CLASS, STYLE */
      ),
      vue.createElementVNode(
        "div",
        {
          class: vue.normalizeClass(_ctx.n("holder")),
          style: vue.normalizeStyle({
            width: _ctx.holderWidth,
            height: _ctx.holderHeight
          })
        },
        null,
        6
        /* CLASS, STYLE */
      )
    ],
    6
    /* CLASS, STYLE */
  )), [
    [_directive_ripple, { disabled: !_ctx.ripple || _ctx.floater }]
  ]);
}
const __sfc__$15 = vue.defineComponent({
  name: name$Z,
  directives: { Ripple: stdin_default$63 },
  components: {
    VarIcon: stdin_default$5_,
    VarButton: stdin_default$5t
  },
  props: props$Y,
  setup(props2) {
    const card = vue.ref(null);
    const cardFloater = vue.ref(null);
    const holderWidth = vue.ref("auto");
    const holderHeight = vue.ref("auto");
    const floaterWidth = vue.ref("100%");
    const floaterHeight = vue.ref("100%");
    const floaterTop = vue.ref("auto");
    const floaterLeft = vue.ref("auto");
    const floaterPosition = vue.ref(void 0);
    const floaterOverflow = vue.ref("hidden");
    const contentHeight = vue.ref("0px");
    const opacity = vue.ref("0");
    const isRow = vue.computed(() => props2.layout === "row");
    const showFloatingButtons = vue.ref(false);
    const floated = vue.ref(false);
    const { zIndex } = useZIndex(() => props2.floating, 1);
    let dropdownFloaterTop = "auto";
    let dropdownFloaterLeft = "auto";
    let dropper = null;
    const floater = vue.ref(null);
    useLock(
      () => props2.floating,
      () => !isRow.value
    );
    vue.watch(
      () => props2.floating,
      (value) => {
        if (isRow.value) {
          return;
        }
        vue.nextTick(() => {
          value ? floating() : dropdown();
        });
      },
      { immediate: true }
    );
    function floating() {
      clearTimeout(floater.value);
      clearTimeout(dropper);
      floater.value = null;
      floater.value = setTimeout(
        () => __async$d(this, null, function* () {
          const { width, height, left: left2, top: top2 } = getRect(card.value);
          holderWidth.value = toSizeUnit(width);
          holderHeight.value = toSizeUnit(height);
          floaterWidth.value = holderWidth.value;
          floaterHeight.value = holderHeight.value;
          floaterTop.value = toSizeUnit(top2);
          floaterLeft.value = toSizeUnit(left2);
          floaterPosition.value = "fixed";
          dropdownFloaterTop = floaterTop.value;
          dropdownFloaterLeft = floaterLeft.value;
          showFloatingButtons.value = true;
          yield doubleRaf();
          floaterTop.value = "0";
          floaterLeft.value = "0";
          floaterWidth.value = "100vw";
          floaterHeight.value = "100vh";
          contentHeight.value = "auto";
          opacity.value = "1";
          floaterOverflow.value = "auto";
          floated.value = true;
        }),
        props2.ripple ? RIPPLE_DELAY : 0
      );
    }
    function dropdown() {
      clearTimeout(dropper);
      clearTimeout(floater.value);
      floater.value = null;
      floaterWidth.value = holderWidth.value;
      floaterHeight.value = holderHeight.value;
      floaterTop.value = dropdownFloaterTop;
      floaterLeft.value = dropdownFloaterLeft;
      contentHeight.value = "0px";
      opacity.value = "0";
      showFloatingButtons.value = false;
      dropper = setTimeout(() => {
        holderWidth.value = "auto";
        holderHeight.value = "auto";
        floaterWidth.value = "100%";
        floaterHeight.value = "100%";
        floaterTop.value = "auto";
        floaterLeft.value = "auto";
        dropdownFloaterTop = "auto";
        dropdownFloaterLeft = "auto";
        floaterOverflow.value = "hidden";
        floaterPosition.value = void 0;
        floated.value = false;
      }, props2.floatingDuration);
    }
    function close() {
      call(props2["onUpdate:floating"], false);
    }
    function handleClick(e) {
      call(props2.onClick, e);
    }
    return {
      card,
      cardFloater,
      holderWidth,
      holderHeight,
      floater,
      floaterWidth,
      floaterHeight,
      floaterTop,
      floaterLeft,
      floaterPosition,
      floaterOverflow,
      contentHeight,
      opacity,
      zIndex,
      isRow,
      showFloatingButtons,
      floated,
      n: n$14,
      classes: classes$R,
      toSizeUnit,
      close,
      formatElevation,
      handleClick
    };
  }
});
__sfc__$15.render = __render__$12;
var stdin_default$5e = __sfc__$15;
withInstall(stdin_default$5e);
withPropsDefaultsSetter(stdin_default$5e, props$Y);
const _CardComponent = stdin_default$5e;
var stdin_default$5d = stdin_default$5e;
const props$X = {
  title: String,
  icon: pickProps(props$1j, "name"),
  namespace: pickProps(props$1j, "namespace"),
  description: String,
  border: Boolean,
  borderOffset: [Number, String],
  iconClass: String,
  titleClass: String,
  descriptionClass: String,
  extraClass: String,
  ripple: Boolean,
  onClick: defineListenerProp()
};
const { name: name$Y, n: n$13, classes: classes$Q } = createNamespace("cell");
function __render__$11(_ctx, _cache) {
  const _component_var_icon = vue.resolveComponent("var-icon");
  const _directive_ripple = vue.resolveDirective("ripple");
  return vue.withDirectives((vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.classes(_ctx.n(), [_ctx.border, _ctx.n("--border")], [_ctx.onClick, _ctx.n("--cursor")])),
      style: vue.normalizeStyle(_ctx.borderOffsetStyles),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    },
    [
      vue.renderSlot(_ctx.$slots, "icon", {}, () => [
        _ctx.icon ? (vue.openBlock(), vue.createElementBlock(
          "div",
          {
            key: 0,
            class: vue.normalizeClass(_ctx.classes(_ctx.n("icon"), _ctx.iconClass))
          },
          [
            vue.createVNode(_component_var_icon, {
              name: _ctx.icon,
              namespace: _ctx.namespace
            }, null, 8, ["name", "namespace"])
          ],
          2
          /* CLASS */
        )) : vue.createCommentVNode("v-if", true)
      ]),
      vue.createElementVNode(
        "div",
        {
          class: vue.normalizeClass(_ctx.n("content"))
        },
        [
          vue.renderSlot(_ctx.$slots, "default", {}, () => [
            _ctx.title ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 0,
                class: vue.normalizeClass(_ctx.classes(_ctx.n("title"), _ctx.titleClass))
              },
              vue.toDisplayString(_ctx.title),
              3
              /* TEXT, CLASS */
            )) : vue.createCommentVNode("v-if", true)
          ]),
          vue.renderSlot(_ctx.$slots, "description", {}, () => [
            _ctx.description ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 0,
                class: vue.normalizeClass(_ctx.classes(_ctx.n("description"), _ctx.descriptionClass))
              },
              vue.toDisplayString(_ctx.description),
              3
              /* TEXT, CLASS */
            )) : vue.createCommentVNode("v-if", true)
          ])
        ],
        2
        /* CLASS */
      ),
      _ctx.$slots.extra ? (vue.openBlock(), vue.createElementBlock(
        "div",
        {
          key: 0,
          class: vue.normalizeClass(_ctx.classes(_ctx.n("extra"), _ctx.extraClass))
        },
        [
          vue.renderSlot(_ctx.$slots, "extra")
        ],
        2
        /* CLASS */
      )) : vue.createCommentVNode("v-if", true)
    ],
    6
    /* CLASS, STYLE */
  )), [
    [_directive_ripple, { disabled: !_ctx.ripple }]
  ]);
}
const __sfc__$14 = vue.defineComponent({
  name: name$Y,
  components: { VarIcon: stdin_default$5_ },
  directives: { Ripple: stdin_default$63 },
  props: props$X,
  setup(props2) {
    const borderOffsetStyles = vue.computed(() => {
      if (props2.borderOffset == null) {
        return {};
      }
      return {
        "--cell-border-left": toSizeUnit(props2.borderOffset),
        "--cell-border-right": toSizeUnit(props2.borderOffset)
      };
    });
    function handleClick(e) {
      call(props2.onClick, e);
    }
    return {
      borderOffsetStyles,
      n: n$13,
      classes: classes$Q,
      toSizeUnit,
      handleClick
    };
  }
});
__sfc__$14.render = __render__$11;
var stdin_default$5c = __sfc__$14;
withInstall(stdin_default$5c);
withPropsDefaultsSetter(stdin_default$5c, props$X);
const _CellComponent = stdin_default$5c;
var stdin_default$5b = stdin_default$5c;
const props$W = {
  modelValue: {
    type: Array,
    default: () => []
  },
  max: [String, Number],
  options: {
    type: Array,
    default: () => []
  },
  labelKey: {
    type: String,
    default: "label"
  },
  valueKey: {
    type: String,
    default: "value"
  },
  direction: {
    type: String,
    default: "horizontal"
  },
  validateTrigger: {
    type: Array,
    default: () => ["onChange"]
  },
  rules: [Array, Function, Object],
  onChange: defineListenerProp(),
  "onUpdate:modelValue": defineListenerProp()
};
const { name: name$X, n: n$12, classes: classes$P } = createNamespace("checkbox-group");
function __render__$10(_ctx, _cache) {
  const _component_maybe_v_node = vue.resolveComponent("maybe-v-node");
  const _component_var_checkbox = vue.resolveComponent("var-checkbox");
  const _component_var_form_details = vue.resolveComponent("var-form-details");
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.n("wrap"))
    },
    [
      vue.createElementVNode(
        "div",
        {
          class: vue.normalizeClass(_ctx.classes(_ctx.n(), _ctx.n(`--${_ctx.direction}`)))
        },
        [
          _ctx.options.length ? (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            { key: 0 },
            vue.renderList(_ctx.options, (option) => {
              return vue.openBlock(), vue.createBlock(_component_var_checkbox, {
                key: option[_ctx.valueKey],
                "checked-value": option[_ctx.valueKey],
                disabled: option.disabled
              }, {
                default: vue.withCtx(({ checked }) => [
                  vue.createVNode(_component_maybe_v_node, {
                    is: _ctx.isFunction(option[_ctx.labelKey]) ? option[_ctx.labelKey](option, checked) : option[_ctx.labelKey]
                  }, null, 8, ["is"])
                ]),
                _: 2
                /* DYNAMIC */
              }, 1032, ["checked-value", "disabled"]);
            }),
            128
            /* KEYED_FRAGMENT */
          )) : vue.createCommentVNode("v-if", true),
          vue.renderSlot(_ctx.$slots, "default")
        ],
        2
        /* CLASS */
      ),
      vue.createVNode(_component_var_form_details, { "error-message": _ctx.errorMessage }, null, 8, ["error-message"])
    ],
    2
    /* CLASS */
  );
}
const __sfc__$13 = vue.defineComponent({
  name: name$X,
  components: { VarFormDetails: stdin_default$5R, VarCheckbox: stdin_default$5L, MaybeVNode },
  props: props$W,
  setup(props2) {
    const max2 = vue.computed(() => props2.max);
    const checkedCount = vue.computed(() => props2.modelValue.length);
    const { length, checkboxes, bindCheckboxes } = useCheckboxes();
    const { bindForm } = useForm();
    const {
      errorMessage,
      validateWithTrigger: vt,
      validate: v,
      // expose
      resetValidation
    } = useValidation();
    const checkboxGroupErrorMessage = vue.computed(() => errorMessage.value);
    const checkboxGroupProvider = {
      max: max2,
      checkedCount,
      onChecked,
      onUnchecked,
      validate,
      resetValidation,
      reset,
      errorMessage: checkboxGroupErrorMessage
    };
    vue.watch(() => props2.modelValue, syncCheckboxes, { deep: true });
    vue.watch(() => length.value, syncCheckboxes);
    bindCheckboxes(checkboxGroupProvider);
    call(bindForm, checkboxGroupProvider);
    function validateWithTrigger(trigger) {
      vue.nextTick(() => {
        const { validateTrigger, rules, modelValue } = props2;
        vt(validateTrigger, trigger, rules, modelValue);
      });
    }
    function change(changedModelValue) {
      call(props2["onUpdate:modelValue"], changedModelValue);
      call(props2.onChange, changedModelValue);
      validateWithTrigger("onChange");
    }
    function onChecked(changedValue) {
      const { modelValue } = props2;
      if (!modelValue.includes(changedValue)) {
        change([...modelValue, changedValue]);
      }
    }
    function onUnchecked(changedValue) {
      const { modelValue } = props2;
      if (!modelValue.includes(changedValue)) {
        return;
      }
      change(modelValue.filter((value) => value !== changedValue));
    }
    function syncCheckboxes() {
      checkboxes.forEach(({ sync }) => sync(props2.modelValue));
    }
    function checkAll2() {
      const checkedValues = checkboxes.map(({ checkedValue }) => checkedValue.value);
      const changedModelValue = uniq(checkedValues);
      call(props2["onUpdate:modelValue"], changedModelValue);
      return changedModelValue;
    }
    function inverseAll() {
      const checkedValues = checkboxes.filter(({ checked }) => !checked.value).map(({ checkedValue }) => checkedValue.value);
      const changedModelValue = uniq(checkedValues);
      call(props2["onUpdate:modelValue"], changedModelValue);
      return changedModelValue;
    }
    function reset() {
      call(props2["onUpdate:modelValue"], []);
      resetValidation();
    }
    function validate() {
      return v(props2.rules, props2.modelValue);
    }
    return {
      errorMessage,
      n: n$12,
      classes: classes$P,
      checkAll: checkAll2,
      inverseAll,
      reset,
      validate,
      resetValidation,
      isFunction
    };
  }
});
__sfc__$13.render = __render__$10;
var stdin_default$5a = __sfc__$13;
withInstall(stdin_default$5a);
withPropsDefaultsSetter(stdin_default$5a, props$W);
const _CheckboxGroupComponent = stdin_default$5a;
var stdin_default$59 = stdin_default$5a;
const props$V = {
  type: {
    type: String,
    default: "default"
  },
  size: {
    type: String,
    default: "normal"
  },
  color: String,
  textColor: String,
  iconName: pickProps(props$1j, "name"),
  namespace: pickProps(props$1j, "namespace"),
  plain: Boolean,
  round: {
    type: Boolean,
    default: true
  },
  elevation: {
    type: [Boolean, Number, String],
    default: false
  },
  block: Boolean,
  closeable: Boolean,
  onClose: defineListenerProp()
};
const { name: name$W, n: n$11, classes: classes$O } = createNamespace("chip");
function __render__$$(_ctx, _cache) {
  const _component_var_icon = vue.resolveComponent("var-icon");
  return vue.openBlock(), vue.createBlock(vue.Transition, {
    name: _ctx.n("$-fade")
  }, {
    default: vue.withCtx(() => [
      vue.createElementVNode(
        "span",
        vue.mergeProps({
          class: _ctx.classes(_ctx.n(), _ctx.n("$--box"), _ctx.formatElevation(_ctx.elevation, 1), ..._ctx.contentClass),
          style: _ctx.chipStyle
        }, _ctx.$attrs),
        [
          vue.renderSlot(_ctx.$slots, "left"),
          vue.createElementVNode(
            "span",
            {
              class: vue.normalizeClass(_ctx.n(`text-${_ctx.size}`))
            },
            [
              vue.renderSlot(_ctx.$slots, "default")
            ],
            2
            /* CLASS */
          ),
          vue.renderSlot(_ctx.$slots, "right"),
          _ctx.closeable ? (vue.openBlock(), vue.createElementBlock(
            "span",
            {
              key: 0,
              class: vue.normalizeClass(_ctx.n("--close")),
              onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClose && _ctx.handleClose(...args))
            },
            [
              vue.createVNode(_component_var_icon, {
                name: `${_ctx.iconName ? _ctx.iconName : "close-circle"}`,
                namespace: _ctx.namespace
              }, null, 8, ["name", "namespace"])
            ],
            2
            /* CLASS */
          )) : vue.createCommentVNode("v-if", true)
        ],
        16
        /* FULL_PROPS */
      )
    ]),
    _: 3
    /* FORWARDED */
  }, 8, ["name"]);
}
const __sfc__$12 = vue.defineComponent({
  name: name$W,
  components: {
    VarIcon: stdin_default$5_
  },
  inheritAttrs: false,
  props: props$V,
  setup(props2) {
    const chipStyle = vue.computed(() => {
      const { plain, textColor, color } = props2;
      if (plain) {
        return {
          color: textColor || color,
          borderColor: color
        };
      }
      return {
        color: textColor,
        background: color
      };
    });
    const contentClass = vue.computed(() => {
      const { size, block, type, plain, round: round2 } = props2;
      const blockClass = block ? n$11("$--flex") : n$11("$--inline-flex");
      const plainTypeClass = plain ? `${n$11("plain")} ${n$11(`plain-${type}`)}` : n$11(`--${type}`);
      const roundClass = round2 ? n$11("--round") : null;
      return [n$11(`--${size}`), blockClass, plainTypeClass, roundClass];
    });
    function handleClose(e) {
      call(props2.onClose, e);
    }
    return {
      chipStyle,
      contentClass,
      n: n$11,
      classes: classes$O,
      formatElevation,
      handleClose
    };
  }
});
__sfc__$12.render = __render__$$;
var stdin_default$58 = __sfc__$12;
withInstall(stdin_default$58);
withPropsDefaultsSetter(stdin_default$58, props$V);
const _ChipComponent = stdin_default$58;
var stdin_default$57 = stdin_default$58;
const HIGHLIGHTER_PROVIDER_KEY = Symbol("HIGHLIGHTER_PROVIDER_KEY");
function provideHighlighterProvider(highlighterProvider) {
  vue.provide(HIGHLIGHTER_PROVIDER_KEY, highlighterProvider);
}
function injectHighlighterProvider() {
  if (!keyInProvides(HIGHLIGHTER_PROVIDER_KEY)) {
    return { highlighter: null, theme: null };
  }
  return vue.inject(HIGHLIGHTER_PROVIDER_KEY);
}
const props$U = {
  code: {
    type: String,
    default: ""
  },
  language: String,
  theme: String,
  wordWrap: Boolean,
  trim: {
    type: Boolean,
    default: true
  }
};
var __async$c = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const { name: name$V, n: n$10, classes: classes$N } = createNamespace("code");
const _hoisted_1$p = ["innerHTML"];
function __render__$_(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock("div", {
    class: vue.normalizeClass(_ctx.classes(_ctx.n(), [_ctx.wordWrap, _ctx.n("--word-wrap")])),
    innerHTML: _ctx.highlightedCode
  }, null, 10, _hoisted_1$p);
}
const __sfc__$11 = vue.defineComponent({
  name: name$V,
  props: props$U,
  setup(props2) {
    const { highlighter, theme } = injectHighlighterProvider();
    const highlightedCode = vue.ref("");
    const normalizedTheme = vue.computed(() => {
      var _a;
      return (_a = props2.theme) != null ? _a : theme == null ? void 0 : theme.value;
    });
    if (highlighter) {
      vue.watch(
        () => [highlighter.value, props2.code, props2.language, normalizedTheme.value, props2.trim],
        (_0) => __async$c(this, [_0], function* ([highlighter2, code, lang = "", theme2 = "", trim]) {
          if (!highlighter2) {
            return;
          }
          highlightedCode.value = yield highlighter2.codeToHtml(trim ? code.trim() : code, { lang, theme: theme2 });
        }),
        { immediate: true }
      );
    }
    return {
      n: n$10,
      classes: classes$N,
      highlightedCode
    };
  }
});
__sfc__$11.render = __render__$_;
var stdin_default$56 = __sfc__$11;
withInstall(stdin_default$56);
withPropsDefaultsSetter(stdin_default$56, props$U);
const _CodeComponent = stdin_default$56;
var stdin_default$55 = stdin_default$56;
const props$T = {
  span: {
    type: [String, Number],
    default: 24
  },
  offset: {
    type: [String, Number],
    default: 0
  },
  direction: {
    type: String,
    default: "row"
  },
  justify: String,
  align: String,
  xs: [Object, Number, String],
  sm: [Object, Number, String],
  md: [Object, Number, String],
  lg: [Object, Number, String],
  xl: [Object, Number, String],
  onClick: defineListenerProp()
};
const ROW_BIND_COL_KEY = Symbol("ROW_BIND_COL_KEY");
function useCols() {
  const { length, childProviders: cols, bindChildren } = useChildren(ROW_BIND_COL_KEY);
  return {
    length,
    cols,
    bindCols: bindChildren
  };
}
function useRow() {
  const { index, bindParent, parentProvider } = useParent(ROW_BIND_COL_KEY);
  return {
    index,
    row: parentProvider,
    bindRow: bindParent
  };
}
const { name: name$U, n: n$$, classes: classes$M } = createNamespace("col");
function __render__$Z(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(
        _ctx.classes(
          _ctx.n(),
          _ctx.n("$--box"),
          [_ctx.span >= 0, _ctx.n(`--span-${_ctx.span}`)],
          [_ctx.offset, _ctx.n(`--offset-${_ctx.offset}`)],
          ..._ctx.getSize("xs", _ctx.xs),
          ..._ctx.getSize("sm", _ctx.sm),
          ..._ctx.getSize("md", _ctx.md),
          ..._ctx.getSize("lg", _ctx.lg),
          ..._ctx.getSize("xl", _ctx.xl)
        )
      ),
      style: vue.normalizeStyle({
        flexDirection: _ctx.direction,
        justifyContent: _ctx.padStartFlex(_ctx.justify),
        alignItems: _ctx.padStartFlex(_ctx.align),
        paddingLeft: _ctx.toSizeUnit(_ctx.padding.left),
        paddingRight: _ctx.toSizeUnit(_ctx.padding.right),
        paddingTop: _ctx.toSizeUnit(_ctx.padding.top),
        paddingBottom: _ctx.toSizeUnit(_ctx.padding.bottom)
      }),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    },
    [
      vue.renderSlot(_ctx.$slots, "default")
    ],
    6
    /* CLASS, STYLE */
  );
}
const __sfc__$10 = vue.defineComponent({
  name: name$U,
  props: props$T,
  setup(props2) {
    const span = vue.computed(() => toNumber(props2.span));
    const offset2 = vue.computed(() => toNumber(props2.offset));
    const padding = vue.computed(() => {
      var _a;
      const [y = 0, x = 0] = (_a = row == null ? void 0 : row.average.value) != null ? _a : [];
      return { left: x, right: x, top: y, bottom: y };
    });
    const { row, bindRow } = useRow();
    call(bindRow, null);
    function getSize2(mode, size) {
      const classes2 = [];
      if (size == null) {
        return classes2;
      }
      if (isPlainObject(size)) {
        const { offset: offset22, span: span2 } = size;
        if (Number(span2) >= 0) {
          classes2.push(n$$(`--span-${mode}-${span2}`));
        }
        if (offset22) {
          classes2.push(n$$(`--offset-${mode}-${offset22}`));
        }
        return classes2;
      }
      if (Number(size) >= 0) {
        classes2.push(n$$(`--span-${mode}-${size}`));
      }
      return classes2;
    }
    function handleClick(e) {
      call(props2.onClick, e);
    }
    return {
      span,
      offset: offset2,
      padding,
      n: n$$,
      classes: classes$M,
      toNumber,
      toSizeUnit,
      getSize: getSize2,
      handleClick,
      padStartFlex
    };
  }
});
__sfc__$10.render = __render__$Z;
var stdin_default$54 = __sfc__$10;
withInstall(stdin_default$54);
withPropsDefaultsSetter(stdin_default$54, props$T);
const _ColComponent = stdin_default$54;
var stdin_default$53 = stdin_default$54;
const props$S = {
  modelValue: [Array, String, Number],
  accordion: Boolean,
  offset: {
    type: Boolean,
    default: true
  },
  divider: {
    type: Boolean,
    default: true
  },
  elevation: {
    type: [Boolean, String, Number],
    default: true
  },
  onChange: defineListenerProp(),
  "onUpdate:modelValue": defineListenerProp()
};
const COLLAPSE_BIND_COLLAPSE_ITEM_KEY = Symbol("COLLAPSE_BIND_COLLAPSE_ITEM_KEY");
function useCollapseItem() {
  const { childProviders, length, bindChildren } = useChildren(
    COLLAPSE_BIND_COLLAPSE_ITEM_KEY
  );
  return {
    length,
    collapseItems: childProviders,
    bindCollapseItems: bindChildren
  };
}
const { name: name$T, n: n$_ } = createNamespace("collapse");
function __render__$Y(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.n())
    },
    [
      vue.renderSlot(_ctx.$slots, "default")
    ],
    2
    /* CLASS */
  );
}
const __sfc__$$ = vue.defineComponent({
  name: name$T,
  props: props$S,
  setup(props2) {
    const offset2 = vue.computed(() => props2.offset);
    const divider = vue.computed(() => props2.divider);
    const elevation = vue.computed(() => props2.elevation);
    const accordion = vue.computed(() => props2.accordion);
    const normalizeValues = vue.computed(() => normalizeToArray(props2.modelValue));
    const { length, collapseItems, bindCollapseItems } = useCollapseItem();
    const collapseProvider = {
      offset: offset2,
      divider,
      elevation,
      accordion,
      updateItem
    };
    vue.watch(
      () => length.value,
      () => vue.nextTick().then(resize)
    );
    vue.watch(
      () => props2.modelValue,
      () => vue.nextTick().then(resize)
    );
    bindCollapseItems(collapseProvider);
    function updateItem(itemValue, targetExpand) {
      if (props2.accordion) {
        const modelValue2 = targetExpand ? itemValue : void 0;
        updateModelValue(modelValue2);
        return;
      }
      const modelValue = targetExpand ? [...normalizeValues.value, itemValue] : normalizeValues.value.filter((value) => value !== itemValue);
      updateModelValue(modelValue);
    }
    function updateModelValue(modelValue) {
      call(props2["onUpdate:modelValue"], modelValue);
      call(props2.onChange, modelValue);
    }
    function matchItems() {
      if (props2.accordion) {
        const [value] = normalizeValues.value;
        if (value == null) {
          return;
        }
        const matchedNameItem = collapseItems.find(({ name: name2 }) => value === name2.value);
        if (matchedNameItem == null) {
          return collapseItems.find(({ index, name: name2 }) => name2.value == null && value === index.value);
        }
        return matchedNameItem;
      }
      const matchedNameItems = collapseItems.filter(
        ({ name: name2 }) => name2.value != null && normalizeValues.value.includes(name2.value)
      );
      const matchedIndexItems = collapseItems.filter(
        ({ index, name: name2 }) => name2.value == null && normalizeValues.value.includes(index.value)
      );
      return [...matchedNameItems, ...matchedIndexItems];
    }
    function resize() {
      const matchedItems = removeArrayBlank(normalizeToArray(matchItems()));
      collapseItems.forEach((collapseItem) => {
        collapseItem.init(matchedItems.includes(collapseItem));
      });
    }
    const toggleAll = (options) => {
      if (props2.accordion) {
        return;
      }
      const matchedItems = collapseItems.filter((item) => {
        var _a;
        const itemValue = (_a = item.name.value) != null ? _a : item.index.value;
        const expanded = normalizeValues.value.includes(itemValue);
        if (options.skipDisabled && item.disabled.value) {
          return expanded;
        }
        if (options.expand === "inverse") {
          return !expanded;
        }
        return options.expand;
      });
      const modelValue = matchedItems.map((item) => {
        var _a;
        return (_a = item.name.value) != null ? _a : item.index.value;
      });
      updateModelValue(modelValue);
    };
    return {
      divider,
      n: n$_,
      toggleAll
    };
  }
});
__sfc__$$.render = __render__$Y;
var stdin_default$52 = __sfc__$$;
withInstall(stdin_default$52);
withPropsDefaultsSetter(stdin_default$52, props$S);
const _CollapseComponent = stdin_default$52;
var stdin_default$51 = stdin_default$52;
var __async$b = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function useCollapseTransition(options) {
  const { contentEl, showContent, expand } = options;
  let isInitToTrigger = true;
  vue.watch(
    expand,
    (value) => {
      vue.nextTick(() => {
        value ? open() : close();
      });
    },
    { immediate: true }
  );
  function open() {
    return __async$b(this, null, function* () {
      if (!contentEl.value) {
        return;
      }
      contentEl.value.style.height = "";
      showContent.value = true;
      yield raf();
      if (!contentEl.value) {
        return;
      }
      const { offsetHeight } = contentEl.value;
      contentEl.value.style.height = "0px";
      yield raf();
      if (!contentEl.value) {
        return;
      }
      contentEl.value.style.height = offsetHeight + "px";
      if (!isInitToTrigger) {
        return;
      }
      yield doubleRaf();
      if (isInitToTrigger) {
        handleTransitionEnd();
      }
    });
  }
  const close = () => __async$b(this, null, function* () {
    if (!contentEl.value) {
      return;
    }
    const { offsetHeight } = contentEl.value;
    contentEl.value.style.height = offsetHeight + "px";
    yield raf();
    contentEl.value.style.height = "0px";
  });
  const handleTransitionEnd = () => {
    if (!expand.value) {
      showContent.value = false;
    }
    contentEl.value.style.height = "";
  };
  const handleTransitionStart = () => {
    isInitToTrigger = false;
  };
  return {
    handleTransitionEnd,
    handleTransitionStart
  };
}
const props$R = {
  name: [String, Number],
  title: String,
  icon: {
    type: String,
    default: "chevron-down"
  },
  disabled: Boolean
};
function useCollapse() {
  const { parentProvider, index, bindParent } = useParent(
    COLLAPSE_BIND_COLLAPSE_ITEM_KEY
  );
  assert(!!bindParent, "Collapse", "<var-collapse-item/> must in <var-collapse>");
  return {
    index,
    collapse: parentProvider,
    bindCollapse: bindParent
  };
}
const { name: name$S, n: n$Z, classes: classes$L } = createNamespace("collapse-item");
const _hoisted_1$o = ["aria-expanded", "aria-disabled", "role"];
function __render__$X(_ctx, _cache) {
  const _component_var_icon = vue.resolveComponent("var-icon");
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.classes(_ctx.n(), [_ctx.offset && _ctx.isShow, _ctx.n("--active")], [_ctx.disabled, _ctx.n("--disable")])),
      style: vue.normalizeStyle(`--collapse-divider-top: ${_ctx.divider ? "var(--collapse-border-top)" : "none"}`)
    },
    [
      vue.createElementVNode(
        "div",
        {
          class: vue.normalizeClass(_ctx.classes(_ctx.n("shadow"), _ctx.formatElevation(_ctx.elevation, 2)))
        },
        null,
        2
        /* CLASS */
      ),
      vue.createElementVNode("div", {
        class: vue.normalizeClass(_ctx.classes(_ctx.n("header"), [!_ctx.disabled, _ctx.n("header--cursor-pointer")])),
        "aria-expanded": _ctx.isShow,
        "aria-disabled": _ctx.disabled,
        role: _ctx.accordion ? "tab" : "button",
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.toggle && _ctx.toggle(...args))
      }, [
        _ctx.$slots.title || _ctx.title ? (vue.openBlock(), vue.createElementBlock(
          "div",
          {
            key: 0,
            class: vue.normalizeClass(_ctx.n("header-title"))
          },
          [
            vue.renderSlot(_ctx.$slots, "title", {}, () => [
              vue.createTextVNode(
                vue.toDisplayString(_ctx.title),
                1
                /* TEXT */
              )
            ])
          ],
          2
          /* CLASS */
        )) : vue.createCommentVNode("v-if", true),
        vue.createElementVNode(
          "div",
          {
            class: vue.normalizeClass(_ctx.n("header-icon"))
          },
          [
            vue.renderSlot(_ctx.$slots, "icon", {}, () => [
              vue.createVNode(_component_var_icon, {
                name: _ctx.icon,
                transition: 250,
                class: vue.normalizeClass(
                  _ctx.classes(
                    _ctx.n("header-icon"),
                    [_ctx.isShow && _ctx.icon === "chevron-down", _ctx.n("header-open")],
                    [_ctx.disabled, _ctx.n("header--disable")]
                  )
                )
              }, null, 8, ["name", "class"])
            ])
          ],
          2
          /* CLASS */
        )
      ], 10, _hoisted_1$o),
      vue.withDirectives(vue.createElementVNode(
        "div",
        {
          ref: "contentEl",
          class: vue.normalizeClass(_ctx.n("content")),
          onTransitionend: _cache[1] || (_cache[1] = (...args) => _ctx.handleTransitionEnd && _ctx.handleTransitionEnd(...args)),
          onTransitionstart: _cache[2] || (_cache[2] = (...args) => _ctx.handleTransitionStart && _ctx.handleTransitionStart(...args))
        },
        [
          vue.createElementVNode(
            "div",
            {
              class: vue.normalizeClass(_ctx.n("content-wrap"))
            },
            [
              vue.renderSlot(_ctx.$slots, "default")
            ],
            2
            /* CLASS */
          )
        ],
        34
        /* CLASS, NEED_HYDRATION */
      ), [
        [vue.vShow, _ctx.showContent]
      ])
    ],
    6
    /* CLASS, STYLE */
  );
}
const __sfc__$_ = vue.defineComponent({
  name: name$S,
  components: {
    VarIcon: stdin_default$5_
  },
  props: props$R,
  setup(props2) {
    const isShow = vue.ref(false);
    const showContent = vue.ref(false);
    const contentEl = vue.ref(null);
    const name2 = vue.computed(() => props2.name);
    const disabled = vue.computed(() => props2.disabled);
    const { index, collapse, bindCollapse } = useCollapse();
    const { offset: offset2, divider, elevation, accordion, updateItem } = collapse;
    const collapseItemProvider = {
      index,
      name: name2,
      disabled,
      init
    };
    bindCollapse(collapseItemProvider);
    const { handleTransitionEnd, handleTransitionStart } = useCollapseTransition({
      contentEl,
      showContent,
      expand: isShow
    });
    function init(show) {
      isShow.value = show;
    }
    function toggle() {
      var _a;
      if (props2.disabled) {
        return;
      }
      updateItem((_a = props2.name) != null ? _a : index.value, !isShow.value);
    }
    return {
      isShow,
      showContent,
      offset: offset2,
      divider,
      elevation,
      contentEl,
      accordion,
      n: n$Z,
      classes: classes$L,
      toggle,
      formatElevation,
      handleTransitionEnd,
      handleTransitionStart
    };
  }
});
__sfc__$_.render = __render__$X;
var stdin_default$50 = __sfc__$_;
withInstall(stdin_default$50);
withPropsDefaultsSetter(stdin_default$50, props$R);
const _CollapseItemComponent = stdin_default$50;
var stdin_default$4$ = stdin_default$50;
const props$Q = {
  expand: Boolean
};
const { name: name$R, n: n$Y } = createNamespace("collapse-transition");
function __render__$W(_ctx, _cache) {
  return vue.withDirectives((vue.openBlock(), vue.createElementBlock(
    "div",
    {
      ref: "contentEl",
      class: vue.normalizeClass(_ctx.n("content")),
      onTransitionend: _cache[0] || (_cache[0] = (...args) => _ctx.handleTransitionEnd && _ctx.handleTransitionEnd(...args)),
      onTransitionstart: _cache[1] || (_cache[1] = (...args) => _ctx.handleTransitionStart && _ctx.handleTransitionStart(...args))
    },
    [
      vue.renderSlot(_ctx.$slots, "default")
    ],
    34
    /* CLASS, NEED_HYDRATION */
  )), [
    [vue.vShow, _ctx.showContent]
  ]);
}
const __sfc__$Z = vue.defineComponent({
  name: name$R,
  props: props$Q,
  setup(props2) {
    const showContent = vue.ref(false);
    const contentEl = vue.ref(null);
    const expand = vue.computed(() => props2.expand);
    const { handleTransitionEnd, handleTransitionStart } = useCollapseTransition({
      contentEl,
      showContent,
      expand
    });
    return {
      showContent,
      contentEl,
      n: n$Y,
      handleTransitionEnd,
      handleTransitionStart
    };
  }
});
__sfc__$Z.render = __render__$W;
var stdin_default$4_ = __sfc__$Z;
withInstall(stdin_default$4_);
withPropsDefaultsSetter(stdin_default$4_, props$Q);
const _CollapseTransitionComponent = stdin_default$4_;
var stdin_default$4Z = stdin_default$4_;
const props$P = {
  from: {
    type: [String, Number],
    default: 0
  },
  to: {
    type: [String, Number],
    default: 0
  },
  duration: {
    type: [String, Number],
    default: 2e3
  },
  precision: {
    type: [String, Number],
    default: 0
  },
  autoStart: {
    type: Boolean,
    default: true
  },
  timingFunction: {
    type: Function
  },
  onEnd: defineListenerProp()
};
const { name: name$Q, n: n$X } = createNamespace("count-to");
function __render__$V(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.n())
    },
    [
      vue.renderSlot(_ctx.$slots, "default", { value: _ctx.value }, () => [
        vue.createTextVNode(
          vue.toDisplayString(_ctx.value),
          1
          /* TEXT */
        )
      ])
    ],
    2
    /* CLASS */
  );
}
const __sfc__$Y = vue.defineComponent({
  name: name$Q,
  props: props$P,
  setup(props2) {
    const {
      value: _value,
      reset: _reset,
      // expose
      start: start2,
      // expose
      pause
    } = useMotion({
      from: () => toNumber(props2.from),
      to: () => toNumber(props2.to),
      duration: () => toNumber(props2.duration),
      timingFunction: props2.timingFunction,
      onFinished() {
        call(props2.onEnd);
      }
    });
    const value = vue.computed(() => floor$1(_value.value, toNumber(props2.precision)));
    vue.watch(() => [props2.from, props2.to, props2.duration], reset);
    vue.onMounted(reset);
    function reset() {
      _reset();
      if (props2.autoStart) {
        start2();
      }
    }
    return {
      value,
      n: n$X,
      start: start2,
      pause,
      reset,
      toNumber,
      floor: floor$1
    };
  }
});
__sfc__$Y.render = __render__$V;
var stdin_default$4Y = __sfc__$Y;
withInstall(stdin_default$4Y);
withPropsDefaultsSetter(stdin_default$4Y, props$P);
const _CountToComponent = stdin_default$4Y;
var stdin_default$4X = stdin_default$4Y;
const props$O = {
  time: {
    type: [String, Number],
    default: 0
  },
  format: {
    type: String,
    default: "HH : mm : ss"
  },
  autoStart: {
    type: Boolean,
    default: true
  },
  onEnd: defineListenerProp(),
  onChange: defineListenerProp()
};
const { name: name$P, n: n$W } = createNamespace("countdown");
const SECOND = 1e3;
const MINUTE = 60 * SECOND;
const HOUR = 60 * MINUTE;
const DAY = 24 * HOUR;
function __render__$U(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.n())
    },
    [
      vue.renderSlot(_ctx.$slots, "default", vue.normalizeProps(vue.guardReactiveProps(_ctx.timeData)), () => [
        vue.createTextVNode(
          vue.toDisplayString(_ctx.showTime),
          1
          /* TEXT */
        )
      ])
    ],
    2
    /* CLASS */
  );
}
const __sfc__$X = vue.defineComponent({
  name: name$P,
  props: props$O,
  setup(props2) {
    const showTime = vue.ref("");
    const timeData = vue.ref({
      days: 0,
      hours: 0,
      minutes: 0,
      seconds: 0,
      milliseconds: 0
    });
    let endTime = 0;
    let isStart = false;
    let handle = 0;
    let remainingTime = 0;
    let cacheIsStart;
    vue.watch(
      () => props2.time,
      () => {
        reset();
        if (props2.autoStart) {
          start2();
        }
      }
    );
    vue.onMounted(() => {
      countdown();
      if (props2.autoStart) {
        start2();
      }
    });
    vue.onActivated(() => {
      if (cacheIsStart == null) {
        return;
      }
      isStart = cacheIsStart;
      if (isStart === true) {
        start2(true);
      }
    });
    vue.onDeactivated(() => {
      cacheIsStart = isStart;
      pause();
    });
    vue.onUnmounted(pause);
    function parseFormat(format2, time) {
      const scannedTimes = Object.values(time);
      const scannedFormats = ["DD", "HH", "mm", "ss"];
      const padValues = [24, 60, 60, 1e3];
      scannedFormats.forEach((scannedFormat, index) => {
        if (!format2.includes(scannedFormat)) {
          scannedTimes[index + 1] += scannedTimes[index] * padValues[index];
        } else {
          format2 = format2.replace(scannedFormat, padStart$1(`${scannedTimes[index]}`, 2, "0"));
        }
      });
      if (format2.includes("S")) {
        const ms = padStart$1(`${scannedTimes[scannedTimes.length - 1]}`, 3, "0");
        if (format2.includes("SSS")) {
          format2 = format2.replace("SSS", ms);
        } else if (format2.includes("SS")) {
          format2 = format2.replace("SS", ms.slice(0, 2));
        } else {
          format2 = format2.replace("S", ms.slice(0, 1));
        }
      }
      return format2;
    }
    function displayTime(durationTime) {
      const days = Math.floor(durationTime / DAY);
      const hours = Math.floor(durationTime % DAY / HOUR);
      const minutes = Math.floor(durationTime % HOUR / MINUTE);
      const seconds = Math.floor(durationTime % MINUTE / SECOND);
      const milliseconds = Math.floor(durationTime % SECOND);
      const time = {
        days,
        hours,
        minutes,
        seconds,
        milliseconds
      };
      timeData.value = time;
      call(props2.onChange, timeData.value);
      showTime.value = parseFormat(props2.format, time);
    }
    function countdown() {
      const { time, onEnd } = props2;
      const now = performance.now();
      if (!endTime) {
        endTime = now + toNumber(time);
      }
      remainingTime = endTime - now;
      if (remainingTime < 0) {
        remainingTime = 0;
      }
      displayTime(remainingTime);
      if (remainingTime === 0) {
        call(onEnd);
        return;
      }
      if (isStart) {
        handle = requestAnimationFrame$1(countdown);
      }
    }
    function start2(resume = false) {
      if (isStart && !resume) {
        return;
      }
      isStart = true;
      endTime = performance.now() + (remainingTime || toNumber(props2.time));
      countdown();
    }
    function pause() {
      isStart = false;
      cancelAnimationFrame(handle);
    }
    function reset() {
      endTime = 0;
      isStart = false;
      cancelAnimationFrame(handle);
      countdown();
    }
    return {
      showTime,
      timeData,
      n: n$W,
      start: start2,
      pause,
      reset
    };
  }
});
__sfc__$X.render = __render__$U;
var stdin_default$4W = __sfc__$X;
withInstall(stdin_default$4W);
withPropsDefaultsSetter(stdin_default$4W, props$O);
const _CountdownComponent = stdin_default$4W;
var stdin_default$4V = stdin_default$4W;
/*!
 *  decimal.js v10.4.0
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js
 *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Licence
 */
var EXP_LIMIT = 9e15, MAX_DIGITS = 1e9, NUMERALS = "0123456789abcdef", LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", DEFAULTS = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -EXP_LIMIT,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: EXP_LIMIT,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: false
  // true/false
}, inexact, quadrant, external = true, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", precisionLimitExceeded = decimalError + "Precision limit exceeded", cryptoUnavailable = decimalError + "crypto unavailable", tag = "[object Decimal]", mathfloor = Math.floor, mathpow = Math.pow, isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, LN10_PRECISION = LN10.length - 1, PI_PRECISION = PI.length - 1, P = { toStringTag: tag };
P.absoluteValue = P.abs = function() {
  var x = new this.constructor(this);
  if (x.s < 0) x.s = 1;
  return finalise(x);
};
P.ceil = function() {
  return finalise(new this.constructor(this), this.e + 1, 2);
};
P.clampedTo = P.clamp = function(min2, max2) {
  var k, x = this, Ctor = x.constructor;
  min2 = new Ctor(min2);
  max2 = new Ctor(max2);
  if (!min2.s || !max2.s) return new Ctor(NaN);
  if (min2.gt(max2)) throw Error(invalidArgument + max2);
  k = x.cmp(min2);
  return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x);
};
P.comparedTo = P.cmp = function(y) {
  var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
  if (!xd || !yd) {
    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
  }
  if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;
  if (xs !== ys) return xs;
  if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;
  xdL = xd.length;
  ydL = yd.length;
  for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
    if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
};
P.cosine = P.cos = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.d) return new Ctor(NaN);
  if (!x.d[0]) return new Ctor(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
};
P.cubeRoot = P.cbrt = function() {
  var e, m, n2, r, rep, s, sd, t2, t3, t3plusx, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero()) return new Ctor(x);
  external = false;
  s = x.s * mathpow(x.s * x, 1 / 3);
  if (!s || Math.abs(s) == 1 / 0) {
    n2 = digitsToString(x.d);
    e = x.e;
    if (s = (e - n2.length + 1) % 3) n2 += s == 1 || s == -2 ? "0" : "00";
    s = mathpow(n2, 1 / 3);
    e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
    if (s == 1 / 0) {
      n2 = "5e" + e;
    } else {
      n2 = s.toExponential();
      n2 = n2.slice(0, n2.indexOf("e") + 1) + e;
    }
    r = new Ctor(n2);
    r.s = x.s;
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (; ; ) {
    t2 = r;
    t3 = t2.times(t2).times(t2);
    t3plusx = t3.plus(x);
    r = divide(t3plusx.plus(x).times(t2), t3plusx.plus(t3), sd + 2, 1);
    if (digitsToString(t2.d).slice(0, sd) === (n2 = digitsToString(r.d)).slice(0, sd)) {
      n2 = n2.slice(sd - 3, sd + 1);
      if (n2 == "9999" || !rep && n2 == "4999") {
        if (!rep) {
          finalise(t2, e + 1, 0);
          if (t2.times(t2).times(t2).eq(x)) {
            r = t2;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n2 || !+n2.slice(1) && n2.charAt(0) == "5") {
          finalise(r, e + 1, 1);
          m = !r.times(r).times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e, Ctor.rounding, m);
};
P.decimalPlaces = P.dp = function() {
  var w, d = this.d, n2 = NaN;
  if (d) {
    w = d.length - 1;
    n2 = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
    w = d[w];
    if (w) for (; w % 10 == 0; w /= 10) n2--;
    if (n2 < 0) n2 = 0;
  }
  return n2;
};
P.dividedBy = P.div = function(y) {
  return divide(this, new this.constructor(y));
};
P.dividedToIntegerBy = P.divToInt = function(y) {
  var x = this, Ctor = x.constructor;
  return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
};
P.equals = P.eq = function(y) {
  return this.cmp(y) === 0;
};
P.floor = function() {
  return finalise(new this.constructor(this), this.e + 1, 3);
};
P.greaterThan = P.gt = function(y) {
  return this.cmp(y) > 0;
};
P.greaterThanOrEqualTo = P.gte = function(y) {
  var k = this.cmp(y);
  return k == 1 || k === 0;
};
P.hyperbolicCosine = P.cosh = function() {
  var k, n2, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
  if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
  if (x.isZero()) return one;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    n2 = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    n2 = "2.3283064365386962890625e-10";
  }
  x = taylorSeries(Ctor, 1, x.times(n2), new Ctor(1), true);
  var cosh2_x, i = k, d8 = new Ctor(8);
  for (; i--; ) {
    cosh2_x = x.times(x);
    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
  }
  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P.hyperbolicSine = P.sinh = function() {
  var k, pr, rm, len, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero()) return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 3) {
    x = taylorSeries(Ctor, 2, x, x, true);
  } else {
    k = 1.4 * Math.sqrt(len);
    k = k > 16 ? 16 : k | 0;
    x = x.times(1 / tinyPow(5, k));
    x = taylorSeries(Ctor, 2, x, x, true);
    var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
    for (; k--; ) {
      sinh2_x = x.times(x);
      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
    }
  }
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(x, pr, rm, true);
};
P.hyperbolicTangent = P.tanh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite()) return new Ctor(x.s);
  if (x.isZero()) return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;
  return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
};
P.inverseCosine = P.acos = function() {
  var halfPi, x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
  if (k !== -1) {
    return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
  }
  if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = x.asin();
  halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return halfPi.minus(x);
};
P.inverseHyperbolicCosine = P.acosh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
  if (!x.isFinite()) return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).minus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P.inverseHyperbolicSine = P.asinh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero()) return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).plus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P.inverseHyperbolicTangent = P.atanh = function() {
  var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
  if (!x.isFinite()) return new Ctor(NaN);
  if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  xsd = x.sd();
  if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);
  Ctor.precision = wpr = xsd - x.e;
  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
  Ctor.precision = pr + 4;
  Ctor.rounding = 1;
  x = x.ln();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(0.5);
};
P.inverseSine = P.asin = function() {
  var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
  if (x.isZero()) return new Ctor(x);
  k = x.abs().cmp(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (k !== -1) {
    if (k === 0) {
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
      halfPi.s = x.s;
      return halfPi;
    }
    return new Ctor(NaN);
  }
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(2);
};
P.inverseTangent = P.atan = function() {
  var i, j, k, n2, px, t2, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
  if (!x.isFinite()) {
    if (!x.s) return new Ctor(NaN);
    if (pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.5);
      r.s = x.s;
      return r;
    }
  } else if (x.isZero()) {
    return new Ctor(x);
  } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
    r = getPi(Ctor, pr + 4, rm).times(0.25);
    r.s = x.s;
    return r;
  }
  Ctor.precision = wpr = pr + 10;
  Ctor.rounding = 1;
  k = Math.min(28, wpr / LOG_BASE + 2 | 0);
  for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));
  external = false;
  j = Math.ceil(wpr / LOG_BASE);
  n2 = 1;
  x2 = x.times(x);
  r = new Ctor(x);
  px = x;
  for (; i !== -1; ) {
    px = px.times(x2);
    t2 = r.minus(px.div(n2 += 2));
    px = px.times(x2);
    r = t2.plus(px.div(n2 += 2));
    if (r.d[j] !== void 0) for (i = j; r.d[i] === t2.d[i] && i--; ) ;
  }
  if (k) r = r.times(2 << k - 1);
  external = true;
  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P.isFinite = function() {
  return !!this.d;
};
P.isInteger = P.isInt = function() {
  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
};
P.isNaN = function() {
  return !this.s;
};
P.isNegative = P.isNeg = function() {
  return this.s < 0;
};
P.isPositive = P.isPos = function() {
  return this.s > 0;
};
P.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
P.lessThan = P.lt = function(y) {
  return this.cmp(y) < 0;
};
P.lessThanOrEqualTo = P.lte = function(y) {
  return this.cmp(y) < 1;
};
P.logarithm = P.log = function(base) {
  var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
  if (base == null) {
    base = new Ctor(10);
    isBase10 = true;
  } else {
    base = new Ctor(base);
    d = base.d;
    if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);
    isBase10 = base.eq(10);
  }
  d = arg.d;
  if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
    return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
  }
  if (isBase10) {
    if (d.length > 1) {
      inf = true;
    } else {
      for (k = d[0]; k % 10 === 0; ) k /= 10;
      inf = k !== 1;
    }
  }
  external = false;
  sd = pr + guard;
  num = naturalLogarithm(arg, sd);
  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
  r = divide(num, denominator, sd, 1);
  if (checkRoundingDigits(r.d, k = pr, rm)) {
    do {
      sd += 10;
      num = naturalLogarithm(arg, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
      r = divide(num, denominator, sd, 1);
      if (!inf) {
        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0);
        }
        break;
      }
    } while (checkRoundingDigits(r.d, k += 10, rm));
  }
  external = true;
  return finalise(r, pr, rm);
};
P.minus = P.sub = function(y) {
  var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s) y = new Ctor(NaN);
    else if (x.d) y.s = -y.s;
    else y = new Ctor(y.d || x.s !== y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.plus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (yd[0]) y.s = -y.s;
    else if (xd[0]) y = new Ctor(x);
    else return new Ctor(rm === 3 ? -0 : 0);
    return external ? finalise(y, pr, rm) : y;
  }
  e = mathfloor(y.e / LOG_BASE);
  xe = mathfloor(x.e / LOG_BASE);
  xd = xd.slice();
  k = xe - e;
  if (k) {
    xLTy = k < 0;
    if (xLTy) {
      d = xd;
      k = -k;
      len = yd.length;
    } else {
      d = yd;
      e = xe;
      len = xd.length;
    }
    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
    if (k > i) {
      k = i;
      d.length = 1;
    }
    d.reverse();
    for (i = k; i--; ) d.push(0);
    d.reverse();
  } else {
    i = xd.length;
    len = yd.length;
    xLTy = i < len;
    if (xLTy) len = i;
    for (i = 0; i < len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] < yd[i];
        break;
      }
    }
    k = 0;
  }
  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y.s = -y.s;
  }
  len = xd.length;
  for (i = yd.length - len; i > 0; --i) xd[len++] = 0;
  for (i = yd.length; i > k; ) {
    if (xd[--i] < yd[i]) {
      for (j = i; j && xd[--j] === 0; ) xd[j] = BASE - 1;
      --xd[j];
      xd[i] += BASE;
    }
    xd[i] -= yd[i];
  }
  for (; xd[--len] === 0; ) xd.pop();
  for (; xd[0] === 0; xd.shift()) --e;
  if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);
  y.d = xd;
  y.e = getBase10Exponent(xd, e);
  return external ? finalise(y, pr, rm) : y;
};
P.modulo = P.mod = function(y) {
  var q, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);
  if (!y.d || x.d && !x.d[0]) {
    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
  }
  external = false;
  if (Ctor.modulo == 9) {
    q = divide(x, y.abs(), 0, 3, 1);
    q.s *= y.s;
  } else {
    q = divide(x, y, 0, Ctor.modulo, 1);
  }
  q = q.times(y);
  external = true;
  return x.minus(q);
};
P.naturalExponential = P.exp = function() {
  return naturalExponential(this);
};
P.naturalLogarithm = P.ln = function() {
  return naturalLogarithm(this);
};
P.negated = P.neg = function() {
  var x = new this.constructor(this);
  x.s = -x.s;
  return finalise(x);
};
P.plus = P.add = function(y) {
  var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s) y = new Ctor(NaN);
    else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (!yd[0]) y = new Ctor(x);
    return external ? finalise(y, pr, rm) : y;
  }
  k = mathfloor(x.e / LOG_BASE);
  e = mathfloor(y.e / LOG_BASE);
  xd = xd.slice();
  i = k - e;
  if (i) {
    if (i < 0) {
      d = xd;
      i = -i;
      len = yd.length;
    } else {
      d = yd;
      e = k;
      len = xd.length;
    }
    k = Math.ceil(pr / LOG_BASE);
    len = k > len ? k + 1 : len + 1;
    if (i > len) {
      i = len;
      d.length = 1;
    }
    d.reverse();
    for (; i--; ) d.push(0);
    d.reverse();
  }
  len = xd.length;
  i = yd.length;
  if (len - i < 0) {
    i = len;
    d = yd;
    yd = xd;
    xd = d;
  }
  for (carry = 0; i; ) {
    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
    xd[i] %= BASE;
  }
  if (carry) {
    xd.unshift(carry);
    ++e;
  }
  for (len = xd.length; xd[--len] == 0; ) xd.pop();
  y.d = xd;
  y.e = getBase10Exponent(xd, e);
  return external ? finalise(y, pr, rm) : y;
};
P.precision = P.sd = function(z) {
  var k, x = this;
  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);
  if (x.d) {
    k = getPrecision(x.d);
    if (z && x.e + 1 > k) k = x.e + 1;
  } else {
    k = NaN;
  }
  return k;
};
P.round = function() {
  var x = this, Ctor = x.constructor;
  return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
};
P.sine = P.sin = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite()) return new Ctor(NaN);
  if (x.isZero()) return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x = sine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
};
P.squareRoot = P.sqrt = function() {
  var m, n2, sd, r, rep, t2, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;
  if (s !== 1 || !d || !d[0]) {
    return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
  }
  external = false;
  s = Math.sqrt(+x);
  if (s == 0 || s == 1 / 0) {
    n2 = digitsToString(d);
    if ((n2.length + e) % 2 == 0) n2 += "0";
    s = Math.sqrt(n2);
    e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
    if (s == 1 / 0) {
      n2 = "5e" + e;
    } else {
      n2 = s.toExponential();
      n2 = n2.slice(0, n2.indexOf("e") + 1) + e;
    }
    r = new Ctor(n2);
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (; ; ) {
    t2 = r;
    r = t2.plus(divide(x, t2, sd + 2, 1)).times(0.5);
    if (digitsToString(t2.d).slice(0, sd) === (n2 = digitsToString(r.d)).slice(0, sd)) {
      n2 = n2.slice(sd - 3, sd + 1);
      if (n2 == "9999" || !rep && n2 == "4999") {
        if (!rep) {
          finalise(t2, e + 1, 0);
          if (t2.times(t2).eq(x)) {
            r = t2;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n2 || !+n2.slice(1) && n2.charAt(0) == "5") {
          finalise(r, e + 1, 1);
          m = !r.times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e, Ctor.rounding, m);
};
P.tangent = P.tan = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite()) return new Ctor(NaN);
  if (x.isZero()) return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 10;
  Ctor.rounding = 1;
  x = x.sin();
  x.s = 1;
  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
};
P.times = P.mul = function(y) {
  var carry, e, i, k, r, rL, t2, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
  y.s *= x.s;
  if (!xd || !xd[0] || !yd || !yd[0]) {
    return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
  }
  e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
  xdL = xd.length;
  ydL = yd.length;
  if (xdL < ydL) {
    r = xd;
    xd = yd;
    yd = r;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r = [];
  rL = xdL + ydL;
  for (i = rL; i--; ) r.push(0);
  for (i = ydL; --i >= 0; ) {
    carry = 0;
    for (k = xdL + i; k > i; ) {
      t2 = r[k] + yd[i] * xd[k - i - 1] + carry;
      r[k--] = t2 % BASE | 0;
      carry = t2 / BASE | 0;
    }
    r[k] = (r[k] + carry) % BASE | 0;
  }
  for (; !r[--rL]; ) r.pop();
  if (carry) ++e;
  else r.shift();
  y.d = r;
  y.e = getBase10Exponent(r, e);
  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
};
P.toBinary = function(sd, rm) {
  return toStringBinary(this, 2, sd, rm);
};
P.toDecimalPlaces = P.toDP = function(dp, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (dp === void 0) return x;
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0) rm = Ctor.rounding;
  else checkInt32(rm, 0, 8);
  return finalise(x, dp + x.e + 1, rm);
};
P.toExponential = function(dp, rm) {
  var str, x = this, Ctor = x.constructor;
  if (dp === void 0) {
    str = finiteToString(x, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), dp + 1, rm);
    str = finiteToString(x, true, dp + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toFixed = function(dp, rm) {
  var str, y, x = this, Ctor = x.constructor;
  if (dp === void 0) {
    str = finiteToString(x);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
    y = finalise(new Ctor(x), dp + x.e + 1, rm);
    str = finiteToString(y, false, dp + y.e + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toFraction = function(maxD) {
  var d, d0, d1, d2, e, k, n2, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
  if (!xd) return new Ctor(x);
  n1 = d0 = new Ctor(1);
  d1 = n0 = new Ctor(0);
  d = new Ctor(d1);
  e = d.e = getPrecision(xd) - x.e - 1;
  k = e % LOG_BASE;
  d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
  if (maxD == null) {
    maxD = e > 0 ? d : n1;
  } else {
    n2 = new Ctor(maxD);
    if (!n2.isInt() || n2.lt(n1)) throw Error(invalidArgument + n2);
    maxD = n2.gt(d) ? e > 0 ? d : n1 : n2;
  }
  external = false;
  n2 = new Ctor(digitsToString(xd));
  pr = Ctor.precision;
  Ctor.precision = e = xd.length * LOG_BASE * 2;
  for (; ; ) {
    q = divide(n2, d, 0, 1, 1);
    d2 = d0.plus(q.times(d1));
    if (d2.cmp(maxD) == 1) break;
    d0 = d1;
    d1 = d2;
    d2 = n1;
    n1 = n0.plus(q.times(d2));
    n0 = d2;
    d2 = d;
    d = n2.minus(q.times(d2));
    n2 = d2;
  }
  d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
  n0 = n0.plus(d2.times(n1));
  d0 = d0.plus(d2.times(d1));
  n0.s = n1.s = x.s;
  r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
  Ctor.precision = pr;
  external = true;
  return r;
};
P.toHexadecimal = P.toHex = function(sd, rm) {
  return toStringBinary(this, 16, sd, rm);
};
P.toNearest = function(y, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (y == null) {
    if (!x.d) return x;
    y = new Ctor(1);
    rm = Ctor.rounding;
  } else {
    y = new Ctor(y);
    if (rm === void 0) {
      rm = Ctor.rounding;
    } else {
      checkInt32(rm, 0, 8);
    }
    if (!x.d) return y.s ? x : y;
    if (!y.d) {
      if (y.s) y.s = x.s;
      return y;
    }
  }
  if (y.d[0]) {
    external = false;
    x = divide(x, y, 0, rm, 1).times(y);
    external = true;
    finalise(x);
  } else {
    y.s = x.s;
    x = y;
  }
  return x;
};
P.toNumber = function() {
  return +this;
};
P.toOctal = function(sd, rm) {
  return toStringBinary(this, 8, sd, rm);
};
P.toPower = P.pow = function(y) {
  var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
  if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));
  x = new Ctor(x);
  if (x.eq(1)) return x;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (y.eq(1)) return finalise(x, pr, rm);
  e = mathfloor(y.e / LOG_BASE);
  if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
    r = intPow(Ctor, x, k, pr);
    return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
  }
  s = x.s;
  if (s < 0) {
    if (e < y.d.length - 1) return new Ctor(NaN);
    if ((y.d[e] & 1) == 0) s = 1;
    if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
      x.s = s;
      return x;
    }
  }
  k = mathpow(+x, yn);
  e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
  if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);
  external = false;
  Ctor.rounding = x.s = 1;
  k = Math.min(12, (e + "").length);
  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
  if (r.d) {
    r = finalise(r, pr + 5, 1);
    if (checkRoundingDigits(r.d, pr, rm)) {
      e = pr + 10;
      r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);
      if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
        r = finalise(r, pr + 1, 0);
      }
    }
  }
  r.s = s;
  external = true;
  Ctor.rounding = rm;
  return finalise(r, pr, rm);
};
P.toPrecision = function(sd, rm) {
  var str, x = this, Ctor = x.constructor;
  if (sd === void 0) {
    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), sd, rm);
    str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toSignificantDigits = P.toSD = function(sd, rm) {
  var x = this, Ctor = x.constructor;
  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
  }
  return finalise(new Ctor(x), sd, rm);
};
P.toString = function() {
  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.truncated = P.trunc = function() {
  return finalise(new this.constructor(this), this.e + 1, 1);
};
P.valueOf = P.toJSON = function() {
  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() ? "-" + str : str;
};
function digitsToString(d) {
  var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
  if (indexOfLastWord > 0) {
    str += w;
    for (i = 1; i < indexOfLastWord; i++) {
      ws = d[i] + "";
      k = LOG_BASE - ws.length;
      if (k) str += getZeroString(k);
      str += ws;
    }
    w = d[i];
    ws = w + "";
    k = LOG_BASE - ws.length;
    if (k) str += getZeroString(k);
  } else if (w === 0) {
    return "0";
  }
  for (; w % 10 === 0; ) w /= 10;
  return str + w;
}
function checkInt32(i, min2, max2) {
  if (i !== ~~i || i < min2 || i > max2) {
    throw Error(invalidArgument + i);
  }
}
function checkRoundingDigits(d, i, rm, repeating) {
  var di, k, r, rd;
  for (k = d[0]; k >= 10; k /= 10) --i;
  if (--i < 0) {
    i += LOG_BASE;
    di = 0;
  } else {
    di = Math.ceil((i + 1) / LOG_BASE);
    i %= LOG_BASE;
  }
  k = mathpow(10, LOG_BASE - i);
  rd = d[di] % k | 0;
  if (repeating == null) {
    if (i < 3) {
      if (i == 0) rd = rd / 100 | 0;
      else if (i == 1) rd = rd / 10 | 0;
      r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
    } else {
      r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
    }
  } else {
    if (i < 4) {
      if (i == 0) rd = rd / 1e3 | 0;
      else if (i == 1) rd = rd / 100 | 0;
      else if (i == 2) rd = rd / 10 | 0;
      r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
    } else {
      r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;
    }
  }
  return r;
}
function convertBase(str, baseIn, baseOut) {
  var j, arr = [0], arrL, i = 0, strL = str.length;
  for (; i < strL; ) {
    for (arrL = arr.length; arrL--; ) arr[arrL] *= baseIn;
    arr[0] += NUMERALS.indexOf(str.charAt(i++));
    for (j = 0; j < arr.length; j++) {
      if (arr[j] > baseOut - 1) {
        if (arr[j + 1] === void 0) arr[j + 1] = 0;
        arr[j + 1] += arr[j] / baseOut | 0;
        arr[j] %= baseOut;
      }
    }
  }
  return arr.reverse();
}
function cosine(Ctor, x) {
  var k, len, y;
  if (x.isZero()) return x;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    y = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    y = "2.3283064365386962890625e-10";
  }
  Ctor.precision += k;
  x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
  for (var i = k; i--; ) {
    var cos2x = x.times(x);
    x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
  }
  Ctor.precision -= k;
  return x;
}
var divide = /* @__PURE__ */ function() {
  function multiplyInteger(x, k, base) {
    var temp, carry = 0, i = x.length;
    for (x = x.slice(); i--; ) {
      temp = x[i] * k + carry;
      x[i] = temp % base | 0;
      carry = temp / base | 0;
    }
    if (carry) x.unshift(carry);
    return x;
  }
  function compare(a, b, aL, bL) {
    var i, r;
    if (aL != bL) {
      r = aL > bL ? 1 : -1;
    } else {
      for (i = r = 0; i < aL; i++) {
        if (a[i] != b[i]) {
          r = a[i] > b[i] ? 1 : -1;
          break;
        }
      }
    }
    return r;
  }
  function subtract(a, b, aL, base) {
    var i = 0;
    for (; aL--; ) {
      a[aL] -= i;
      i = a[aL] < b[aL] ? 1 : 0;
      a[aL] = i * base + a[aL] - b[aL];
    }
    for (; !a[0] && a.length > 1; ) a.shift();
  }
  return function(x, y, pr, rm, dp, base) {
    var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t2, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign2 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
    if (!xd || !xd[0] || !yd || !yd[0]) {
      return new Ctor(
        // Return NaN if either NaN, or both Infinity or 0.
        !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : (
          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
          xd && xd[0] == 0 || !yd ? sign2 * 0 : sign2 / 0
        )
      );
    }
    if (base) {
      logBase = 1;
      e = x.e - y.e;
    } else {
      base = BASE;
      logBase = LOG_BASE;
      e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
    }
    yL = yd.length;
    xL = xd.length;
    q = new Ctor(sign2);
    qd = q.d = [];
    for (i = 0; yd[i] == (xd[i] || 0); i++) ;
    if (yd[i] > (xd[i] || 0)) e--;
    if (pr == null) {
      sd = pr = Ctor.precision;
      rm = Ctor.rounding;
    } else if (dp) {
      sd = pr + (x.e - y.e) + 1;
    } else {
      sd = pr;
    }
    if (sd < 0) {
      qd.push(1);
      more = true;
    } else {
      sd = sd / logBase + 2 | 0;
      i = 0;
      if (yL == 1) {
        k = 0;
        yd = yd[0];
        sd++;
        for (; (i < xL || k) && sd--; i++) {
          t2 = k * base + (xd[i] || 0);
          qd[i] = t2 / yd | 0;
          k = t2 % yd | 0;
        }
        more = k || i < xL;
      } else {
        k = base / (yd[0] + 1) | 0;
        if (k > 1) {
          yd = multiplyInteger(yd, k, base);
          xd = multiplyInteger(xd, k, base);
          yL = yd.length;
          xL = xd.length;
        }
        xi = yL;
        rem = xd.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; ) rem[remL++] = 0;
        yz = yd.slice();
        yz.unshift(0);
        yd0 = yd[0];
        if (yd[1] >= base / 2) ++yd0;
        do {
          k = 0;
          cmp = compare(yd, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
            k = rem0 / yd0 | 0;
            if (k > 1) {
              if (k >= base) k = base - 1;
              prod = multiplyInteger(yd, k, base);
              prodL = prod.length;
              remL = rem.length;
              cmp = compare(prod, rem, prodL, remL);
              if (cmp == 1) {
                k--;
                subtract(prod, yL < prodL ? yz : yd, prodL, base);
              }
            } else {
              if (k == 0) cmp = k = 1;
              prod = yd.slice();
            }
            prodL = prod.length;
            if (prodL < remL) prod.unshift(0);
            subtract(rem, prod, remL, base);
            if (cmp == -1) {
              remL = rem.length;
              cmp = compare(yd, rem, yL, remL);
              if (cmp < 1) {
                k++;
                subtract(rem, yL < remL ? yz : yd, remL, base);
              }
            }
            remL = rem.length;
          } else if (cmp === 0) {
            k++;
            rem = [0];
          }
          qd[i++] = k;
          if (cmp && rem[0]) {
            rem[remL++] = xd[xi] || 0;
          } else {
            rem = [xd[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] !== void 0) && sd--);
        more = rem[0] !== void 0;
      }
      if (!qd[0]) qd.shift();
    }
    if (logBase == 1) {
      q.e = e;
      inexact = more;
    } else {
      for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;
      q.e = i + e * logBase - 1;
      finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
    }
    return q;
  };
}();
function finalise(x, sd, rm, isTruncated) {
  var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
  out: if (sd != null) {
    xd = x.d;
    if (!xd) return x;
    for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;
    i = sd - digits;
    if (i < 0) {
      i += LOG_BASE;
      j = sd;
      w = xd[xdi = 0];
      rd = w / mathpow(10, digits - j - 1) % 10 | 0;
    } else {
      xdi = Math.ceil((i + 1) / LOG_BASE);
      k = xd.length;
      if (xdi >= k) {
        if (isTruncated) {
          for (; k++ <= xdi; ) xd.push(0);
          w = rd = 0;
          digits = 1;
          i %= LOG_BASE;
          j = i - LOG_BASE + 1;
        } else {
          break out;
        }
      } else {
        w = k = xd[xdi];
        for (digits = 1; k >= 10; k /= 10) digits++;
        i %= LOG_BASE;
        j = i - LOG_BASE + digits;
        rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
      }
    }
    isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));
    roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
    (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
    if (sd < 1 || !xd[0]) {
      xd.length = 0;
      if (roundUp) {
        sd -= x.e + 1;
        xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
        x.e = -sd || 0;
      } else {
        xd[0] = x.e = 0;
      }
      return x;
    }
    if (i == 0) {
      xd.length = xdi;
      k = 1;
      xdi--;
    } else {
      xd.length = xdi + 1;
      k = mathpow(10, LOG_BASE - i);
      xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
    }
    if (roundUp) {
      for (; ; ) {
        if (xdi == 0) {
          for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;
          j = xd[0] += k;
          for (k = 1; j >= 10; j /= 10) k++;
          if (i != k) {
            x.e++;
            if (xd[0] == BASE) xd[0] = 1;
          }
          break;
        } else {
          xd[xdi] += k;
          if (xd[xdi] != BASE) break;
          xd[xdi--] = 0;
          k = 1;
        }
      }
    }
    for (i = xd.length; xd[--i] === 0; ) xd.pop();
  }
  if (external) {
    if (x.e > Ctor.maxE) {
      x.d = null;
      x.e = NaN;
    } else if (x.e < Ctor.minE) {
      x.e = 0;
      x.d = [0];
    }
  }
  return x;
}
function finiteToString(x, isExp, sd) {
  if (!x.isFinite()) return nonFiniteToString(x);
  var k, e = x.e, str = digitsToString(x.d), len = str.length;
  if (isExp) {
    if (sd && (k = sd - len) > 0) {
      str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
    } else if (len > 1) {
      str = str.charAt(0) + "." + str.slice(1);
    }
    str = str + (x.e < 0 ? "e" : "e+") + x.e;
  } else if (e < 0) {
    str = "0." + getZeroString(-e - 1) + str;
    if (sd && (k = sd - len) > 0) str += getZeroString(k);
  } else if (e >= len) {
    str += getZeroString(e + 1 - len);
    if (sd && (k = sd - e - 1) > 0) str = str + "." + getZeroString(k);
  } else {
    if ((k = e + 1) < len) str = str.slice(0, k) + "." + str.slice(k);
    if (sd && (k = sd - len) > 0) {
      if (e + 1 === len) str += ".";
      str += getZeroString(k);
    }
  }
  return str;
}
function getBase10Exponent(digits, e) {
  var w = digits[0];
  for (e *= LOG_BASE; w >= 10; w /= 10) e++;
  return e;
}
function getLn10(Ctor, sd, pr) {
  if (sd > LN10_PRECISION) {
    external = true;
    if (pr) Ctor.precision = pr;
    throw Error(precisionLimitExceeded);
  }
  return finalise(new Ctor(LN10), sd, 1, true);
}
function getPi(Ctor, sd, rm) {
  if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);
  return finalise(new Ctor(PI), sd, rm, true);
}
function getPrecision(digits) {
  var w = digits.length - 1, len = w * LOG_BASE + 1;
  w = digits[w];
  if (w) {
    for (; w % 10 == 0; w /= 10) len--;
    for (w = digits[0]; w >= 10; w /= 10) len++;
  }
  return len;
}
function getZeroString(k) {
  var zs = "";
  for (; k--; ) zs += "0";
  return zs;
}
function intPow(Ctor, x, n2, pr) {
  var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
  external = false;
  for (; ; ) {
    if (n2 % 2) {
      r = r.times(x);
      if (truncate(r.d, k)) isTruncated = true;
    }
    n2 = mathfloor(n2 / 2);
    if (n2 === 0) {
      n2 = r.d.length - 1;
      if (isTruncated && r.d[n2] === 0) ++r.d[n2];
      break;
    }
    x = x.times(x);
    truncate(x.d, k);
  }
  external = true;
  return r;
}
function isOdd(n2) {
  return n2.d[n2.d.length - 1] & 1;
}
function maxOrMin(Ctor, args, ltgt) {
  var y, x = new Ctor(args[0]), i = 0;
  for (; ++i < args.length; ) {
    y = new Ctor(args[i]);
    if (!y.s) {
      x = y;
      break;
    } else if (x[ltgt](y)) {
      x = y;
    }
  }
  return x;
}
function naturalExponential(x, sd) {
  var denominator, guard, j, pow2, sum2, t2, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (!x.d || !x.d[0] || x.e > 17) {
    return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  t2 = new Ctor(0.03125);
  while (x.e > -2) {
    x = x.times(t2);
    k += 5;
  }
  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow2 = sum2 = new Ctor(1);
  Ctor.precision = wpr;
  for (; ; ) {
    pow2 = finalise(pow2.times(x), wpr, 1);
    denominator = denominator.times(++i);
    t2 = sum2.plus(divide(pow2, denominator, wpr, 1));
    if (digitsToString(t2.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      j = k;
      while (j--) sum2 = finalise(sum2.times(sum2), wpr, 1);
      if (sd == null) {
        if (rep < 3 && checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += 10;
          denominator = pow2 = t2 = new Ctor(1);
          i = 0;
          rep++;
        } else {
          return finalise(sum2, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum2;
      }
    }
    sum2 = t2;
  }
}
function naturalLogarithm(y, sd) {
  var c, c0, denominator, e, numerator, rep, sum2, t2, wpr, x1, x2, n2 = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
    return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  Ctor.precision = wpr += guard;
  c = digitsToString(xd);
  c0 = c.charAt(0);
  if (Math.abs(e = x.e) < 15e14) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
      x = x.times(y);
      c = digitsToString(x.d);
      c0 = c.charAt(0);
      n2++;
    }
    e = x.e;
    if (c0 > 1) {
      x = new Ctor("0." + c);
      e++;
    } else {
      x = new Ctor(c0 + "." + c.slice(1));
    }
  } else {
    t2 = getLn10(Ctor, wpr + 2, pr).times(e + "");
    x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t2);
    Ctor.precision = pr;
    return sd == null ? finalise(x, pr, rm, external = true) : x;
  }
  x1 = x;
  sum2 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
  x2 = finalise(x.times(x), wpr, 1);
  denominator = 3;
  for (; ; ) {
    numerator = finalise(numerator.times(x2), wpr, 1);
    t2 = sum2.plus(divide(numerator, new Ctor(denominator), wpr, 1));
    if (digitsToString(t2.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      sum2 = sum2.times(2);
      if (e !== 0) sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
      sum2 = divide(sum2, new Ctor(n2), wpr, 1);
      if (sd == null) {
        if (checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += guard;
          t2 = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
          x2 = finalise(x.times(x), wpr, 1);
          denominator = rep = 1;
        } else {
          return finalise(sum2, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum2;
      }
    }
    sum2 = t2;
    denominator += 2;
  }
}
function nonFiniteToString(x) {
  return String(x.s * x.s / 0);
}
function parseDecimal(x, str) {
  var e, i, len;
  if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
  if ((i = str.search(/e/i)) > 0) {
    if (e < 0) e = i;
    e += +str.slice(i + 1);
    str = str.substring(0, i);
  } else if (e < 0) {
    e = str.length;
  }
  for (i = 0; str.charCodeAt(i) === 48; i++) ;
  for (len = str.length; str.charCodeAt(len - 1) === 48; --len) ;
  str = str.slice(i, len);
  if (str) {
    len -= i;
    x.e = e = e - i - 1;
    x.d = [];
    i = (e + 1) % LOG_BASE;
    if (e < 0) i += LOG_BASE;
    if (i < len) {
      if (i) x.d.push(+str.slice(0, i));
      for (len -= LOG_BASE; i < len; ) x.d.push(+str.slice(i, i += LOG_BASE));
      str = str.slice(i);
      i = LOG_BASE - str.length;
    } else {
      i -= len;
    }
    for (; i--; ) str += "0";
    x.d.push(+str);
    if (external) {
      if (x.e > x.constructor.maxE) {
        x.d = null;
        x.e = NaN;
      } else if (x.e < x.constructor.minE) {
        x.e = 0;
        x.d = [0];
      }
    }
  } else {
    x.e = 0;
    x.d = [0];
  }
  return x;
}
function parseOther(x, str) {
  var base, Ctor, divisor, i, isFloat, len, p, xd, xe;
  if (str.indexOf("_") > -1) {
    str = str.replace(/(\d)_(?=\d)/g, "$1");
    if (isDecimal.test(str)) return parseDecimal(x, str);
  } else if (str === "Infinity" || str === "NaN") {
    if (!+str) x.s = NaN;
    x.e = NaN;
    x.d = null;
    return x;
  }
  if (isHex.test(str)) {
    base = 16;
    str = str.toLowerCase();
  } else if (isBinary.test(str)) {
    base = 2;
  } else if (isOctal.test(str)) {
    base = 8;
  } else {
    throw Error(invalidArgument + str);
  }
  i = str.search(/p/i);
  if (i > 0) {
    p = +str.slice(i + 1);
    str = str.substring(2, i);
  } else {
    str = str.slice(2);
  }
  i = str.indexOf(".");
  isFloat = i >= 0;
  Ctor = x.constructor;
  if (isFloat) {
    str = str.replace(".", "");
    len = str.length;
    i = len - i;
    divisor = intPow(Ctor, new Ctor(base), i, i * 2);
  }
  xd = convertBase(str, base, BASE);
  xe = xd.length - 1;
  for (i = xe; xd[i] === 0; --i) xd.pop();
  if (i < 0) return new Ctor(x.s * 0);
  x.e = getBase10Exponent(xd, xe);
  x.d = xd;
  external = false;
  if (isFloat) x = divide(x, divisor, len * 4);
  if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
  external = true;
  return x;
}
function sine(Ctor, x) {
  var k, len = x.d.length;
  if (len < 3) {
    return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
  }
  k = 1.4 * Math.sqrt(len);
  k = k > 16 ? 16 : k | 0;
  x = x.times(1 / tinyPow(5, k));
  x = taylorSeries(Ctor, 2, x, x);
  var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
  for (; k--; ) {
    sin2_x = x.times(x);
    x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
  }
  return x;
}
function taylorSeries(Ctor, n2, x, y, isHyperbolic) {
  var j, t2, u, x2, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
  external = false;
  x2 = x.times(x);
  u = new Ctor(y);
  for (; ; ) {
    t2 = divide(u.times(x2), new Ctor(n2++ * n2++), pr, 1);
    u = isHyperbolic ? y.plus(t2) : y.minus(t2);
    y = divide(t2.times(x2), new Ctor(n2++ * n2++), pr, 1);
    t2 = u.plus(y);
    if (t2.d[k] !== void 0) {
      for (j = k; t2.d[j] === u.d[j] && j--; ) ;
      if (j == -1) break;
    }
    j = u;
    u = y;
    y = t2;
    t2 = j;
  }
  external = true;
  t2.d.length = k + 1;
  return t2;
}
function tinyPow(b, e) {
  var n2 = b;
  while (--e) n2 *= b;
  return n2;
}
function toLessThanHalfPi(Ctor, x) {
  var t2, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
  x = x.abs();
  if (x.lte(halfPi)) {
    quadrant = isNeg ? 4 : 1;
    return x;
  }
  t2 = x.divToInt(pi);
  if (t2.isZero()) {
    quadrant = isNeg ? 3 : 2;
  } else {
    x = x.minus(t2.times(pi));
    if (x.lte(halfPi)) {
      quadrant = isOdd(t2) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
      return x;
    }
    quadrant = isOdd(t2) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
  }
  return x.minus(pi).abs();
}
function toStringBinary(x, baseOut, sd, rm) {
  var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
  if (isExp) {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
  } else {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  }
  if (!x.isFinite()) {
    str = nonFiniteToString(x);
  } else {
    str = finiteToString(x);
    i = str.indexOf(".");
    if (isExp) {
      base = 2;
      if (baseOut == 16) {
        sd = sd * 4 - 3;
      } else if (baseOut == 8) {
        sd = sd * 3 - 2;
      }
    } else {
      base = baseOut;
    }
    if (i >= 0) {
      str = str.replace(".", "");
      y = new Ctor(1);
      y.e = str.length - i;
      y.d = convertBase(finiteToString(y), 10, base);
      y.e = y.d.length;
    }
    xd = convertBase(str, 10, base);
    e = len = xd.length;
    for (; xd[--len] == 0; ) xd.pop();
    if (!xd[0]) {
      str = isExp ? "0p+0" : "0";
    } else {
      if (i < 0) {
        e--;
      } else {
        x = new Ctor(x);
        x.d = xd;
        x.e = e;
        x = divide(x, y, sd, rm, 0, base);
        xd = x.d;
        e = x.e;
        roundUp = inexact;
      }
      i = xd[sd];
      k = base / 2;
      roundUp = roundUp || xd[sd + 1] !== void 0;
      roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
      xd.length = sd;
      if (roundUp) {
        for (; ++xd[--sd] > base - 1; ) {
          xd[sd] = 0;
          if (!sd) {
            ++e;
            xd.unshift(1);
          }
        }
      }
      for (len = xd.length; !xd[len - 1]; --len) ;
      for (i = 0, str = ""; i < len; i++) str += NUMERALS.charAt(xd[i]);
      if (isExp) {
        if (len > 1) {
          if (baseOut == 16 || baseOut == 8) {
            i = baseOut == 16 ? 4 : 3;
            for (--len; len % i; len++) str += "0";
            xd = convertBase(str, base, baseOut);
            for (len = xd.length; !xd[len - 1]; --len) ;
            for (i = 1, str = "1."; i < len; i++) str += NUMERALS.charAt(xd[i]);
          } else {
            str = str.charAt(0) + "." + str.slice(1);
          }
        }
        str = str + (e < 0 ? "p" : "p+") + e;
      } else if (e < 0) {
        for (; ++e; ) str = "0" + str;
        str = "0." + str;
      } else {
        if (++e > len) for (e -= len; e--; ) str += "0";
        else if (e < len) str = str.slice(0, e) + "." + str.slice(e);
      }
    }
    str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
  }
  return x.s < 0 ? "-" + str : str;
}
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
function abs(x) {
  return new this(x).abs();
}
function acos(x) {
  return new this(x).acos();
}
function acosh(x) {
  return new this(x).acosh();
}
function add(x, y) {
  return new this(x).plus(y);
}
function asin(x) {
  return new this(x).asin();
}
function asinh(x) {
  return new this(x).asinh();
}
function atan(x) {
  return new this(x).atan();
}
function atanh(x) {
  return new this(x).atanh();
}
function atan2(y, x) {
  y = new this(y);
  x = new this(x);
  var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
  if (!y.s || !x.s) {
    r = new this(NaN);
  } else if (!y.d && !x.d) {
    r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
    r.s = y.s;
  } else if (!x.d || y.isZero()) {
    r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
    r.s = y.s;
  } else if (!y.d || x.isZero()) {
    r = getPi(this, wpr, 1).times(0.5);
    r.s = y.s;
  } else if (x.s < 0) {
    this.precision = wpr;
    this.rounding = 1;
    r = this.atan(divide(y, x, wpr, 1));
    x = getPi(this, wpr, 1);
    this.precision = pr;
    this.rounding = rm;
    r = y.s < 0 ? r.minus(x) : r.plus(x);
  } else {
    r = this.atan(divide(y, x, wpr, 1));
  }
  return r;
}
function cbrt(x) {
  return new this(x).cbrt();
}
function ceil(x) {
  return finalise(x = new this(x), x.e + 1, 2);
}
function clamp(x, min2, max2) {
  return new this(x).clamp(min2, max2);
}
function config(obj) {
  if (!obj || typeof obj !== "object") throw Error(decimalError + "Object expected");
  var i, p, v, useDefaults = obj.defaults === true, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -EXP_LIMIT,
    0,
    "toExpPos",
    0,
    EXP_LIMIT,
    "maxE",
    0,
    EXP_LIMIT,
    "minE",
    -EXP_LIMIT,
    0,
    "modulo",
    0,
    9
  ];
  for (i = 0; i < ps.length; i += 3) {
    if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];
    if ((v = obj[p]) !== void 0) {
      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
      else throw Error(invalidArgument + p + ": " + v);
    }
  }
  if (p = "crypto", useDefaults) this[p] = DEFAULTS[p];
  if ((v = obj[p]) !== void 0) {
    if (v === true || v === false || v === 0 || v === 1) {
      if (v) {
        if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
          this[p] = true;
        } else {
          throw Error(cryptoUnavailable);
        }
      } else {
        this[p] = false;
      }
    } else {
      throw Error(invalidArgument + p + ": " + v);
    }
  }
  return this;
}
function cos(x) {
  return new this(x).cos();
}
function cosh(x) {
  return new this(x).cosh();
}
function clone(obj) {
  var i, p, ps;
  function Decimal2(v) {
    var e, i2, t2, x = this;
    if (!(x instanceof Decimal2)) return new Decimal2(v);
    x.constructor = Decimal2;
    if (isDecimalInstance(v)) {
      x.s = v.s;
      if (external) {
        if (!v.d || v.e > Decimal2.maxE) {
          x.e = NaN;
          x.d = null;
        } else if (v.e < Decimal2.minE) {
          x.e = 0;
          x.d = [0];
        } else {
          x.e = v.e;
          x.d = v.d.slice();
        }
      } else {
        x.e = v.e;
        x.d = v.d ? v.d.slice() : v.d;
      }
      return;
    }
    t2 = typeof v;
    if (t2 === "number") {
      if (v === 0) {
        x.s = 1 / v < 0 ? -1 : 1;
        x.e = 0;
        x.d = [0];
        return;
      }
      if (v < 0) {
        v = -v;
        x.s = -1;
      } else {
        x.s = 1;
      }
      if (v === ~~v && v < 1e7) {
        for (e = 0, i2 = v; i2 >= 10; i2 /= 10) e++;
        if (external) {
          if (e > Decimal2.maxE) {
            x.e = NaN;
            x.d = null;
          } else if (e < Decimal2.minE) {
            x.e = 0;
            x.d = [0];
          } else {
            x.e = e;
            x.d = [v];
          }
        } else {
          x.e = e;
          x.d = [v];
        }
        return;
      } else if (v * 0 !== 0) {
        if (!v) x.s = NaN;
        x.e = NaN;
        x.d = null;
        return;
      }
      return parseDecimal(x, v.toString());
    } else if (t2 !== "string") {
      throw Error(invalidArgument + v);
    }
    if ((i2 = v.charCodeAt(0)) === 45) {
      v = v.slice(1);
      x.s = -1;
    } else {
      if (i2 === 43) v = v.slice(1);
      x.s = 1;
    }
    return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
  }
  Decimal2.prototype = P;
  Decimal2.ROUND_UP = 0;
  Decimal2.ROUND_DOWN = 1;
  Decimal2.ROUND_CEIL = 2;
  Decimal2.ROUND_FLOOR = 3;
  Decimal2.ROUND_HALF_UP = 4;
  Decimal2.ROUND_HALF_DOWN = 5;
  Decimal2.ROUND_HALF_EVEN = 6;
  Decimal2.ROUND_HALF_CEIL = 7;
  Decimal2.ROUND_HALF_FLOOR = 8;
  Decimal2.EUCLID = 9;
  Decimal2.config = Decimal2.set = config;
  Decimal2.clone = clone;
  Decimal2.isDecimal = isDecimalInstance;
  Decimal2.abs = abs;
  Decimal2.acos = acos;
  Decimal2.acosh = acosh;
  Decimal2.add = add;
  Decimal2.asin = asin;
  Decimal2.asinh = asinh;
  Decimal2.atan = atan;
  Decimal2.atanh = atanh;
  Decimal2.atan2 = atan2;
  Decimal2.cbrt = cbrt;
  Decimal2.ceil = ceil;
  Decimal2.clamp = clamp;
  Decimal2.cos = cos;
  Decimal2.cosh = cosh;
  Decimal2.div = div;
  Decimal2.exp = exp;
  Decimal2.floor = floor;
  Decimal2.hypot = hypot;
  Decimal2.ln = ln;
  Decimal2.log = log;
  Decimal2.log10 = log10;
  Decimal2.log2 = log2;
  Decimal2.max = max;
  Decimal2.min = min;
  Decimal2.mod = mod;
  Decimal2.mul = mul;
  Decimal2.pow = pow;
  Decimal2.random = random;
  Decimal2.round = round;
  Decimal2.sign = sign;
  Decimal2.sin = sin;
  Decimal2.sinh = sinh;
  Decimal2.sqrt = sqrt;
  Decimal2.sub = sub;
  Decimal2.sum = sum;
  Decimal2.tan = tan;
  Decimal2.tanh = tanh;
  Decimal2.trunc = trunc;
  if (obj === void 0) obj = {};
  if (obj) {
    if (obj.defaults !== true) {
      ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
      for (i = 0; i < ps.length; ) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
    }
  }
  Decimal2.config(obj);
  return Decimal2;
}
function div(x, y) {
  return new this(x).div(y);
}
function exp(x) {
  return new this(x).exp();
}
function floor(x) {
  return finalise(x = new this(x), x.e + 1, 3);
}
function hypot() {
  var i, n2, t2 = new this(0);
  external = false;
  for (i = 0; i < arguments.length; ) {
    n2 = new this(arguments[i++]);
    if (!n2.d) {
      if (n2.s) {
        external = true;
        return new this(1 / 0);
      }
      t2 = n2;
    } else if (t2.d) {
      t2 = t2.plus(n2.times(n2));
    }
  }
  external = true;
  return t2.sqrt();
}
function isDecimalInstance(obj) {
  return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
}
function ln(x) {
  return new this(x).ln();
}
function log(x, y) {
  return new this(x).log(y);
}
function log2(x) {
  return new this(x).log(2);
}
function log10(x) {
  return new this(x).log(10);
}
function max() {
  return maxOrMin(this, arguments, "lt");
}
function min() {
  return maxOrMin(this, arguments, "gt");
}
function mod(x, y) {
  return new this(x).mod(y);
}
function mul(x, y) {
  return new this(x).mul(y);
}
function pow(x, y) {
  return new this(x).pow(y);
}
function random(sd) {
  var d, e, k, n2, i = 0, r = new this(1), rd = [];
  if (sd === void 0) sd = this.precision;
  else checkInt32(sd, 1, MAX_DIGITS);
  k = Math.ceil(sd / LOG_BASE);
  if (!this.crypto) {
    for (; i < k; ) rd[i++] = Math.random() * 1e7 | 0;
  } else if (crypto.getRandomValues) {
    d = crypto.getRandomValues(new Uint32Array(k));
    for (; i < k; ) {
      n2 = d[i];
      if (n2 >= 429e7) {
        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
      } else {
        rd[i++] = n2 % 1e7;
      }
    }
  } else if (crypto.randomBytes) {
    d = crypto.randomBytes(k *= 4);
    for (; i < k; ) {
      n2 = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
      if (n2 >= 214e7) {
        crypto.randomBytes(4).copy(d, i);
      } else {
        rd.push(n2 % 1e7);
        i += 4;
      }
    }
    i = k / 4;
  } else {
    throw Error(cryptoUnavailable);
  }
  k = rd[--i];
  sd %= LOG_BASE;
  if (k && sd) {
    n2 = mathpow(10, LOG_BASE - sd);
    rd[i] = (k / n2 | 0) * n2;
  }
  for (; rd[i] === 0; i--) rd.pop();
  if (i < 0) {
    e = 0;
    rd = [0];
  } else {
    e = -1;
    for (; rd[0] === 0; e -= LOG_BASE) rd.shift();
    for (k = 1, n2 = rd[0]; n2 >= 10; n2 /= 10) k++;
    if (k < LOG_BASE) e -= LOG_BASE - k;
  }
  r.e = e;
  r.d = rd;
  return r;
}
function round(x) {
  return finalise(x = new this(x), x.e + 1, this.rounding);
}
function sign(x) {
  x = new this(x);
  return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
}
function sin(x) {
  return new this(x).sin();
}
function sinh(x) {
  return new this(x).sinh();
}
function sqrt(x) {
  return new this(x).sqrt();
}
function sub(x, y) {
  return new this(x).sub(y);
}
function sum() {
  var i = 0, args = arguments, x = new this(args[i]);
  external = false;
  for (; x.s && ++i < args.length; ) x = x.plus(args[i]);
  external = true;
  return finalise(x, this.precision, this.rounding);
}
function tan(x) {
  return new this(x).tan();
}
function tanh(x) {
  return new this(x).tanh();
}
function trunc(x) {
  return finalise(x = new this(x), x.e + 1, 1);
}
P[Symbol.for("nodejs.util.inspect.custom")] = P.toString;
P[Symbol.toStringTag] = "Decimal";
var Decimal = P.constructor = clone(DEFAULTS);
LN10 = new Decimal(LN10);
PI = new Decimal(PI);
const props$N = {
  modelValue: {
    type: Number,
    default: 0
  },
  min: [String, Number],
  max: [String, Number],
  step: {
    type: [String, Number],
    default: 1
  },
  color: String,
  inputWidth: [String, Number],
  inputTextSize: [String, Number],
  buttonSize: [String, Number],
  elevation: {
    type: [Boolean, Number, String],
    default: true
  },
  decimalLength: [String, Number],
  disabled: Boolean,
  readonly: Boolean,
  disableIncrement: Boolean,
  disableDecrement: Boolean,
  disableInput: Boolean,
  lazyChange: Boolean,
  incrementButton: {
    type: Boolean,
    default: true
  },
  decrementButton: {
    type: Boolean,
    default: true
  },
  press: {
    type: Boolean,
    default: true
  },
  ripple: {
    type: Boolean,
    default: true
  },
  validateTrigger: {
    type: Array,
    default: () => ["onInputChange", "onLazyChange", "onIncrement", "onDecrement"]
  },
  rules: [Array, Function, Object],
  onBeforeChange: defineListenerProp(),
  onChange: defineListenerProp(),
  onIncrement: defineListenerProp(),
  onDecrement: defineListenerProp(),
  "onUpdate:modelValue": defineListenerProp()
};
const SPEED = 100;
const DELAY = 600;
const { name: name$O, n: n$V, classes: classes$K } = createNamespace("counter");
const _hoisted_1$n = ["inputmode", "readonly", "disabled"];
function __render__$T(_ctx, _cache) {
  const _component_var_icon = vue.resolveComponent("var-icon");
  const _component_var_button = vue.resolveComponent("var-button");
  const _component_var_form_details = vue.resolveComponent("var-form-details");
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.classes(_ctx.n(), _ctx.n("$--box")))
    },
    [
      vue.createElementVNode(
        "div",
        vue.mergeProps({
          class: _ctx.classes(
            _ctx.n("controller"),
            _ctx.formatElevation(_ctx.elevation, 2),
            [_ctx.disabled || _ctx.formDisabled, _ctx.n("--disabled")],
            [_ctx.errorMessage, _ctx.n("--error")]
          ),
          style: { background: _ctx.color }
        }, _ctx.$attrs),
        [
          vue.createVNode(_component_var_button, {
            class: vue.normalizeClass(
              _ctx.classes(
                _ctx.n("decrement-button"),
                [!_ctx.decrementButton, _ctx.n("--hidden")],
                [_ctx.disabled || _ctx.formDisabled, _ctx.n("--not-allowed")]
              )
            ),
            style: vue.normalizeStyle({
              width: _ctx.toSizeUnit(_ctx.buttonSize),
              height: _ctx.toSizeUnit(_ctx.buttonSize)
            }),
            round: "",
            "var-counter-cover": "",
            ripple: _ctx.ripple && _ctx.decrementButton && !_ctx.disabled && !_ctx.formDisabled && !_ctx.readonly && !_ctx.formReadonly && !_ctx.disableDecrement && !_ctx.isMin,
            onClick: _ctx.decrement,
            onTouchstart: _ctx.pressDecrement,
            onTouchend: _ctx.releaseDecrement,
            onTouchcancel: _ctx.releaseDecrement
          }, {
            default: vue.withCtx(() => [
              vue.createVNode(_component_var_icon, { name: "minus" })
            ]),
            _: 1
            /* STABLE */
          }, 8, ["class", "style", "ripple", "onClick", "onTouchstart", "onTouchend", "onTouchcancel"]),
          vue.withDirectives(vue.createElementVNode("input", {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.inputValue = $event),
            class: vue.normalizeClass(_ctx.classes(_ctx.n("input"), [_ctx.disabled || _ctx.formDisabled, _ctx.n("--not-allowed")])),
            style: vue.normalizeStyle({
              width: _ctx.toSizeUnit(_ctx.inputWidth),
              fontSize: _ctx.toSizeUnit(_ctx.inputTextSize)
            }),
            inputmode: _ctx.toNumber(_ctx.decimalLength) === 0 ? "numeric" : "decimal",
            readonly: _ctx.readonly || _ctx.formReadonly,
            disabled: _ctx.disabled || _ctx.formDisabled || _ctx.disableInput,
            onChange: _cache[1] || (_cache[1] = (...args) => _ctx.handleChange && _ctx.handleChange(...args))
          }, null, 46, _hoisted_1$n), [
            [vue.vModelText, _ctx.inputValue]
          ]),
          vue.createVNode(_component_var_button, {
            class: vue.normalizeClass(
              _ctx.classes(
                _ctx.n("increment-button"),
                [!_ctx.incrementButton, _ctx.n("--hidden")],
                [_ctx.disabled || _ctx.formDisabled, _ctx.n("--not-allowed")]
              )
            ),
            style: vue.normalizeStyle({
              width: _ctx.toSizeUnit(_ctx.buttonSize),
              height: _ctx.toSizeUnit(_ctx.buttonSize)
            }),
            round: "",
            "var-counter-cover": "",
            ripple: _ctx.ripple && _ctx.incrementButton && !_ctx.disabled && !_ctx.formDisabled && !_ctx.readonly && !_ctx.formReadonly && !_ctx.disableIncrement && !_ctx.isMax,
            onClick: _ctx.increment,
            onTouchstart: _ctx.pressIncrement,
            onTouchend: _ctx.releaseIncrement,
            onTouchcancel: _ctx.releaseIncrement
          }, {
            default: vue.withCtx(() => [
              vue.createVNode(_component_var_icon, { name: "plus" })
            ]),
            _: 1
            /* STABLE */
          }, 8, ["class", "style", "ripple", "onClick", "onTouchstart", "onTouchend", "onTouchcancel"])
        ],
        16
        /* FULL_PROPS */
      ),
      vue.createVNode(_component_var_form_details, { "error-message": _ctx.errorMessage }, null, 8, ["error-message"])
    ],
    2
    /* CLASS */
  );
}
const __sfc__$W = vue.defineComponent({
  name: name$O,
  components: {
    VarButton: stdin_default$5t,
    VarIcon: stdin_default$5_,
    VarFormDetails: stdin_default$5R
  },
  directives: { Ripple: stdin_default$63 },
  inheritAttrs: false,
  props: props$N,
  setup(props2) {
    const inputValue = vue.ref("");
    const { bindForm, form } = useForm();
    const {
      errorMessage,
      validateWithTrigger: vt,
      validate: v,
      // expose
      resetValidation
    } = useValidation();
    const { readonly: formReadonly, disabled: formDisabled } = form != null ? form : {};
    const isMax = vue.computed(() => {
      const { max: max2, modelValue } = props2;
      return max2 != null && toNumber(modelValue) >= toNumber(max2);
    });
    const isMin = vue.computed(() => {
      const { min: min2, modelValue } = props2;
      return min2 != null && toNumber(modelValue) <= toNumber(min2);
    });
    let incrementTimer;
    let decrementTimer;
    let incrementDelayTimer;
    let decrementDelayTimer;
    const counterProvider = {
      reset,
      validate,
      resetValidation
    };
    call(bindForm, counterProvider);
    vue.watch(
      () => props2.modelValue,
      (newValue) => {
        setNormalizedValue(normalizeValue(String(newValue)));
        call(props2.onChange, toNumber(newValue));
      }
    );
    setNormalizedValue(normalizeValue(String(props2.modelValue)));
    function validate() {
      return v(props2.rules, props2.modelValue);
    }
    function validateWithTrigger(trigger) {
      vue.nextTick(() => {
        const { validateTrigger, rules, modelValue } = props2;
        vt(validateTrigger, trigger, rules, modelValue);
      });
    }
    function reset() {
      const { min: min2 } = props2;
      call(props2["onUpdate:modelValue"], min2 != null ? toNumber(min2) : 0);
      resetValidation();
    }
    function normalizeValue(value) {
      const { decimalLength, max: max2, min: min2 } = props2;
      let num = toNumber(value);
      if (max2 != null && num > toNumber(max2)) {
        num = toNumber(max2);
      }
      if (min2 != null && num < toNumber(min2)) {
        num = toNumber(min2);
      }
      value = String(num);
      if (decimalLength != null) {
        value = num.toFixed(toNumber(decimalLength));
      }
      return value;
    }
    function handleChange(event) {
      const { lazyChange, onBeforeChange } = props2;
      const { value } = event.target;
      const normalizedValue = normalizeValue(value);
      lazyChange ? call(onBeforeChange, toNumber(normalizedValue), change) : setNormalizedValue(normalizedValue);
      validateWithTrigger("onInputChange");
    }
    function decrement() {
      const {
        disabled,
        readonly,
        disableDecrement,
        decrementButton,
        lazyChange,
        step,
        modelValue,
        onDecrement,
        onBeforeChange
      } = props2;
      if ((formDisabled == null ? void 0 : formDisabled.value) || (formReadonly == null ? void 0 : formReadonly.value) || disabled || readonly || disableDecrement || !decrementButton) {
        return;
      }
      if (isMin.value) {
        return;
      }
      const value = new Decimal(toNumber(modelValue)).minus(new Decimal(toNumber(step))).toString();
      const normalizedValue = normalizeValue(value);
      const normalizedValueNum = toNumber(normalizedValue);
      call(onDecrement, normalizedValueNum);
      if (lazyChange) {
        call(onBeforeChange, normalizedValueNum, change);
      } else {
        setNormalizedValue(normalizedValue);
        validateWithTrigger("onDecrement");
      }
    }
    function increment() {
      const {
        disabled,
        readonly,
        disableIncrement,
        incrementButton,
        lazyChange,
        step,
        modelValue,
        onIncrement,
        onBeforeChange
      } = props2;
      if ((formDisabled == null ? void 0 : formDisabled.value) || (formReadonly == null ? void 0 : formReadonly.value) || disabled || readonly || disableIncrement || !incrementButton) {
        return;
      }
      if (isMax.value) {
        return;
      }
      const value = new Decimal(toNumber(modelValue)).plus(new Decimal(toNumber(step))).toString();
      const normalizedValue = normalizeValue(value);
      const normalizedValueNum = toNumber(normalizedValue);
      call(onIncrement, normalizedValueNum);
      if (lazyChange) {
        call(onBeforeChange, normalizedValueNum, change);
      } else {
        setNormalizedValue(normalizedValue);
        validateWithTrigger("onIncrement");
      }
    }
    function pressDecrement() {
      const { press, lazyChange } = props2;
      if (!press || lazyChange) {
        return;
      }
      decrementDelayTimer = window.setTimeout(() => {
        continuedDecrement();
      }, DELAY);
    }
    function pressIncrement() {
      const { press, lazyChange } = props2;
      if (!press || lazyChange) {
        return;
      }
      incrementDelayTimer = window.setTimeout(() => {
        continuedIncrement();
      }, DELAY);
    }
    function releaseDecrement() {
      decrementTimer && clearTimeout(decrementTimer);
      decrementDelayTimer && clearTimeout(decrementDelayTimer);
    }
    function releaseIncrement() {
      incrementTimer && clearTimeout(incrementTimer);
      incrementDelayTimer && clearTimeout(incrementDelayTimer);
    }
    function continuedIncrement() {
      incrementTimer = window.setTimeout(() => {
        increment();
        continuedIncrement();
      }, SPEED);
    }
    function continuedDecrement() {
      decrementTimer = window.setTimeout(() => {
        decrement();
        continuedDecrement();
      }, SPEED);
    }
    function setNormalizedValue(normalizedValue) {
      inputValue.value = normalizedValue;
      const normalizedValueNum = toNumber(normalizedValue);
      call(props2["onUpdate:modelValue"], normalizedValueNum);
    }
    function change(value) {
      setNormalizedValue(normalizeValue(String(value)));
      validateWithTrigger("onLazyChange");
    }
    return {
      inputValue,
      errorMessage,
      formDisabled,
      formReadonly,
      isMax,
      isMin,
      n: n$V,
      classes: classes$K,
      formatElevation,
      validate,
      reset,
      resetValidation,
      handleChange,
      decrement,
      increment,
      pressDecrement,
      pressIncrement,
      releaseDecrement,
      releaseIncrement,
      toSizeUnit,
      toNumber
    };
  }
});
__sfc__$W.render = __render__$T;
var stdin_default$4U = __sfc__$W;
withInstall(stdin_default$4U);
withPropsDefaultsSetter(stdin_default$4U, props$N);
const _CounterComponent = stdin_default$4U;
var stdin_default$4T = stdin_default$4U;
var SECONDS_A_MINUTE = 60;
var SECONDS_A_HOUR = SECONDS_A_MINUTE * 60;
var SECONDS_A_DAY = SECONDS_A_HOUR * 24;
var SECONDS_A_WEEK = SECONDS_A_DAY * 7;
var MILLISECONDS_A_SECOND = 1e3;
var MILLISECONDS_A_MINUTE = SECONDS_A_MINUTE * MILLISECONDS_A_SECOND;
var MILLISECONDS_A_HOUR = SECONDS_A_HOUR * MILLISECONDS_A_SECOND;
var MILLISECONDS_A_DAY = SECONDS_A_DAY * MILLISECONDS_A_SECOND;
var MILLISECONDS_A_WEEK = SECONDS_A_WEEK * MILLISECONDS_A_SECOND;
var MS = "millisecond";
var S = "second";
var MIN$1 = "minute";
var H = "hour";
var D = "day";
var W = "week";
var M = "month";
var Q = "quarter";
var Y = "year";
var DATE = "date";
var FORMAT_DEFAULT = "YYYY-MM-DDTHH:mm:ssZ";
var INVALID_DATE_STRING = "Invalid Date";
var REGEX_PARSE = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/;
var REGEX_FORMAT = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g;
const en = {
  name: "en",
  weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
  months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_")
};
var padStart = function padStart2(string, length, pad) {
  var s = String(string);
  if (!s || s.length >= length) return string;
  return "" + Array(length + 1 - s.length).join(pad) + string;
};
var padZoneStr = function padZoneStr2(instance) {
  var negMinutes = -instance.utcOffset();
  var minutes = Math.abs(negMinutes);
  var hourOffset = Math.floor(minutes / 60);
  var minuteOffset = minutes % 60;
  return (negMinutes <= 0 ? "+" : "-") + padStart(hourOffset, 2, "0") + ":" + padStart(minuteOffset, 2, "0");
};
var monthDiff = function monthDiff2(a, b) {
  if (a.date() < b.date()) return -monthDiff2(b, a);
  var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month());
  var anchor = a.clone().add(wholeMonthDiff, M);
  var c = b - anchor < 0;
  var anchor2 = a.clone().add(wholeMonthDiff + (c ? -1 : 1), M);
  return +(-(wholeMonthDiff + (b - anchor) / (c ? anchor - anchor2 : anchor2 - anchor)) || 0);
};
var absFloor = function absFloor2(n2) {
  return n2 < 0 ? Math.ceil(n2) || 0 : Math.floor(n2);
};
var prettyUnit = function prettyUnit2(u) {
  var special = {
    M,
    y: Y,
    w: W,
    d: D,
    D: DATE,
    h: H,
    m: MIN$1,
    s: S,
    ms: MS,
    Q
  };
  return special[u] || String(u || "").toLowerCase().replace(/s$/, "");
};
var isUndefined = function isUndefined2(s) {
  return s === void 0;
};
const U = {
  s: padStart,
  z: padZoneStr,
  m: monthDiff,
  a: absFloor,
  p: prettyUnit,
  u: isUndefined
};
var L = "en";
var Ls = {};
Ls[L] = en;
var isDayjs = function isDayjs2(d) {
  return d instanceof Dayjs;
};
var parseLocale = function parseLocale2(preset, object, isLocal) {
  var l;
  if (!preset) return L;
  if (typeof preset === "string") {
    var presetLower = preset.toLowerCase();
    if (Ls[presetLower]) {
      l = presetLower;
    }
    if (object) {
      Ls[presetLower] = object;
      l = presetLower;
    }
    var presetSplit = preset.split("-");
    if (!l && presetSplit.length > 1) {
      return parseLocale2(presetSplit[0]);
    }
  } else {
    var name2 = preset.name;
    Ls[name2] = preset;
    l = name2;
  }
  if (!isLocal && l) L = l;
  return l || !isLocal && L;
};
var dayjs = function dayjs2(date, c) {
  if (isDayjs(date)) {
    return date.clone();
  }
  var cfg = typeof c === "object" ? c : {};
  cfg.date = date;
  cfg.args = arguments;
  return new Dayjs(cfg);
};
var wrapper = function wrapper2(date, instance) {
  return dayjs(date, {
    locale: instance.$L,
    utc: instance.$u,
    x: instance.$x,
    $offset: instance.$offset
    // todo: refactor; do not use this.$offset in you code
  });
};
var Utils = U;
Utils.l = parseLocale;
Utils.i = isDayjs;
Utils.w = wrapper;
var parseDate = function parseDate2(cfg) {
  var date = cfg.date, utc = cfg.utc;
  if (date === null) return /* @__PURE__ */ new Date(NaN);
  if (Utils.u(date)) return /* @__PURE__ */ new Date();
  if (date instanceof Date) return new Date(date);
  if (typeof date === "string" && !/Z$/i.test(date)) {
    var d = date.match(REGEX_PARSE);
    if (d) {
      var m = d[2] - 1 || 0;
      var ms = (d[7] || "0").substring(0, 3);
      if (utc) {
        return new Date(Date.UTC(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms));
      }
      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);
    }
  }
  return new Date(date);
};
var Dayjs = /* @__PURE__ */ function() {
  function Dayjs2(cfg) {
    this.$L = parseLocale(cfg.locale, null, true);
    this.parse(cfg);
  }
  var _proto = Dayjs2.prototype;
  _proto.parse = function parse(cfg) {
    this.$d = parseDate(cfg);
    this.$x = cfg.x || {};
    this.init();
  };
  _proto.init = function init() {
    var $d = this.$d;
    this.$y = $d.getFullYear();
    this.$M = $d.getMonth();
    this.$D = $d.getDate();
    this.$W = $d.getDay();
    this.$H = $d.getHours();
    this.$m = $d.getMinutes();
    this.$s = $d.getSeconds();
    this.$ms = $d.getMilliseconds();
  };
  _proto.$utils = function $utils() {
    return Utils;
  };
  _proto.isValid = function isValid() {
    return !(this.$d.toString() === INVALID_DATE_STRING);
  };
  _proto.isSame = function isSame(that, units) {
    var other = dayjs(that);
    return this.startOf(units) <= other && other <= this.endOf(units);
  };
  _proto.isAfter = function isAfter(that, units) {
    return dayjs(that) < this.startOf(units);
  };
  _proto.isBefore = function isBefore(that, units) {
    return this.endOf(units) < dayjs(that);
  };
  _proto.$g = function $g(input, get, set) {
    if (Utils.u(input)) return this[get];
    return this.set(set, input);
  };
  _proto.unix = function unix() {
    return Math.floor(this.valueOf() / 1e3);
  };
  _proto.valueOf = function valueOf() {
    return this.$d.getTime();
  };
  _proto.startOf = function startOf(units, _startOf) {
    var _this = this;
    var isStartOf = !Utils.u(_startOf) ? _startOf : true;
    var unit = Utils.p(units);
    var instanceFactory = function instanceFactory2(d, m) {
      var ins = Utils.w(_this.$u ? Date.UTC(_this.$y, m, d) : new Date(_this.$y, m, d), _this);
      return isStartOf ? ins : ins.endOf(D);
    };
    var instanceFactorySet = function instanceFactorySet2(method, slice) {
      var argumentStart = [0, 0, 0, 0];
      var argumentEnd = [23, 59, 59, 999];
      return Utils.w(_this.toDate()[method].apply(
        // eslint-disable-line prefer-spread
        _this.toDate("s"),
        (isStartOf ? argumentStart : argumentEnd).slice(slice)
      ), _this);
    };
    var $W = this.$W, $M = this.$M, $D = this.$D;
    var utcPad = "set" + (this.$u ? "UTC" : "");
    switch (unit) {
      case Y:
        return isStartOf ? instanceFactory(1, 0) : instanceFactory(31, 11);
      case M:
        return isStartOf ? instanceFactory(1, $M) : instanceFactory(0, $M + 1);
      case W: {
        var weekStart = this.$locale().weekStart || 0;
        var gap = ($W < weekStart ? $W + 7 : $W) - weekStart;
        return instanceFactory(isStartOf ? $D - gap : $D + (6 - gap), $M);
      }
      case D:
      case DATE:
        return instanceFactorySet(utcPad + "Hours", 0);
      case H:
        return instanceFactorySet(utcPad + "Minutes", 1);
      case MIN$1:
        return instanceFactorySet(utcPad + "Seconds", 2);
      case S:
        return instanceFactorySet(utcPad + "Milliseconds", 3);
      default:
        return this.clone();
    }
  };
  _proto.endOf = function endOf(arg) {
    return this.startOf(arg, false);
  };
  _proto.$set = function $set(units, _int) {
    var _C$D$C$DATE$C$M$C$Y$C;
    var unit = Utils.p(units);
    var utcPad = "set" + (this.$u ? "UTC" : "");
    var name2 = (_C$D$C$DATE$C$M$C$Y$C = {}, _C$D$C$DATE$C$M$C$Y$C[D] = utcPad + "Date", _C$D$C$DATE$C$M$C$Y$C[DATE] = utcPad + "Date", _C$D$C$DATE$C$M$C$Y$C[M] = utcPad + "Month", _C$D$C$DATE$C$M$C$Y$C[Y] = utcPad + "FullYear", _C$D$C$DATE$C$M$C$Y$C[H] = utcPad + "Hours", _C$D$C$DATE$C$M$C$Y$C[MIN$1] = utcPad + "Minutes", _C$D$C$DATE$C$M$C$Y$C[S] = utcPad + "Seconds", _C$D$C$DATE$C$M$C$Y$C[MS] = utcPad + "Milliseconds", _C$D$C$DATE$C$M$C$Y$C)[unit];
    var arg = unit === D ? this.$D + (_int - this.$W) : _int;
    if (unit === M || unit === Y) {
      var date = this.clone().set(DATE, 1);
      date.$d[name2](arg);
      date.init();
      this.$d = date.set(DATE, Math.min(this.$D, date.daysInMonth())).$d;
    } else if (name2) this.$d[name2](arg);
    this.init();
    return this;
  };
  _proto.set = function set(string, _int2) {
    return this.clone().$set(string, _int2);
  };
  _proto.get = function get(unit) {
    return this[Utils.p(unit)]();
  };
  _proto.add = function add2(number, units) {
    var _this2 = this, _C$MIN$C$H$C$S$unit;
    number = Number(number);
    var unit = Utils.p(units);
    var instanceFactorySet = function instanceFactorySet2(n2) {
      var d = dayjs(_this2);
      return Utils.w(d.date(d.date() + Math.round(n2 * number)), _this2);
    };
    if (unit === M) {
      return this.set(M, this.$M + number);
    }
    if (unit === Y) {
      return this.set(Y, this.$y + number);
    }
    if (unit === D) {
      return instanceFactorySet(1);
    }
    if (unit === W) {
      return instanceFactorySet(7);
    }
    var step = (_C$MIN$C$H$C$S$unit = {}, _C$MIN$C$H$C$S$unit[MIN$1] = MILLISECONDS_A_MINUTE, _C$MIN$C$H$C$S$unit[H] = MILLISECONDS_A_HOUR, _C$MIN$C$H$C$S$unit[S] = MILLISECONDS_A_SECOND, _C$MIN$C$H$C$S$unit)[unit] || 1;
    var nextTimeStamp = this.$d.getTime() + number * step;
    return Utils.w(nextTimeStamp, this);
  };
  _proto.subtract = function subtract(number, string) {
    return this.add(number * -1, string);
  };
  _proto.format = function format2(formatStr) {
    var _this3 = this;
    var locale = this.$locale();
    if (!this.isValid()) return locale.invalidDate || INVALID_DATE_STRING;
    var str = formatStr || FORMAT_DEFAULT;
    var zoneStr = Utils.z(this);
    var $H = this.$H, $m = this.$m, $M = this.$M;
    var weekdays = locale.weekdays, months = locale.months, meridiem = locale.meridiem;
    var getShort = function getShort2(arr, index, full, length) {
      return arr && (arr[index] || arr(_this3, str)) || full[index].slice(0, length);
    };
    var get$H = function get$H2(num) {
      return Utils.s($H % 12 || 12, num, "0");
    };
    var meridiemFunc = meridiem || function(hour, minute, isLowercase) {
      var m = hour < 12 ? "AM" : "PM";
      return isLowercase ? m.toLowerCase() : m;
    };
    var matches = {
      YY: String(this.$y).slice(-2),
      YYYY: this.$y,
      M: $M + 1,
      MM: Utils.s($M + 1, 2, "0"),
      MMM: getShort(locale.monthsShort, $M, months, 3),
      MMMM: getShort(months, $M),
      D: this.$D,
      DD: Utils.s(this.$D, 2, "0"),
      d: String(this.$W),
      dd: getShort(locale.weekdaysMin, this.$W, weekdays, 2),
      ddd: getShort(locale.weekdaysShort, this.$W, weekdays, 3),
      dddd: weekdays[this.$W],
      H: String($H),
      HH: Utils.s($H, 2, "0"),
      h: get$H(1),
      hh: get$H(2),
      a: meridiemFunc($H, $m, true),
      A: meridiemFunc($H, $m, false),
      m: String($m),
      mm: Utils.s($m, 2, "0"),
      s: String(this.$s),
      ss: Utils.s(this.$s, 2, "0"),
      SSS: Utils.s(this.$ms, 3, "0"),
      Z: zoneStr
      // 'ZZ' logic below
    };
    return str.replace(REGEX_FORMAT, function(match, $1) {
      return $1 || matches[match] || zoneStr.replace(":", "");
    });
  };
  _proto.utcOffset = function utcOffset() {
    return -Math.round(this.$d.getTimezoneOffset() / 15) * 15;
  };
  _proto.diff = function diff2(input, units, _float) {
    var _C$Y$C$M$C$Q$C$W$C$D$;
    var unit = Utils.p(units);
    var that = dayjs(input);
    var zoneDelta = (that.utcOffset() - this.utcOffset()) * MILLISECONDS_A_MINUTE;
    var diff3 = this - that;
    var result = Utils.m(this, that);
    result = (_C$Y$C$M$C$Q$C$W$C$D$ = {}, _C$Y$C$M$C$Q$C$W$C$D$[Y] = result / 12, _C$Y$C$M$C$Q$C$W$C$D$[M] = result, _C$Y$C$M$C$Q$C$W$C$D$[Q] = result / 3, _C$Y$C$M$C$Q$C$W$C$D$[W] = (diff3 - zoneDelta) / MILLISECONDS_A_WEEK, _C$Y$C$M$C$Q$C$W$C$D$[D] = (diff3 - zoneDelta) / MILLISECONDS_A_DAY, _C$Y$C$M$C$Q$C$W$C$D$[H] = diff3 / MILLISECONDS_A_HOUR, _C$Y$C$M$C$Q$C$W$C$D$[MIN$1] = diff3 / MILLISECONDS_A_MINUTE, _C$Y$C$M$C$Q$C$W$C$D$[S] = diff3 / MILLISECONDS_A_SECOND, _C$Y$C$M$C$Q$C$W$C$D$)[unit] || diff3;
    return _float ? result : Utils.a(result);
  };
  _proto.daysInMonth = function daysInMonth() {
    return this.endOf(M).$D;
  };
  _proto.$locale = function $locale() {
    return Ls[this.$L];
  };
  _proto.locale = function locale(preset, object) {
    if (!preset) return this.$L;
    var that = this.clone();
    var nextLocaleName = parseLocale(preset, object, true);
    if (nextLocaleName) that.$L = nextLocaleName;
    return that;
  };
  _proto.clone = function clone2() {
    return Utils.w(this.$d, this);
  };
  _proto.toDate = function toDate() {
    return new Date(this.valueOf());
  };
  _proto.toJSON = function toJSON() {
    return this.isValid() ? this.toISOString() : null;
  };
  _proto.toISOString = function toISOString() {
    return this.$d.toISOString();
  };
  _proto.toString = function toString() {
    return this.$d.toUTCString();
  };
  return Dayjs2;
}();
var proto = Dayjs.prototype;
dayjs.prototype = proto;
[["$ms", MS], ["$s", S], ["$m", MIN$1], ["$H", H], ["$W", D], ["$M", M], ["$y", Y], ["$D", DATE]].forEach(function(g) {
  proto[g[1]] = function(input) {
    return this.$g(input, g[0], g[1]);
  };
});
dayjs.extend = function(plugin, option) {
  if (!plugin.$i) {
    plugin(option, Dayjs, dayjs);
    plugin.$i = true;
  }
  return dayjs;
};
dayjs.locale = parseLocale;
dayjs.isDayjs = isDayjs;
dayjs.unix = function(timestamp) {
  return dayjs(timestamp * 1e3);
};
dayjs.en = Ls[L];
dayjs.Ls = Ls;
dayjs.p = {};
const MONTH_LIST = ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
const WEEK_HEADER = ["0", "1", "2", "3", "4", "5", "6"];
const props$M = {
  modelValue: [String, Array],
  type: {
    type: String,
    default: "date"
  },
  hint: String,
  allowedDates: Function,
  color: String,
  titleColor: String,
  elevation: {
    type: [Boolean, Number, String],
    default: false
  },
  buttonElevation: {
    type: [Boolean, Number, String],
    default: true
  },
  firstDayOfWeek: {
    type: [String, Number],
    default: 0
  },
  min: String,
  max: String,
  showCurrent: {
    type: Boolean,
    default: true
  },
  readonly: Boolean,
  multiple: Boolean,
  range: Boolean,
  touchable: {
    type: Boolean,
    default: true
  },
  onPreview: defineListenerProp(),
  onChange: defineListenerProp(),
  "onUpdate:modelValue": defineListenerProp()
};
const isSameOrAfter = function(o, c) {
  c.prototype.isSameOrAfter = function(that, units) {
    return this.isSame(that, units) || this.isAfter(that, units);
  };
};
const isSameOrBefore = function(o, c) {
  c.prototype.isSameOrBefore = function(that, units) {
    return this.isSame(that, units) || this.isBefore(that, units);
  };
};
const { n: n$U } = createNamespace("date-picker-header");
function __render__$S(_ctx, _cache) {
  const _component_var_icon = vue.resolveComponent("var-icon");
  const _component_var_button = vue.resolveComponent("var-button");
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.n())
    },
    [
      vue.createVNode(_component_var_button, {
        class: vue.normalizeClass(_ctx.n("arrow")),
        "var-date-picker-header-cover": "",
        round: "",
        text: "",
        disabled: _ctx.disabled.left,
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.checkDate("prev"))
      }, {
        default: vue.withCtx(() => [
          vue.createVNode(_component_var_icon, { name: "chevron-left" })
        ]),
        _: 1
        /* STABLE */
      }, 8, ["class", "disabled"]),
      vue.createElementVNode(
        "div",
        {
          class: vue.normalizeClass(_ctx.n("value")),
          onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("check-panel"))
        },
        [
          vue.createVNode(vue.Transition, {
            name: `var-date-picker${_ctx.reverse ? "-reverse" : ""}-translatex`
          }, {
            default: vue.withCtx(() => [
              (vue.openBlock(), vue.createElementBlock(
                "div",
                { key: _ctx.showDate },
                vue.toDisplayString(_ctx.showDate),
                1
                /* TEXT */
              ))
            ]),
            _: 1
            /* STABLE */
          }, 8, ["name"])
        ],
        2
        /* CLASS */
      ),
      vue.createVNode(_component_var_button, {
        class: vue.normalizeClass(_ctx.n("arrow")),
        "var-date-picker-header-cover": "",
        round: "",
        text: "",
        disabled: _ctx.disabled.right,
        onClick: _cache[2] || (_cache[2] = ($event) => _ctx.checkDate("next"))
      }, {
        default: vue.withCtx(() => [
          vue.createVNode(_component_var_icon, { name: "chevron-right" })
        ]),
        _: 1
        /* STABLE */
      }, 8, ["class", "disabled"])
    ],
    2
    /* CLASS */
  );
}
const __sfc__$V = vue.defineComponent({
  name: "PanelHeader",
  components: {
    VarButton: stdin_default$5t,
    VarIcon: stdin_default$5_
  },
  props: {
    date: {
      type: Object,
      required: true
    },
    type: {
      type: String,
      default: "date"
    },
    disabled: {
      type: Object,
      required: true
    }
  },
  emits: ["check-panel", "check-date"],
  setup(props2, { emit }) {
    const reverse = vue.ref(false);
    const forwardOrBackNum = vue.ref(0);
    const { t: pt } = injectLocaleProvider();
    const showDate = vue.computed(() => {
      var _a;
      const { date, type } = props2;
      const { previewMonth, previewYear } = date;
      if (type === "year") {
        return previewYear;
      }
      if (type === "month") {
        return toNumber(previewYear) + forwardOrBackNum.value;
      }
      const monthName = (_a = (pt || t)("datePickerMonthDict")) == null ? void 0 : _a[previewMonth].name;
      return (pt || t)("lang") === "zh-CN" ? `${previewYear} ${monthName}` : `${monthName} ${previewYear}`;
    });
    const checkDate = (checkType) => {
      if (checkType === "prev" && props2.disabled.left || checkType === "next" && props2.disabled.right) {
        return;
      }
      emit("check-date", checkType);
      reverse.value = checkType === "prev";
      forwardOrBackNum.value += checkType === "prev" ? -1 : 1;
    };
    vue.watch(
      () => props2.date,
      () => {
        forwardOrBackNum.value = 0;
      }
    );
    return {
      n: n$U,
      reverse,
      showDate,
      checkDate
    };
  }
});
__sfc__$V.render = __render__$S;
var stdin_default$4S = __sfc__$V;
var __defProp$i = Object.defineProperty;
var __getOwnPropSymbols$i = Object.getOwnPropertySymbols;
var __hasOwnProp$i = Object.prototype.hasOwnProperty;
var __propIsEnum$i = Object.prototype.propertyIsEnumerable;
var __defNormalProp$i = (obj, key3, value) => key3 in obj ? __defProp$i(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$i = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$i.call(b, prop))
      __defNormalProp$i(a, prop, b[prop]);
  if (__getOwnPropSymbols$i)
    for (var prop of __getOwnPropSymbols$i(b)) {
      if (__propIsEnum$i.call(b, prop))
        __defNormalProp$i(a, prop, b[prop]);
    }
  return a;
};
dayjs.extend(isSameOrBefore);
dayjs.extend(isSameOrAfter);
const { n: n$T, classes: classes$J } = createNamespace("day-picker");
const { n: nDate$2 } = createNamespace("date-picker");
function __render__$R(_ctx, _cache) {
  const _component_panel_header = vue.resolveComponent("panel-header");
  const _component_var_button = vue.resolveComponent("var-button");
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.n())
    },
    [
      vue.createElementVNode(
        "div",
        {
          class: vue.normalizeClass(_ctx.n("content"))
        },
        [
          vue.createVNode(_component_panel_header, {
            ref: "headerEl",
            type: "day",
            date: _ctx.preview,
            disabled: _ctx.panelBtnDisabled,
            onCheckPanel: _ctx.clickMonth,
            onCheckDate: _ctx.checkDate
          }, null, 8, ["date", "disabled", "onCheckPanel", "onCheckDate"]),
          vue.createVNode(vue.Transition, {
            name: `${_ctx.nDate()}${_ctx.reverse ? "-reverse" : ""}-translatex`
          }, {
            default: vue.withCtx(() => [
              (vue.openBlock(), vue.createElementBlock("div", { key: _ctx.panelKey }, [
                vue.createElementVNode(
                  "ul",
                  {
                    class: vue.normalizeClass(_ctx.n("head"))
                  },
                  [
                    (vue.openBlock(true), vue.createElementBlock(
                      vue.Fragment,
                      null,
                      vue.renderList(_ctx.sortWeekList, (week) => {
                        return vue.openBlock(), vue.createElementBlock(
                          "li",
                          { key: week },
                          vue.toDisplayString(_ctx.getDayAbbr(week)),
                          1
                          /* TEXT */
                        );
                      }),
                      128
                      /* KEYED_FRAGMENT */
                    ))
                  ],
                  2
                  /* CLASS */
                ),
                vue.createElementVNode(
                  "ul",
                  {
                    class: vue.normalizeClass(_ctx.n("body"))
                  },
                  [
                    (vue.openBlock(true), vue.createElementBlock(
                      vue.Fragment,
                      null,
                      vue.renderList(_ctx.days, (day, index) => {
                        return vue.openBlock(), vue.createElementBlock("li", { key: index }, [
                          vue.createVNode(_component_var_button, vue.mergeProps({
                            type: "primary",
                            "var-day-picker-cover": "",
                            round: "",
                            ripple: false,
                            elevation: _ctx.componentProps.buttonElevation,
                            ref_for: true
                          }, __spreadValues$i({}, _ctx.buttonProps(day)), {
                            onClick: (event) => _ctx.chooseDay(day, event)
                          }), {
                            default: vue.withCtx(() => [
                              vue.createTextVNode(
                                vue.toDisplayString(_ctx.filterDay(day)),
                                1
                                /* TEXT */
                              )
                            ]),
                            _: 2
                            /* DYNAMIC */
                          }, 1040, ["elevation", "onClick"])
                        ]);
                      }),
                      128
                      /* KEYED_FRAGMENT */
                    ))
                  ],
                  2
                  /* CLASS */
                )
              ]))
            ]),
            _: 1
            /* STABLE */
          }, 8, ["name"])
        ],
        2
        /* CLASS */
      )
    ],
    2
    /* CLASS */
  );
}
const __sfc__$U = vue.defineComponent({
  name: "DayPickerPanel",
  components: {
    VarButton: stdin_default$5t,
    PanelHeader: stdin_default$4S
  },
  props: {
    choose: {
      type: Object,
      required: true
    },
    preview: {
      type: Object,
      required: true
    },
    current: {
      type: String,
      required: true
    },
    clickMonth: {
      type: Function,
      required: true
    },
    componentProps: {
      type: Object,
      required: true
    }
  },
  emits: ["check-preview", "choose-day"],
  setup(props2, { emit }) {
    const [currentYear, currentMonth, currentDay] = props2.current.split("-");
    const days = vue.ref([]);
    const reverse = vue.ref(false);
    const panelKey = vue.ref(0);
    const headerEl = vue.ref(null);
    const panelBtnDisabled = vue.reactive({
      left: false,
      right: false
    });
    const { t: pt } = injectLocaleProvider();
    const isCurrent = vue.computed(
      () => props2.preview.previewYear === currentYear && props2.preview.previewMonth === currentMonth
    );
    const isSame = vue.computed(
      () => props2.choose.chooseYear === props2.preview.previewYear && props2.choose.chooseMonth === props2.preview.previewMonth
    );
    const sortWeekList = vue.computed(() => {
      const index = WEEK_HEADER.findIndex((week) => week === props2.componentProps.firstDayOfWeek);
      if (index === -1 || index === 0) {
        return WEEK_HEADER;
      }
      return [...WEEK_HEADER.slice(index), ...WEEK_HEADER.slice(0, index)];
    });
    const getDayAbbr = (key3) => {
      var _a, _b;
      return (_b = (_a = (pt || t)("datePickerWeekDict")) == null ? void 0 : _a[key3].abbr) != null ? _b : "";
    };
    const filterDay = (day) => day > 0 ? day : "";
    const initDate = () => {
      const {
        preview: { previewMonth, previewYear }
      } = props2;
      const monthNum = dayjs(`${previewYear}-${previewMonth}`).daysInMonth();
      const firstDayToWeek = dayjs(`${previewYear}-${previewMonth}-01`).day();
      const index = sortWeekList.value.findIndex((week) => week === `${firstDayToWeek}`);
      days.value = [...Array(index).fill(-1), ...Array.from(Array(monthNum + 1).keys())].filter((value) => value);
    };
    const initHeader = () => {
      const {
        preview: { previewYear, previewMonth },
        componentProps: { max: max2, min: min2 }
      } = props2;
      if (max2) {
        const date = `${previewYear}-${toNumber(previewMonth) + 1}`;
        panelBtnDisabled.right = !dayjs(date).isSameOrBefore(dayjs(max2), "month");
      }
      if (min2) {
        const date = `${previewYear}-${toNumber(previewMonth) - 1}`;
        panelBtnDisabled.left = !dayjs(date).isSameOrAfter(dayjs(min2), "month");
      }
    };
    const inRange = (day) => {
      const {
        preview: { previewYear, previewMonth },
        componentProps: { min: min2, max: max2 }
      } = props2;
      let isBeforeMax = true;
      let isAfterMin = true;
      const previewDate = `${previewYear}-${previewMonth}-${day}`;
      if (max2) {
        isBeforeMax = dayjs(previewDate).isSameOrBefore(dayjs(max2), "day");
      }
      if (min2) {
        isAfterMin = dayjs(previewDate).isSameOrAfter(dayjs(min2), "day");
      }
      return isBeforeMax && isAfterMin;
    };
    const shouldChoose = (val) => {
      const {
        choose: { chooseDays, chooseRangeDay },
        componentProps: { range }
      } = props2;
      if (range) {
        if (!chooseRangeDay.length) {
          return false;
        }
        const isBeforeMax = dayjs(val).isSameOrBefore(dayjs(chooseRangeDay[1]), "day");
        const isAfterMin = dayjs(val).isSameOrAfter(dayjs(chooseRangeDay[0]), "day");
        return isBeforeMax && isAfterMin;
      }
      return chooseDays.includes(val);
    };
    const buttonProps = (day) => {
      if (day < 0) {
        return {
          text: true,
          outline: false,
          textColor: "",
          class: n$T("button"),
          disabled: true
        };
      }
      const {
        choose: { chooseDay: chooseDay2 },
        preview: { previewYear, previewMonth },
        componentProps: { allowedDates, color, multiple, range }
      } = props2;
      const val = `${previewYear}-${previewMonth}-${day}`;
      const dayExist = () => {
        if (range || multiple) {
          return shouldChoose(val);
        }
        return toNumber(chooseDay2) === day && isSame.value;
      };
      const computeDisabled = () => {
        if (!inRange(day)) {
          return true;
        }
        if (!allowedDates) {
          return false;
        }
        return !allowedDates(val);
      };
      const disabled = computeDisabled();
      const computeText = () => {
        if (disabled) {
          return true;
        }
        if (range || multiple) {
          return !shouldChoose(val);
        }
        return !isSame.value || toNumber(chooseDay2) !== day;
      };
      const computeOutline = () => {
        if (!(isCurrent.value && toNumber(currentDay) === day && props2.componentProps.showCurrent)) {
          return false;
        }
        if ((range || multiple || isSame.value) && disabled) {
          return true;
        }
        if (range || multiple) {
          return !shouldChoose(val);
        }
        if (isSame.value) {
          return chooseDay2 !== currentDay;
        }
        return true;
      };
      const textColorOrCover = () => {
        if (disabled) {
          return "";
        }
        if (computeOutline()) {
          return color != null ? color : "";
        }
        if (dayExist()) {
          return "";
        }
        return `${nDate$2()}-color-cover`;
      };
      const isCover = textColorOrCover().startsWith(nDate$2());
      return {
        text: computeText(),
        outline: computeOutline(),
        textColor: isCover ? "" : textColorOrCover(),
        [`${nDate$2()}-color-cover`]: isCover,
        class: classes$J(n$T("button"), n$T("button--usable"), [disabled, n$T("button--disabled")]),
        disabled
      };
    };
    const checkDate = (checkType) => {
      reverse.value = checkType === "prev";
      panelKey.value += checkType === "prev" ? -1 : 1;
      emit("check-preview", "month", checkType);
    };
    const chooseDay = (day, event) => {
      const buttonEl = event.currentTarget;
      if (buttonEl.classList.contains(n$T("button--disabled"))) {
        return;
      }
      emit("choose-day", day);
    };
    const forwardRef = (checkType) => {
      headerEl.value.checkDate(checkType);
    };
    onSmartMounted(() => {
      initDate();
      initHeader();
    });
    vue.watch(
      () => props2.preview,
      () => {
        initDate();
        initHeader();
      }
    );
    vue.watch(() => [props2.componentProps.max, props2.componentProps.min], initHeader);
    return {
      n: n$T,
      nDate: nDate$2,
      days,
      reverse,
      headerEl,
      panelKey,
      sortWeekList,
      panelBtnDisabled,
      forwardRef,
      filterDay,
      getDayAbbr,
      checkDate,
      chooseDay,
      buttonProps
    };
  }
});
__sfc__$U.render = __render__$R;
var stdin_default$4R = __sfc__$U;
var __defProp$h = Object.defineProperty;
var __getOwnPropSymbols$h = Object.getOwnPropertySymbols;
var __hasOwnProp$h = Object.prototype.hasOwnProperty;
var __propIsEnum$h = Object.prototype.propertyIsEnumerable;
var __defNormalProp$h = (obj, key3, value) => key3 in obj ? __defProp$h(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$h = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$h.call(b, prop))
      __defNormalProp$h(a, prop, b[prop]);
  if (__getOwnPropSymbols$h)
    for (var prop of __getOwnPropSymbols$h(b)) {
      if (__propIsEnum$h.call(b, prop))
        __defNormalProp$h(a, prop, b[prop]);
    }
  return a;
};
dayjs.extend(isSameOrBefore);
dayjs.extend(isSameOrAfter);
const { n: n$S, classes: classes$I } = createNamespace("month-picker");
const { n: nDate$1 } = createNamespace("date-picker");
function __render__$Q(_ctx, _cache) {
  const _component_panel_header = vue.resolveComponent("panel-header");
  const _component_var_button = vue.resolveComponent("var-button");
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.n())
    },
    [
      vue.createElementVNode(
        "div",
        {
          class: vue.normalizeClass(_ctx.n("content"))
        },
        [
          vue.createVNode(_component_panel_header, {
            ref: "headerEl",
            type: "month",
            date: _ctx.preview,
            disabled: _ctx.panelBtnDisabled,
            onCheckPanel: _ctx.clickYear,
            onCheckDate: _ctx.checkDate
          }, null, 8, ["date", "disabled", "onCheckPanel", "onCheckDate"]),
          vue.createVNode(vue.Transition, {
            name: `${_ctx.nDate()}${_ctx.reverse ? "-reverse" : ""}-translatex`
          }, {
            default: vue.withCtx(() => [
              (vue.openBlock(), vue.createElementBlock("ul", { key: _ctx.panelKey }, [
                (vue.openBlock(true), vue.createElementBlock(
                  vue.Fragment,
                  null,
                  vue.renderList(_ctx.MONTH_LIST, (month) => {
                    return vue.openBlock(), vue.createElementBlock("li", { key: month }, [
                      vue.createVNode(_component_var_button, vue.mergeProps({
                        type: "primary",
                        "var-month-picker-cover": "",
                        ripple: false,
                        elevation: _ctx.componentProps.buttonElevation,
                        ref_for: true
                      }, __spreadValues$h({}, _ctx.buttonProps(month)), {
                        onClick: (event) => _ctx.chooseMonth(month, event)
                      }), {
                        default: vue.withCtx(() => [
                          vue.createTextVNode(
                            vue.toDisplayString(_ctx.getMonthAbbr(month)),
                            1
                            /* TEXT */
                          )
                        ]),
                        _: 2
                        /* DYNAMIC */
                      }, 1040, ["elevation", "onClick"])
                    ]);
                  }),
                  128
                  /* KEYED_FRAGMENT */
                ))
              ]))
            ]),
            _: 1
            /* STABLE */
          }, 8, ["name"])
        ],
        2
        /* CLASS */
      )
    ],
    2
    /* CLASS */
  );
}
const __sfc__$T = vue.defineComponent({
  name: "MonthPickerPanel",
  components: {
    VarButton: stdin_default$5t,
    PanelHeader: stdin_default$4S
  },
  props: {
    choose: {
      type: Object,
      required: true
    },
    preview: {
      type: Object,
      required: true
    },
    current: {
      type: String,
      required: true
    },
    clickYear: {
      type: Function,
      required: true
    },
    componentProps: {
      type: Object,
      required: true
    }
  },
  emits: ["check-preview", "choose-month"],
  setup(props2, { emit }) {
    const [currentYear, currentMonth] = props2.current.split("-");
    const reverse = vue.ref(false);
    const panelKey = vue.ref(0);
    const headerEl = vue.ref(null);
    const panelBtnDisabled = vue.reactive({
      left: false,
      right: false
    });
    const { t: pt } = injectLocaleProvider();
    const isSameYear = vue.computed(() => props2.choose.chooseYear === props2.preview.previewYear);
    const isCurrentYear = vue.computed(() => props2.preview.previewYear === currentYear);
    const getMonthAbbr = (key3) => {
      var _a, _b;
      return (_b = (_a = (pt || t)("datePickerMonthDict")) == null ? void 0 : _a[key3].abbr) != null ? _b : "";
    };
    const inRange = (key3) => {
      const {
        preview: { previewYear },
        componentProps: { min: min2, max: max2 }
      } = props2;
      let isBeforeMax = true;
      let isAfterMin = true;
      const previewDate = `${previewYear}-${key3}`;
      if (max2) {
        isBeforeMax = dayjs(previewDate).isSameOrBefore(dayjs(max2), "month");
      }
      if (min2) {
        isAfterMin = dayjs(previewDate).isSameOrAfter(dayjs(min2), "month");
      }
      return isBeforeMax && isAfterMin;
    };
    const shouldChoose = (val) => {
      const {
        choose: { chooseMonths, chooseDays, chooseRangeMonth },
        componentProps: { type, range }
      } = props2;
      if (range) {
        if (!chooseRangeMonth.length) {
          return false;
        }
        const isBeforeMax = dayjs(val).isSameOrBefore(dayjs(chooseRangeMonth[1]), "month");
        const isAfterMin = dayjs(val).isSameOrAfter(dayjs(chooseRangeMonth[0]), "month");
        return isBeforeMax && isAfterMin;
      }
      if (type === "month") {
        return chooseMonths.includes(val);
      }
      return chooseDays.some((value) => value.includes(val));
    };
    const buttonProps = (key3) => {
      const {
        choose: { chooseMonth: chooseMonth2 },
        preview: { previewYear },
        componentProps: { allowedDates, color, multiple, range }
      } = props2;
      const val = `${previewYear}-${key3}`;
      const monthExist = () => {
        if (range || multiple) {
          return shouldChoose(val);
        }
        return chooseMonth2 === key3 && isSameYear.value;
      };
      const computeDisabled = () => {
        if (!inRange(key3)) {
          return true;
        }
        if (!allowedDates) {
          return false;
        }
        return !allowedDates(val);
      };
      const disabled = computeDisabled();
      const computeText = () => {
        if (disabled) {
          return true;
        }
        if (range || multiple) {
          return !shouldChoose(val);
        }
        return !isSameYear.value || chooseMonth2 !== key3;
      };
      const computeOutline = () => {
        if (!(isCurrentYear.value && currentMonth === key3 && props2.componentProps.showCurrent)) {
          return false;
        }
        if ((range || multiple || isSameYear.value) && disabled) {
          return true;
        }
        if (range || multiple) {
          return !shouldChoose(val);
        }
        if (isSameYear.value) {
          return chooseMonth2 !== currentMonth;
        }
        return true;
      };
      const textColorOrCover = () => {
        if (disabled) {
          return "";
        }
        if (computeOutline()) {
          return color != null ? color : "";
        }
        if (monthExist()) {
          return "";
        }
        return `${nDate$1()}-color-cover`;
      };
      const isCover = textColorOrCover().startsWith(nDate$1());
      return {
        outline: computeOutline(),
        text: computeText(),
        color: !computeText() ? color : "",
        textColor: isCover ? "" : textColorOrCover(),
        [`${nDate$1()}-color-cover`]: isCover,
        class: classes$I(n$S("button"), [disabled, n$S("button--disabled")]),
        disabled
      };
    };
    const chooseMonth = (month, event) => {
      const buttonEl = event.currentTarget;
      if (buttonEl.classList.contains(n$S("button--disabled"))) {
        return;
      }
      emit("choose-month", month);
    };
    const checkDate = (checkType) => {
      reverse.value = checkType === "prev";
      panelKey.value += checkType === "prev" ? -1 : 1;
      emit("check-preview", "year", checkType);
    };
    const forwardRef = (checkType) => {
      headerEl.value.checkDate(checkType);
    };
    vue.watch(
      () => [props2.preview.previewYear, props2.componentProps.max, props2.componentProps.min],
      ([year, max2, min2]) => {
        if (max2) {
          panelBtnDisabled.right = !dayjs(`${toNumber(year) + 1}`).isSameOrBefore(dayjs(max2), "year");
        }
        if (min2) {
          panelBtnDisabled.left = !dayjs(`${toNumber(year) - 1}`).isSameOrAfter(dayjs(min2), "year");
        }
      },
      { immediate: true }
    );
    return {
      n: n$S,
      nDate: nDate$1,
      t,
      MONTH_LIST,
      headerEl,
      reverse,
      panelKey,
      panelBtnDisabled,
      forwardRef,
      buttonProps,
      getMonthAbbr,
      chooseMonth,
      checkDate
    };
  }
});
__sfc__$T.render = __render__$Q;
var stdin_default$4Q = __sfc__$T;
const props$L = {
  offsetTop: {
    type: [String, Number],
    default: 0
  },
  zIndex: {
    type: [String, Number],
    default: 10
  },
  cssMode: Boolean,
  disabled: Boolean,
  onScroll: defineListenerProp()
};
var __async$a = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const { name: name$N, n: n$R, classes: classes$H } = createNamespace("sticky");
function __render__$P(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      ref: "stickyEl",
      class: vue.normalizeClass(_ctx.classes(_ctx.n(), [_ctx.enableCSSMode, _ctx.n("--css-mode")])),
      style: vue.normalizeStyle({
        zIndex: _ctx.toNumber(_ctx.zIndex),
        top: _ctx.enableCSSMode ? `${_ctx.offsetTop}px` : void 0,
        width: _ctx.enableFixedMode ? _ctx.fixedWidth : void 0,
        height: _ctx.enableFixedMode ? _ctx.fixedHeight : void 0
      })
    },
    [
      vue.createElementVNode(
        "div",
        {
          ref: "wrapperEl",
          class: vue.normalizeClass(_ctx.n("wrapper")),
          style: vue.normalizeStyle({
            zIndex: _ctx.toNumber(_ctx.zIndex),
            position: _ctx.enableFixedMode ? "fixed" : void 0,
            width: _ctx.enableFixedMode ? _ctx.fixedWrapperWidth : void 0,
            height: _ctx.enableFixedMode ? _ctx.fixedWrapperHeight : void 0,
            left: _ctx.enableFixedMode ? _ctx.fixedLeft : void 0,
            top: _ctx.enableFixedMode ? _ctx.fixedTop : void 0
          })
        },
        [
          vue.renderSlot(_ctx.$slots, "default")
        ],
        6
        /* CLASS, STYLE */
      )
    ],
    6
    /* CLASS, STYLE */
  );
}
const __sfc__$S = vue.defineComponent({
  name: name$N,
  props: props$L,
  setup(props2) {
    const stickyEl = vue.ref(null);
    const wrapperEl = vue.ref(null);
    const isFixed = vue.ref(false);
    const fixedTop = vue.ref("0px");
    const fixedLeft = vue.ref("0px");
    const fixedWidth = vue.ref("auto");
    const fixedHeight = vue.ref("auto");
    const fixedWrapperWidth = vue.ref("auto");
    const fixedWrapperHeight = vue.ref("auto");
    const enableCSSMode = vue.computed(() => !props2.disabled && props2.cssMode);
    const enableFixedMode = vue.computed(() => !props2.disabled && !props2.cssMode && isFixed.value);
    const offsetTop = vue.computed(() => toPxNum(props2.offsetTop));
    let scroller;
    vue.watch(() => props2.disabled, resize);
    onSmartMounted(() => __async$a(this, null, function* () {
      yield doubleRaf();
      setupScroller();
      handleScroll();
    }));
    onSmartUnmounted(removeScrollListener);
    onWindowResize(resize);
    useEventListener(() => window, "scroll", handleScroll);
    function computeFixedParams() {
      const { cssMode, disabled } = props2;
      if (disabled) {
        return;
      }
      let scrollerTop = 0;
      if (scroller && scroller !== window) {
        const { top: top2 } = getRect(scroller);
        scrollerTop = top2;
      }
      const wrapper3 = wrapperEl.value;
      const sticky = stickyEl.value;
      const { top: stickyTop, left: stickyLeft } = getRect(sticky);
      const currentOffsetTop = stickyTop - scrollerTop;
      if (currentOffsetTop <= offsetTop.value) {
        if (!cssMode) {
          fixedWidth.value = `${sticky.offsetWidth}px`;
          fixedHeight.value = `${sticky.offsetHeight}px`;
          fixedTop.value = `${scrollerTop + offsetTop.value}px`;
          fixedLeft.value = `${stickyLeft}px`;
          fixedWrapperWidth.value = `${wrapper3.offsetWidth}px`;
          fixedWrapperHeight.value = `${wrapper3.offsetHeight}px`;
          isFixed.value = true;
        }
        return {
          offsetTop: offsetTop.value,
          isFixed: true
        };
      }
      isFixed.value = false;
      return {
        offsetTop: currentOffsetTop,
        isFixed: false
      };
    }
    function setupScroller() {
      scroller = getParentScroller(stickyEl.value);
      if (scroller !== window) {
        scroller.addEventListener("scroll", handleScroll);
      }
    }
    function handleScroll() {
      const fixedParams = computeFixedParams();
      if (fixedParams) {
        call(props2.onScroll, fixedParams.offsetTop, fixedParams.isFixed);
      }
    }
    function removeScrollListener() {
      if (!scroller || scroller === window) {
        return;
      }
      scroller.removeEventListener("scroll", handleScroll);
    }
    function resize() {
      return __async$a(this, null, function* () {
        isFixed.value = false;
        yield raf();
        computeFixedParams();
      });
    }
    return {
      stickyEl,
      wrapperEl,
      isFixed,
      offsetTop,
      fixedTop,
      fixedLeft,
      fixedWidth,
      fixedHeight,
      fixedWrapperWidth,
      fixedWrapperHeight,
      enableCSSMode,
      enableFixedMode,
      n: n$R,
      classes: classes$H,
      resize,
      toNumber
    };
  }
});
__sfc__$S.render = __render__$P;
var stdin_default$4P = __sfc__$S;
withInstall(stdin_default$4P);
withPropsDefaultsSetter(stdin_default$4P, props$L);
const _StickyComponent = stdin_default$4P;
var stdin_default$4O = stdin_default$4P;
var __defProp$g = Object.defineProperty;
var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
var __hasOwnProp$g = Object.prototype.hasOwnProperty;
var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
var __defNormalProp$g = (obj, key3, value) => key3 in obj ? __defProp$g(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$g = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$g.call(b, prop))
      __defNormalProp$g(a, prop, b[prop]);
  if (__getOwnPropSymbols$g)
    for (var prop of __getOwnPropSymbols$g(b)) {
      if (__propIsEnum$g.call(b, prop))
        __defNormalProp$g(a, prop, b[prop]);
    }
  return a;
};
const { n: n$Q, classes: classes$G } = createNamespace("year-picker");
const { n: nDate } = createNamespace("date-picker");
function __render__$O(_ctx, _cache) {
  const _component_panel_header = vue.resolveComponent("panel-header");
  const _component_var_sticky = vue.resolveComponent("var-sticky");
  const _component_var_button = vue.resolveComponent("var-button");
  return vue.openBlock(), vue.createElementBlock("div", null, [
    vue.createVNode(_component_var_sticky, { "css-mode": "" }, {
      default: vue.withCtx(() => [
        vue.createVNode(_component_panel_header, {
          ref: "headerEl",
          type: "year",
          date: {
            previewYear: `${_ctx.yearList[0]} ~ ${_ctx.yearList[_ctx.yearList.length - 1]}`
          },
          disabled: _ctx.panelBtnDisabled,
          onCheckDate: _ctx.checkDate
        }, null, 8, ["date", "disabled", "onCheckDate"])
      ]),
      _: 1
      /* STABLE */
    }),
    vue.createVNode(vue.Transition, {
      name: `${_ctx.nDate()}${_ctx.reverse ? "-reverse" : ""}-translatex`
    }, {
      default: vue.withCtx(() => [
        (vue.openBlock(), vue.createElementBlock(
          "ul",
          {
            ref: "panel",
            key: _ctx.panelKey,
            class: vue.normalizeClass(_ctx.n())
          },
          [
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList(_ctx.yearList, (year) => {
                return vue.openBlock(), vue.createElementBlock("li", { key: year }, [
                  vue.createVNode(_component_var_button, vue.mergeProps({
                    type: "primary",
                    "var-year-picker-cover": "",
                    ripple: false,
                    elevation: _ctx.componentProps.buttonElevation,
                    ref_for: true
                  }, __spreadValues$g({}, _ctx.buttonProps(`${year}`)), {
                    onClick: (event) => _ctx.chooseYear(year, event)
                  }), {
                    default: vue.withCtx(() => [
                      vue.createTextVNode(
                        vue.toDisplayString(year),
                        1
                        /* TEXT */
                      )
                    ]),
                    _: 2
                    /* DYNAMIC */
                  }, 1040, ["elevation", "onClick"])
                ]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ],
          2
          /* CLASS */
        ))
      ]),
      _: 1
      /* STABLE */
    }, 8, ["name"])
  ]);
}
const __sfc__$R = vue.defineComponent({
  name: "YearPickerPanel",
  components: {
    VarButton: stdin_default$5t,
    VarSticky: stdin_default$4O,
    PanelHeader: stdin_default$4S
  },
  props: {
    choose: {
      type: Object,
      required: true
    },
    current: {
      type: String,
      required: true
    },
    preview: {
      type: String
    },
    componentProps: {
      type: Object,
      required: true
    }
  },
  emits: ["choose-year"],
  setup(props2, { emit }) {
    const [currentYear] = props2.current.split("-");
    const panel = vue.ref();
    const headerEl = vue.ref(null);
    const reverse = vue.ref(false);
    const panelKey = vue.ref(0);
    const page = vue.ref(0);
    const panelBtnDisabled = vue.reactive({
      left: false,
      right: false
    });
    const yearList = vue.computed(() => {
      if (!props2.preview) {
        return [];
      }
      const startYear = Math.floor(toNumber(props2.preview) / 100 + page.value) * 100;
      return Array.from(Array(100), (_v, k) => Math.max(0, startYear) + k);
    });
    const shouldChoose = (val) => {
      const {
        choose: { chooseMonths, chooseDays, chooseYears, chooseRangeYear },
        componentProps: { type, range }
      } = props2;
      if (range) {
        if (!chooseRangeYear.length) {
          return false;
        }
        const isBeforeMax = dayjs(val).isSameOrBefore(dayjs(chooseRangeYear[1]), "year");
        const isAfterMin = dayjs(val).isSameOrAfter(dayjs(chooseRangeYear[0]), "year");
        return isBeforeMax && isAfterMin;
      }
      if (type === "year") {
        return chooseYears.includes(val);
      }
      if (type === "month") {
        return chooseMonths.some((value) => value.includes(val));
      }
      return chooseDays.some((value) => value.includes(val));
    };
    const inRange = (year) => {
      const {
        componentProps: { min: min2, max: max2 }
      } = props2;
      const isBeforeMax = max2 ? dayjs(year).isSameOrBefore(dayjs(max2), "year") : true;
      const isAfterMin = min2 ? dayjs(year).isSameOrAfter(dayjs(min2), "year") : true;
      return isBeforeMax && isAfterMin;
    };
    const buttonProps = (year) => {
      const {
        choose: { chooseYear: chooseYear2 },
        componentProps: { allowedDates, color, multiple, range }
      } = props2;
      const yearExist = () => {
        if (range || multiple) {
          return shouldChoose(year);
        }
        return chooseYear2 === year;
      };
      const computeDisabled = () => {
        if (!inRange(year)) {
          return true;
        }
        if (!allowedDates) {
          return false;
        }
        return !allowedDates(year);
      };
      const disabled = computeDisabled();
      const computeText = () => {
        if (disabled) {
          return true;
        }
        if (range || multiple) {
          return !shouldChoose(year);
        }
        return chooseYear2 !== year;
      };
      const computeOutline = () => {
        if (!(currentYear === year && props2.componentProps.showCurrent)) {
          return false;
        }
        if ((range || multiple) && disabled) {
          return true;
        }
        if (range || multiple) {
          return !shouldChoose(year);
        }
        return chooseYear2 !== currentYear;
      };
      const textColorOrCover = () => {
        if (disabled) {
          return "";
        }
        if (computeOutline()) {
          return color != null ? color : "";
        }
        if (yearExist()) {
          return "";
        }
        return `${nDate()}-color-cover`;
      };
      const isCover = textColorOrCover().startsWith(nDate());
      return {
        outline: computeOutline(),
        text: computeText(),
        color: !computeText() ? color : "",
        textColor: isCover ? "" : textColorOrCover(),
        [`${nDate()}-color-cover`]: isCover,
        class: classes$G(n$Q("button"), [disabled, n$Q("button--disabled")]),
        disabled
      };
    };
    const chooseYear = (year, event) => {
      const buttonEl = event.currentTarget;
      if (buttonEl.classList.contains(n$Q("button--disabled"))) {
        return;
      }
      emit("choose-year", year);
    };
    const scrollToView = () => {
      var _a;
      const activeEl = (_a = panel.value.querySelector(".var-button--primary")) != null ? _a : panel.value.querySelector(".var-button--outline");
      activeEl == null ? void 0 : activeEl.scrollIntoView({
        block: "center"
      });
    };
    const checkDate = (checkType) => {
      const isPrevType = checkType === "prev";
      reverse.value = isPrevType;
      panelKey.value += isPrevType ? -1 : 1;
      page.value += isPrevType ? -1 : 1;
    };
    const forwardRef = (checkType) => {
      headerEl.value.checkDate(checkType);
    };
    onSmartMounted(scrollToView);
    vue.watch(
      () => props2.preview,
      () => {
        page.value = 0;
      }
    );
    vue.watch(
      () => [yearList.value, props2.componentProps.max, props2.componentProps.min],
      (newVal) => {
        const [list, max2, min2] = newVal;
        if (max2) {
          panelBtnDisabled.right = !dayjs(`${toNumber(list[list.length - 1])}`).isSameOrBefore(dayjs(max2), "year");
        }
        if (min2) {
          panelBtnDisabled.left = !dayjs(`${toNumber(list[0])}`).isSameOrAfter(dayjs(min2), "year");
        }
        if (toNumber(list[0] <= 0)) {
          panelBtnDisabled.left = false;
        }
      },
      {
        immediate: true
      }
    );
    return {
      n: n$Q,
      classes: classes$G,
      buttonProps,
      panel,
      headerEl,
      yearList,
      reverse,
      panelKey,
      panelBtnDisabled,
      nDate,
      checkDate,
      chooseYear,
      forwardRef,
      toNumber
    };
  }
});
__sfc__$R.render = __render__$O;
var stdin_default$4N = __sfc__$R;
var __async$9 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const { name: name$M, n: n$P, classes: classes$F } = createNamespace("date-picker");
function __render__$N(_ctx, _cache) {
  var _a;
  const _component_year_picker_panel = vue.resolveComponent("year-picker-panel");
  const _component_month_picker_panel = vue.resolveComponent("month-picker-panel");
  const _component_day_picker_panel = vue.resolveComponent("day-picker-panel");
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.classes(_ctx.n(), _ctx.formatElevation(_ctx.elevation, 2)))
    },
    [
      vue.createElementVNode(
        "div",
        {
          class: vue.normalizeClass(_ctx.n("title")),
          style: vue.normalizeStyle({ background: _ctx.titleColor || _ctx.color })
        },
        [
          vue.createElementVNode(
            "div",
            {
              class: vue.normalizeClass(_ctx.n("title-select"))
            },
            [
              vue.createElementVNode(
                "div",
                {
                  class: vue.normalizeClass(_ctx.n("title-hint"))
                },
                vue.toDisplayString((_a = _ctx.hint) != null ? _a : (_ctx.pt ? _ctx.pt : _ctx.t)("datePickerHint")),
                3
                /* TEXT, CLASS */
              ),
              _ctx.type !== "year" ? (vue.openBlock(), vue.createElementBlock(
                "div",
                {
                  key: 0,
                  class: vue.normalizeClass(_ctx.classes(_ctx.n("title-year"), [_ctx.isYearPanel, _ctx.n("title-year--active")])),
                  onClick: _cache[0] || (_cache[0] = ($event) => _ctx.clickEl("year"))
                },
                [
                  vue.renderSlot(_ctx.$slots, "year", { year: _ctx.chooseYear }, () => [
                    vue.createTextVNode(
                      vue.toDisplayString(_ctx.chooseYear),
                      1
                      /* TEXT */
                    )
                  ])
                ],
                2
                /* CLASS */
              )) : vue.createCommentVNode("v-if", true)
            ],
            2
            /* CLASS */
          ),
          vue.createElementVNode(
            "div",
            {
              class: vue.normalizeClass(
                _ctx.classes(
                  _ctx.n("title-date"),
                  [!_ctx.isYearPanel || _ctx.type === "year", _ctx.n("title-date--active")],
                  [_ctx.range, _ctx.n("title-date--range")]
                )
              ),
              onClick: _cache[1] || (_cache[1] = ($event) => _ctx.clickEl("date"))
            },
            [
              vue.createVNode(vue.Transition, {
                name: _ctx.multiple ? "" : `${_ctx.n()}${_ctx.reverse ? "-reverse" : ""}-translatey`
              }, {
                default: vue.withCtx(() => [
                  _ctx.type === "year" ? (vue.openBlock(), vue.createElementBlock("div", {
                    key: `${_ctx.chooseYear}`
                  }, [
                    _ctx.range ? vue.renderSlot(_ctx.$slots, "range", {
                      key: 0,
                      choose: _ctx.getChoose.chooseRangeYear
                    }, () => [
                      vue.createTextVNode(
                        vue.toDisplayString(_ctx.getYearTitle),
                        1
                        /* TEXT */
                      )
                    ]) : _ctx.multiple ? vue.renderSlot(_ctx.$slots, "multiple", {
                      key: 1,
                      choose: _ctx.getChoose.chooseYears
                    }, () => [
                      vue.createTextVNode(
                        vue.toDisplayString(_ctx.getYearTitle),
                        1
                        /* TEXT */
                      )
                    ]) : vue.renderSlot(_ctx.$slots, "year", {
                      key: 2,
                      year: _ctx.chooseYear
                    }, () => [
                      vue.createTextVNode(
                        vue.toDisplayString(_ctx.getYearTitle),
                        1
                        /* TEXT */
                      )
                    ])
                  ])) : _ctx.type === "month" ? (vue.openBlock(), vue.createElementBlock("div", {
                    key: `${_ctx.chooseYear}${_ctx.chooseMonth}`
                  }, [
                    _ctx.range ? vue.renderSlot(_ctx.$slots, "range", {
                      key: 0,
                      choose: _ctx.getChoose.chooseRangeMonth
                    }, () => [
                      vue.createTextVNode(
                        vue.toDisplayString(_ctx.getMonthTitle),
                        1
                        /* TEXT */
                      )
                    ]) : _ctx.multiple ? vue.renderSlot(_ctx.$slots, "multiple", {
                      key: 1,
                      choose: _ctx.getChoose.chooseMonths
                    }, () => [
                      vue.createTextVNode(
                        vue.toDisplayString(_ctx.getMonthTitle),
                        1
                        /* TEXT */
                      )
                    ]) : vue.renderSlot(_ctx.$slots, "month", {
                      key: 2,
                      month: _ctx.chooseMonth,
                      year: _ctx.chooseYear
                    }, () => [
                      vue.createTextVNode(
                        vue.toDisplayString(_ctx.getMonthTitle),
                        1
                        /* TEXT */
                      )
                    ])
                  ])) : (vue.openBlock(), vue.createElementBlock("div", {
                    key: `${_ctx.chooseYear}${_ctx.chooseMonth}${_ctx.chooseDay}`
                  }, [
                    _ctx.range ? vue.renderSlot(_ctx.$slots, "range", {
                      key: 0,
                      choose: _ctx.formatRange
                    }, () => [
                      vue.createTextVNode(
                        vue.toDisplayString(_ctx.getDateTitle),
                        1
                        /* TEXT */
                      )
                    ]) : _ctx.multiple ? vue.renderSlot(_ctx.$slots, "multiple", {
                      key: 1,
                      choose: _ctx.getChoose.chooseDays
                    }, () => [
                      vue.createTextVNode(
                        vue.toDisplayString(_ctx.getDateTitle),
                        1
                        /* TEXT */
                      )
                    ]) : vue.renderSlot(_ctx.$slots, "date", vue.normalizeProps(vue.mergeProps({ key: 2 }, _ctx.slotProps)), () => [
                      vue.createTextVNode(
                        vue.toDisplayString(_ctx.getDateTitle),
                        1
                        /* TEXT */
                      )
                    ])
                  ]))
                ]),
                _: 3
                /* FORWARDED */
              }, 8, ["name"])
            ],
            2
            /* CLASS */
          )
        ],
        6
        /* CLASS, STYLE */
      ),
      vue.createElementVNode(
        "div",
        {
          class: vue.normalizeClass(_ctx.n("body")),
          onTouchstart: _cache[2] || (_cache[2] = (...args) => _ctx.handleTouchstart && _ctx.handleTouchstart(...args)),
          onTouchmove: _cache[3] || (_cache[3] = (...args) => _ctx.handleTouchmove && _ctx.handleTouchmove(...args)),
          onTouchend: _cache[4] || (_cache[4] = (...args) => _ctx.handleTouchend && _ctx.handleTouchend(...args))
        },
        [
          vue.createVNode(vue.Transition, {
            name: `${_ctx.n()}-panel-fade`
          }, {
            default: vue.withCtx(() => [
              _ctx.getPanelType === "year" ? (vue.openBlock(), vue.createBlock(_component_year_picker_panel, {
                key: 0,
                ref: "yearPanelEl",
                choose: _ctx.getChoose,
                current: _ctx.currentDate,
                "component-props": _ctx.componentProps,
                preview: _ctx.previewYear,
                onChooseYear: _ctx.getChooseYear
              }, null, 8, ["choose", "current", "component-props", "preview", "onChooseYear"])) : _ctx.getPanelType === "month" ? (vue.openBlock(), vue.createBlock(_component_month_picker_panel, {
                key: 1,
                ref: "monthPanelEl",
                current: _ctx.currentDate,
                choose: _ctx.getChoose,
                preview: _ctx.getPreview,
                "click-year": () => _ctx.clickEl("year"),
                "component-props": _ctx.componentProps,
                onChooseMonth: _ctx.getChooseMonth,
                onCheckPreview: _ctx.checkPreview
              }, null, 8, ["current", "choose", "preview", "click-year", "component-props", "onChooseMonth", "onCheckPreview"])) : _ctx.getPanelType === "date" ? (vue.openBlock(), vue.createBlock(_component_day_picker_panel, {
                key: 2,
                ref: "dayPanelEl",
                current: _ctx.currentDate,
                choose: _ctx.getChoose,
                preview: _ctx.getPreview,
                "component-props": _ctx.componentProps,
                "click-month": () => _ctx.clickEl("month"),
                onChooseDay: _ctx.getChooseDay,
                onCheckPreview: _ctx.checkPreview
              }, null, 8, ["current", "choose", "preview", "component-props", "click-month", "onChooseDay", "onCheckPreview"])) : vue.createCommentVNode("v-if", true)
            ]),
            _: 1
            /* STABLE */
          }, 8, ["name"])
        ],
        34
        /* CLASS, NEED_HYDRATION */
      ),
      _ctx.$slots.actions ? (vue.openBlock(), vue.createElementBlock(
        "div",
        {
          key: 0,
          class: vue.normalizeClass(_ctx.n("actions"))
        },
        [
          vue.renderSlot(_ctx.$slots, "actions")
        ],
        2
        /* CLASS */
      )) : vue.createCommentVNode("v-if", true)
    ],
    2
    /* CLASS */
  );
}
const __sfc__$Q = vue.defineComponent({
  name: name$M,
  components: {
    MonthPickerPanel: stdin_default$4Q,
    YearPickerPanel: stdin_default$4N,
    DayPickerPanel: stdin_default$4R
  },
  props: props$M,
  setup(props2) {
    const { t: pt } = injectLocaleProvider();
    const currentDate = dayjs().format("YYYY-MM-D");
    const [currentYear, currentMonth] = currentDate.split("-");
    const monthDes = MONTH_LIST.find((month) => month === currentMonth);
    const isYearPanel = vue.ref(false);
    const isMonthPanel = vue.ref(false);
    const rangeDone = vue.ref(true);
    const chooseMonth = vue.ref();
    const chooseYear = vue.ref();
    const chooseDay = vue.ref();
    const previewMonth = vue.ref(monthDes);
    const previewYear = vue.ref(currentYear);
    const reverse = vue.ref(false);
    const chooseYears = vue.ref([]);
    const chooseMonths = vue.ref([]);
    const chooseDays = vue.ref([]);
    const chooseRangeYear = vue.ref([]);
    const chooseRangeMonth = vue.ref([]);
    const chooseRangeDay = vue.ref([]);
    const yearPanelEl = vue.ref(null);
    const monthPanelEl = vue.ref(null);
    const dayPanelEl = vue.ref(null);
    const componentProps = vue.computed(() => ({
      allowedDates: props2.allowedDates,
      type: props2.type,
      color: props2.color,
      firstDayOfWeek: props2.firstDayOfWeek,
      min: props2.min,
      max: props2.max,
      showCurrent: props2.showCurrent,
      multiple: props2.multiple,
      range: props2.range,
      buttonElevation: props2.buttonElevation
    }));
    const getChoose = vue.computed(() => ({
      chooseMonth: chooseMonth.value,
      chooseYear: chooseYear.value,
      chooseDay: chooseDay.value,
      chooseYears: chooseYears.value,
      chooseMonths: chooseMonths.value,
      chooseDays: chooseDays.value,
      chooseRangeYear: chooseRangeYear.value,
      chooseRangeMonth: chooseRangeMonth.value,
      chooseRangeDay: chooseRangeDay.value
    }));
    const getPreview = vue.computed(() => ({
      previewMonth: previewMonth.value,
      previewYear: previewYear.value
    }));
    const getYearTitle = vue.computed(() => {
      var _a;
      const { multiple, range } = props2;
      if (range) {
        return chooseRangeYear.value.length ? `${chooseRangeYear.value[0]} ~ ${chooseRangeYear.value[1]}` : "";
      }
      return multiple ? `${chooseYears.value.length}${(pt || t)("datePickerSelected")}` : (_a = chooseYear.value) != null ? _a : "";
    });
    const getMonthTitle = vue.computed(() => {
      var _a, _b;
      const { multiple, range } = props2;
      if (range) {
        return chooseRangeMonth.value.length ? `${chooseRangeMonth.value[0]} ~ ${chooseRangeMonth.value[1]}` : "";
      }
      let monthName = "";
      if (chooseMonth.value) {
        monthName = (_b = (_a = (pt || t)("datePickerMonthDict")) == null ? void 0 : _a[chooseMonth.value].name) != null ? _b : "";
      }
      return multiple ? `${chooseMonths.value.length}${(pt || t)("datePickerSelected")}` : monthName;
    });
    const getDateTitle = vue.computed(() => {
      var _a, _b, _c, _d;
      const { multiple, range } = props2;
      if (range) {
        const formatRangeDays = chooseRangeDay.value.map((date) => dayjs(date).format("YYYY-MM-DD"));
        return formatRangeDays.length ? `${formatRangeDays[0]} ~ ${formatRangeDays[1]}` : "";
      }
      if (multiple) {
        return `${chooseDays.value.length}${(pt || t)("datePickerSelected")}`;
      }
      if (!chooseYear.value || !chooseMonth.value || !chooseDay.value) {
        return "";
      }
      const weekIndex = dayjs(`${chooseYear.value}-${chooseMonth.value}-${chooseDay.value}`).day();
      const week = WEEK_HEADER.find((value) => value === `${weekIndex}`);
      const weekName = (_b = (_a = (pt || t)("datePickerWeekDict")) == null ? void 0 : _a[week].name) != null ? _b : "";
      const monthName = (_d = (_c = (pt || t)("datePickerMonthDict")) == null ? void 0 : _c[chooseMonth.value].name) != null ? _d : "";
      const showDay = padStart$1(chooseDay.value, 2, "0");
      if ((pt || t)("lang") === "zh-CN") {
        return `${chooseMonth.value}-${showDay} ${weekName.slice(0, 3)}`;
      }
      return `${weekName.slice(0, 3)}, ${monthName.slice(0, 3)} ${chooseDay.value}`;
    });
    const getPanelType = vue.computed(() => {
      if (props2.type === "year" || isYearPanel.value) {
        return "year";
      }
      if (props2.type === "month" || isMonthPanel.value) {
        return "month";
      }
      if (props2.type === "date") {
        return "date";
      }
      return "";
    });
    const isUntouchable = vue.computed(() => !props2.touchable || !getPanelType.value);
    const slotProps = vue.computed(() => {
      var _a, _b;
      const weekIndex = dayjs(`${chooseYear.value}-${chooseMonth.value}-${chooseDay.value}`).day();
      const date = chooseDay.value ? padStart$1(chooseDay.value, 2, "0") : "";
      return {
        week: `${weekIndex}`,
        year: (_a = chooseYear.value) != null ? _a : "",
        month: (_b = chooseMonth.value) != null ? _b : "",
        date
      };
    });
    const formatRange = vue.computed(
      () => getChoose.value.chooseRangeDay.map((choose) => dayjs(choose).format("YYYY-MM-DD"))
    );
    const isSameYear = vue.computed(() => chooseYear.value === previewYear.value);
    const isSameMonth = vue.computed(() => chooseMonth.value === previewMonth.value);
    let startX = 0;
    let startY = 0;
    let checkType = "";
    let touchDirection;
    vue.watch(
      () => props2.modelValue,
      (value) => {
        if (!checkValue() || invalidFormatDate(value)) {
          return;
        }
        if (props2.range) {
          if (!isArray(value)) {
            return;
          }
          rangeDone.value = value.length !== 1;
          rangeInit(value, props2.type);
        } else if (props2.multiple) {
          if (!isArray(value)) {
            return;
          }
          multipleInit(value, props2.type);
        } else {
          dateInit(value);
        }
      },
      { immediate: true }
    );
    vue.watch(getPanelType, resetState);
    function clickEl(type) {
      if (type === "year") {
        isYearPanel.value = true;
      } else if (type === "month") {
        isMonthPanel.value = true;
      } else {
        isYearPanel.value = false;
        isMonthPanel.value = false;
      }
    }
    function handleTouchstart(event) {
      if (isUntouchable.value) {
        return;
      }
      const { clientX, clientY } = event.touches[0];
      startX = clientX;
      startY = clientY;
    }
    function getDirection2(x, y) {
      return x >= y && x > 20 ? "x" : "y";
    }
    function handleTouchmove(event) {
      if (isUntouchable.value) {
        return;
      }
      const { clientX, clientY } = event.touches[0];
      const x = clientX - startX;
      const y = clientY - startY;
      touchDirection = getDirection2(Math.abs(x), Math.abs(y));
      checkType = x > 0 ? "prev" : "next";
    }
    function handleTouchend() {
      return __async$9(this, null, function* () {
        if (isUntouchable.value || touchDirection !== "x") {
          return;
        }
        const componentRef = getPanelType.value === "year" ? yearPanelEl : getPanelType.value === "month" ? monthPanelEl : dayPanelEl;
        yield doubleRaf();
        componentRef.value.forwardRef(checkType);
        resetState();
      });
    }
    function updateRange(date, type) {
      const rangeDate = type === "year" ? chooseRangeYear : type === "month" ? chooseRangeMonth : chooseRangeDay;
      rangeDate.value = rangeDone.value ? [date, date] : [rangeDate.value[0], date];
      rangeDone.value = !rangeDone.value;
      if (rangeDone.value) {
        const isChangeOrder = dayjs(rangeDate.value[0]).isAfter(rangeDate.value[1]);
        const date2 = isChangeOrder ? [rangeDate.value[1], rangeDate.value[0]] : [...rangeDate.value];
        call(props2["onUpdate:modelValue"], date2);
        call(props2.onChange, date2);
      }
    }
    function updateMultiple(date, type) {
      const multipleDates = type === "year" ? chooseYears : type === "month" ? chooseMonths : chooseDays;
      const formatType = type === "year" ? "YYYY" : type === "month" ? "YYYY-MM" : "YYYY-MM-DD";
      const formatDates = multipleDates.value.map((date2) => dayjs(date2).format(formatType));
      const index = formatDates.findIndex((choose) => choose === date);
      if (index === -1) {
        formatDates.push(date);
      } else {
        formatDates.splice(index, 1);
      }
      call(props2["onUpdate:modelValue"], formatDates);
      call(props2.onChange, formatDates);
    }
    function getReverse(dateType, date) {
      if (!chooseYear.value || !chooseMonth.value) {
        return false;
      }
      if (!isSameYear.value) {
        return chooseYear.value > previewYear.value;
      }
      if (dateType === "year") {
        return date < toNumber(chooseYear.value);
      }
      if (dateType === "month") {
        return date < chooseMonth.value;
      }
      return isSameMonth.value ? date < toNumber(chooseDay.value) : chooseMonth.value > previewMonth.value;
    }
    function getChooseDay(day) {
      const { readonly, range, multiple, onChange, "onUpdate:modelValue": updateModelValue } = props2;
      if (day < 0 || readonly) {
        return;
      }
      reverse.value = getReverse("day", day);
      const date = `${previewYear.value}-${previewMonth.value}-${day}`;
      const formatDate = dayjs(date).format("YYYY-MM-DD");
      if (range) {
        updateRange(formatDate, "day");
      } else if (multiple) {
        updateMultiple(formatDate, "day");
      } else {
        call(updateModelValue, formatDate);
        call(onChange, formatDate);
      }
    }
    function getChooseMonth(month) {
      const { type, readonly, range, multiple, onChange, onPreview, "onUpdate:modelValue": updateModelValue } = props2;
      reverse.value = getReverse("month", month);
      if (type === "month" && !readonly) {
        const date = `${previewYear.value}-${month}`;
        if (range) {
          updateRange(date, "month");
        } else if (multiple) {
          updateMultiple(date, "month");
        } else {
          call(updateModelValue, date);
          call(onChange, date);
        }
      } else {
        previewMonth.value = month;
        call(
          onPreview,
          toNumber(previewYear.value),
          toNumber(previewMonth.value),
          type === "date" ? toNumber(chooseDay.value) : void 0
        );
      }
      isMonthPanel.value = false;
    }
    function getChooseYear(year) {
      const { type, readonly, range, multiple, onChange, onPreview, "onUpdate:modelValue": updateModelValue } = props2;
      reverse.value = getReverse("year", year);
      if (type === "year" && !readonly) {
        if (range) {
          updateRange(`${year}`, "year");
        } else if (multiple) {
          updateMultiple(`${year}`, "year");
        } else {
          call(updateModelValue, `${year}`);
          call(onChange, `${year}`);
        }
      } else {
        previewYear.value = `${year}`;
        call(
          onPreview,
          toNumber(previewYear.value),
          toNumber(previewMonth.value),
          type === "date" ? toNumber(chooseDay.value) : void 0
        );
      }
      isYearPanel.value = false;
    }
    function checkPreview(type, checkType2) {
      const changeValue = checkType2 === "prev" ? -1 : 1;
      if (type === "year") {
        previewYear.value = `${toNumber(previewYear.value) + changeValue}`;
      } else {
        let checkIndex = toNumber(previewMonth.value) + changeValue;
        if (checkIndex < 1) {
          previewYear.value = `${toNumber(previewYear.value) - 1}`;
          checkIndex = 12;
        }
        if (checkIndex > 12) {
          previewYear.value = `${toNumber(previewYear.value) + 1}`;
          checkIndex = 1;
        }
        previewMonth.value = MONTH_LIST.find((month) => toNumber(month) === checkIndex);
      }
      call(
        props2.onPreview,
        toNumber(previewYear.value),
        toNumber(previewMonth.value),
        props2.type === "date" ? toNumber(chooseDay.value) : void 0
      );
    }
    function checkValue() {
      if ((props2.multiple || props2.range) && !isArray(props2.modelValue)) {
        error$1("DatePicker", 'type of prop "modelValue" should be an Array');
        return false;
      }
      if (!props2.multiple && !props2.range && isArray(props2.modelValue)) {
        error$1("DatePicker", 'type of prop "modelValue" should be a String');
        return false;
      }
      return true;
    }
    function invalidFormatDate(date) {
      if (isArray(date)) {
        return false;
      }
      if (date === "Invalid Date") {
        error$1("DatePicker", '"modelValue" is an Invalid Date');
        return true;
      }
      return false;
    }
    function rangeInit(value, type) {
      const rangeDate = type === "year" ? chooseRangeYear : type === "month" ? chooseRangeMonth : chooseRangeDay;
      const formatType = type === "year" ? "YYYY" : type === "month" ? "YYYY-MM" : "YYYY-MM-D";
      const formatDateList = value.map((choose) => dayjs(choose).format(formatType)).slice(0, 2);
      const isValid = rangeDate.value.some((date) => invalidFormatDate(date));
      if (isValid) {
        return;
      }
      rangeDate.value = formatDateList;
      const isChangeOrder = dayjs(rangeDate.value[0]).isAfter(rangeDate.value[1]);
      if (rangeDate.value.length === 2 && isChangeOrder) {
        rangeDate.value = [rangeDate.value[1], rangeDate.value[0]];
      }
    }
    function multipleInit(value, type) {
      const rangeDate = type === "year" ? chooseYears : type === "month" ? chooseMonths : chooseDays;
      const formatType = type === "year" ? "YYYY" : type === "month" ? "YYYY-MM" : "YYYY-MM-D";
      const formatDateList = Array.from(new Set(value.map((choose) => dayjs(choose).format(formatType))));
      rangeDate.value = formatDateList.filter((date) => date !== "Invalid Date");
    }
    function dateInit(value) {
      const handleValue = value ? dayjs(value) : dayjs();
      const formatDate = handleValue.format("YYYY-MM-D");
      if (invalidFormatDate(formatDate)) {
        return;
      }
      const [yearValue, monthValue, dayValue] = formatDate.split("-");
      const monthDes2 = MONTH_LIST.find((month) => month === monthValue);
      chooseMonth.value = monthDes2;
      chooseYear.value = yearValue;
      chooseDay.value = dayValue;
      previewMonth.value = monthDes2;
      previewYear.value = yearValue;
    }
    function resetState() {
      startY = 0;
      startX = 0;
      checkType = "";
      touchDirection = void 0;
    }
    return {
      yearPanelEl,
      monthPanelEl,
      dayPanelEl,
      reverse,
      currentDate,
      chooseMonth,
      chooseYear,
      chooseDay,
      previewYear,
      isYearPanel,
      isMonthPanel,
      getMonthTitle,
      getDateTitle,
      getYearTitle,
      getPanelType,
      getChoose,
      getPreview,
      componentProps,
      slotProps,
      formatRange,
      pt,
      t,
      n: n$P,
      classes: classes$F,
      clickEl,
      handleTouchstart,
      handleTouchmove,
      handleTouchend,
      getChooseDay,
      getChooseMonth,
      getChooseYear,
      checkPreview,
      formatElevation
    };
  }
});
__sfc__$Q.render = __render__$N;
var stdin_default$4M = __sfc__$Q;
withInstall(stdin_default$4M);
withPropsDefaultsSetter(stdin_default$4M, props$M);
const _DatePickerComponent = stdin_default$4M;
var stdin_default$4L = stdin_default$4M;
var __defProp$f = Object.defineProperty;
var __getOwnPropSymbols$f = Object.getOwnPropertySymbols;
var __hasOwnProp$f = Object.prototype.hasOwnProperty;
var __propIsEnum$f = Object.prototype.propertyIsEnumerable;
var __defNormalProp$f = (obj, key3, value) => key3 in obj ? __defProp$f(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$f = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$f.call(b, prop))
      __defNormalProp$f(a, prop, b[prop]);
  if (__getOwnPropSymbols$f)
    for (var prop of __getOwnPropSymbols$f(b)) {
      if (__propIsEnum$f.call(b, prop))
        __defNormalProp$f(a, prop, b[prop]);
    }
  return a;
};
const props$K = __spreadValues$f({
  show: Boolean,
  width: [Number, String],
  title: String,
  message: String,
  messageAlign: {
    type: String,
    default: "left"
  },
  confirmButton: {
    type: Boolean,
    default: true
  },
  cancelButton: {
    type: Boolean,
    default: true
  },
  confirmButtonText: String,
  cancelButtonText: String,
  confirmButtonTextColor: String,
  cancelButtonTextColor: String,
  confirmButtonColor: String,
  cancelButtonColor: String,
  dialogClass: String,
  dialogStyle: Object,
  onBeforeClose: defineListenerProp(),
  onConfirm: defineListenerProp(),
  onCancel: defineListenerProp(),
  "onUpdate:show": defineListenerProp()
}, pickProps(props$1l, [
  "overlay",
  "overlayClass",
  "overlayStyle",
  "lockScroll",
  "closeOnClickOverlay",
  "closeOnKeyEscape",
  "teleport",
  "onOpen",
  "onClose",
  "onOpened",
  "onClosed",
  "onClickOverlay",
  "onKeyEscape",
  // internal for function call closes the dialog
  "onRouteChange"
]));
var __defProp$e = Object.defineProperty;
var __getOwnPropSymbols$e = Object.getOwnPropertySymbols;
var __hasOwnProp$e = Object.prototype.hasOwnProperty;
var __propIsEnum$e = Object.prototype.propertyIsEnumerable;
var __defNormalProp$e = (obj, key3, value) => key3 in obj ? __defProp$e(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$e = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$e.call(b, prop))
      __defNormalProp$e(a, prop, b[prop]);
  if (__getOwnPropSymbols$e)
    for (var prop of __getOwnPropSymbols$e(b)) {
      if (__propIsEnum$e.call(b, prop))
        __defNormalProp$e(a, prop, b[prop]);
    }
  return a;
};
const { name: name$L, n: n$O, classes: classes$E } = createNamespace("dialog");
function __render__$M(_ctx, _cache) {
  const _component_var_button = vue.resolveComponent("var-button");
  const _component_var_popup = vue.resolveComponent("var-popup");
  return vue.openBlock(), vue.createBlock(_component_var_popup, {
    class: vue.normalizeClass(_ctx.n("popup")),
    "var-dialog-cover": "",
    show: _ctx.popupShow,
    overlay: _ctx.overlay,
    "overlay-class": _ctx.overlayClass,
    "overlay-style": _ctx.overlayStyle,
    "lock-scroll": _ctx.lockScroll,
    "close-on-click-overlay": _ctx.popupCloseOnClickOverlay,
    "close-on-key-escape": false,
    teleport: _ctx.teleport,
    onOpen: _ctx.onOpen,
    onClose: _ctx.onClose,
    onClosed: _ctx.onClosed,
    onOpened: _ctx.onOpened,
    onKeyEscape: _ctx.handleKeyEscape,
    onRouteChange: _ctx.onRouteChange,
    onClickOverlay: _ctx.handleClickOverlay
  }, {
    default: vue.withCtx(() => [
      vue.createElementVNode(
        "div",
        vue.mergeProps({
          class: _ctx.classes(_ctx.n("$--box"), _ctx.n(), _ctx.dialogClass),
          style: __spreadValues$e({ width: _ctx.toSizeUnit(_ctx.width) }, _ctx.dialogStyle)
        }, _ctx.$attrs),
        [
          vue.createElementVNode(
            "div",
            {
              class: vue.normalizeClass(_ctx.n("title"))
            },
            [
              vue.renderSlot(_ctx.$slots, "title", {}, () => {
                var _a;
                return [
                  vue.createTextVNode(
                    vue.toDisplayString((_a = _ctx.title) != null ? _a : (_ctx.pt ? _ctx.pt : _ctx.t)("dialogTitle")),
                    1
                    /* TEXT */
                  )
                ];
              })
            ],
            2
            /* CLASS */
          ),
          vue.createElementVNode(
            "div",
            {
              class: vue.normalizeClass(_ctx.n("message")),
              style: vue.normalizeStyle({ textAlign: _ctx.messageAlign })
            },
            [
              vue.renderSlot(_ctx.$slots, "default", {}, () => [
                vue.createTextVNode(
                  vue.toDisplayString(_ctx.message),
                  1
                  /* TEXT */
                )
              ])
            ],
            6
            /* CLASS, STYLE */
          ),
          vue.renderSlot(_ctx.$slots, "actions", {
            slotClass: _ctx.n("actions"),
            cancel: _ctx.cancel,
            confirm: _ctx.confirm
          }, () => [
            vue.createElementVNode(
              "div",
              {
                class: vue.normalizeClass(_ctx.n("actions"))
              },
              [
                _ctx.cancelButton ? (vue.openBlock(), vue.createBlock(_component_var_button, {
                  key: 0,
                  class: vue.normalizeClass(_ctx.classes(_ctx.n("button"), _ctx.n("cancel-button"))),
                  "var-dialog-cover": "",
                  text: "",
                  "text-color": _ctx.cancelButtonTextColor,
                  color: _ctx.cancelButtonColor,
                  onClick: _ctx.cancel
                }, {
                  default: vue.withCtx(() => {
                    var _a;
                    return [
                      vue.createTextVNode(
                        vue.toDisplayString((_a = _ctx.cancelButtonText) != null ? _a : (_ctx.pt ? _ctx.pt : _ctx.t)("dialogCancelButtonText")),
                        1
                        /* TEXT */
                      )
                    ];
                  }),
                  _: 1
                  /* STABLE */
                }, 8, ["class", "text-color", "color", "onClick"])) : vue.createCommentVNode("v-if", true),
                _ctx.confirmButton ? (vue.openBlock(), vue.createBlock(_component_var_button, {
                  key: 1,
                  class: vue.normalizeClass(_ctx.classes(_ctx.n("button"), _ctx.n("confirm-button"))),
                  "var-dialog-cover": "",
                  text: "",
                  "text-color": _ctx.confirmButtonTextColor,
                  color: _ctx.confirmButtonColor,
                  onClick: _ctx.confirm
                }, {
                  default: vue.withCtx(() => {
                    var _a;
                    return [
                      vue.createTextVNode(
                        vue.toDisplayString((_a = _ctx.confirmButtonText) != null ? _a : (_ctx.pt ? _ctx.pt : _ctx.t)("dialogConfirmButtonText")),
                        1
                        /* TEXT */
                      )
                    ];
                  }),
                  _: 1
                  /* STABLE */
                }, 8, ["class", "text-color", "color", "onClick"])) : vue.createCommentVNode("v-if", true)
              ],
              2
              /* CLASS */
            )
          ])
        ],
        16
        /* FULL_PROPS */
      )
    ]),
    _: 3
    /* FORWARDED */
  }, 8, ["class", "show", "overlay", "overlay-class", "overlay-style", "lock-scroll", "close-on-click-overlay", "teleport", "onOpen", "onClose", "onClosed", "onOpened", "onKeyEscape", "onRouteChange", "onClickOverlay"]);
}
const __sfc__$P = vue.defineComponent({
  name: name$L,
  components: {
    VarPopup: stdin_default$64,
    VarButton: stdin_default$5t
  },
  inheritAttrs: false,
  props: props$K,
  setup(props2) {
    const popupShow = vue.ref(false);
    const popupCloseOnClickOverlay = vue.ref(false);
    const { t: pt } = injectLocaleProvider();
    vue.watch(
      () => props2.show,
      (newValue) => {
        popupShow.value = newValue;
      },
      { immediate: true }
    );
    vue.watch(
      () => props2.closeOnClickOverlay,
      (newValue) => {
        if (props2.onBeforeClose != null) {
          popupCloseOnClickOverlay.value = false;
          return;
        }
        popupCloseOnClickOverlay.value = newValue;
      },
      { immediate: true }
    );
    function done() {
      return call(props2["onUpdate:show"], false);
    }
    function handleClickOverlay() {
      const { closeOnClickOverlay, onClickOverlay, onBeforeClose } = props2;
      call(onClickOverlay);
      if (!closeOnClickOverlay) {
        return;
      }
      if (onBeforeClose != null) {
        call(onBeforeClose, "close", done);
        return;
      }
      call(props2["onUpdate:show"], false);
    }
    function confirm() {
      const { onBeforeClose, onConfirm } = props2;
      call(onConfirm);
      if (onBeforeClose != null) {
        call(onBeforeClose, "confirm", done);
        return;
      }
      call(props2["onUpdate:show"], false);
    }
    function cancel() {
      const { onBeforeClose, onCancel } = props2;
      call(onCancel);
      if (onBeforeClose != null) {
        call(onBeforeClose, "cancel", done);
        return;
      }
      call(props2["onUpdate:show"], false);
    }
    function handleKeyEscape() {
      call(props2.onKeyEscape);
      if (!props2.closeOnKeyEscape) {
        return;
      }
      cancel();
    }
    return {
      popupShow,
      popupCloseOnClickOverlay,
      pt,
      t,
      n: n$O,
      classes: classes$E,
      handleClickOverlay,
      confirm,
      cancel,
      toSizeUnit,
      handleKeyEscape
    };
  }
});
__sfc__$P.render = __render__$M;
var stdin_default$4K = __sfc__$P;
var __defProp$d = Object.defineProperty;
var __defProps$5 = Object.defineProperties;
var __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$d = Object.getOwnPropertySymbols;
var __hasOwnProp$d = Object.prototype.hasOwnProperty;
var __propIsEnum$d = Object.prototype.propertyIsEnumerable;
var __defNormalProp$d = (obj, key3, value) => key3 in obj ? __defProp$d(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$d = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$d.call(b, prop))
      __defNormalProp$d(a, prop, b[prop]);
  if (__getOwnPropSymbols$d)
    for (var prop of __getOwnPropSymbols$d(b)) {
      if (__propIsEnum$d.call(b, prop))
        __defNormalProp$d(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));
let singletonOptions$2;
let defaultOptions$2 = {};
function normalizeOptions$2(options = {}) {
  if (isString(options)) {
    return __spreadProps$5(__spreadValues$d({}, defaultOptions$2), { message: options });
  }
  return __spreadValues$d(__spreadValues$d({}, defaultOptions$2), options);
}
function Dialog(options) {
  if (!inBrowser()) {
    return Promise.resolve();
  }
  return new Promise((resolve) => {
    Dialog.close();
    const dialogOptions = normalizeOptions$2(options);
    const reactiveDialogOptions = vue.reactive(dialogOptions);
    reactiveDialogOptions.teleport = "body";
    singletonOptions$2 = reactiveDialogOptions;
    const { unmountInstance } = mountInstance(stdin_default$4K, reactiveDialogOptions, {
      onConfirm: () => {
        call(reactiveDialogOptions.onConfirm);
        resolve("confirm");
      },
      onCancel: () => {
        call(reactiveDialogOptions.onCancel);
        resolve("cancel");
      },
      onClose: () => {
        call(reactiveDialogOptions.onClose);
        resolve("close");
      },
      onClosed: () => {
        call(reactiveDialogOptions.onClosed);
        unmountInstance();
        singletonOptions$2 === reactiveDialogOptions && (singletonOptions$2 = null);
      },
      onRouteChange: () => {
        unmountInstance();
        singletonOptions$2 === reactiveDialogOptions && (singletonOptions$2 = null);
      },
      "onUpdate:show": (value) => {
        reactiveDialogOptions.show = value;
      }
    });
    reactiveDialogOptions.show = true;
  });
}
Dialog.setDefaultOptions = function(options) {
  defaultOptions$2 = options;
};
Dialog.resetDefaultOptions = function() {
  defaultOptions$2 = {};
};
Dialog.close = function() {
  if (singletonOptions$2 != null) {
    const prevSingletonOptions = singletonOptions$2;
    singletonOptions$2 = null;
    vue.nextTick().then(() => {
      prevSingletonOptions.show = false;
    });
  }
};
Dialog.Component = stdin_default$4K;
withInstall(stdin_default$4K);
withInstall(stdin_default$4K, Dialog);
withPropsDefaultsSetter(Dialog, props$K);
const _DialogComponent = stdin_default$4K;
var stdin_default$4J = Dialog;
const props$J = {
  inset: {
    type: [Boolean, Number, String],
    default: false
  },
  vertical: Boolean,
  description: String,
  margin: String,
  dashed: Boolean,
  hairline: Boolean
};
const { name: name$K, n: n$N, classes: classes$D } = createNamespace("divider");
function __render__$L(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(
        _ctx.classes(
          _ctx.n(),
          _ctx.n("$--box"),
          [_ctx.vertical, _ctx.n("--vertical")],
          [_ctx.withText, _ctx.n("--with-text")],
          [_ctx.withPresetInset, _ctx.n("--inset")],
          [_ctx.dashed, _ctx.n("--dashed")],
          [_ctx.hairline, _ctx.n("--hairline")]
        )
      ),
      style: vue.normalizeStyle(_ctx.style),
      role: "separator"
    },
    [
      !_ctx.vertical ? vue.renderSlot(_ctx.$slots, "default", { key: 0 }, () => [
        _ctx.description ? (vue.openBlock(), vue.createElementBlock(
          "span",
          {
            key: 0,
            class: vue.normalizeClass(_ctx.n("text"))
          },
          vue.toDisplayString(_ctx.description),
          3
          /* TEXT, CLASS */
        )) : vue.createCommentVNode("v-if", true)
      ]) : vue.createCommentVNode("v-if", true)
    ],
    6
    /* CLASS, STYLE */
  );
}
const __sfc__$O = vue.defineComponent({
  name: name$K,
  props: props$J,
  setup(props2, { slots }) {
    const withText = vue.ref(false);
    const withPresetInset = vue.computed(() => {
      const { vertical, inset } = props2;
      return !vertical && inset === true;
    });
    const style = vue.computed(() => {
      const { inset, vertical, margin } = props2;
      if (isBoolean(inset) || vertical) {
        return { margin };
      }
      const _inset = toNumber(inset);
      const absInsetWithUnit = Math.abs(_inset) + (inset + "").replace(_inset + "", "");
      return {
        margin,
        width: `calc(100% - ${toSizeUnit(absInsetWithUnit)})`,
        left: _inset > 0 ? toSizeUnit(absInsetWithUnit) : toSizeUnit(0)
      };
    });
    onSmartMounted(checkHasText);
    vue.onUpdated(checkHasText);
    function checkHasText() {
      const { description, vertical } = props2;
      withText.value = (slots.default || description != null) && !vertical;
    }
    return {
      n: n$N,
      classes: classes$D,
      withText,
      style,
      withPresetInset
    };
  }
});
__sfc__$O.render = __render__$L;
var stdin_default$4I = __sfc__$O;
withInstall(stdin_default$4I);
withPropsDefaultsSetter(stdin_default$4I, props$J);
const _DividerComponent = stdin_default$4I;
var stdin_default$4H = stdin_default$4I;
const props$I = {
  direction: {
    type: String,
    default: "xy"
  },
  attraction: String,
  disabled: Boolean,
  boundary: {
    type: Object,
    default: () => ({
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    })
  },
  zIndex: {
    type: [Number, String],
    default: 90
  },
  teleport: {
    type: [String, Object, Boolean],
    default: "body"
  },
  onClick: defineListenerProp()
};
var __defProp$c = Object.defineProperty;
var __defProps$4 = Object.defineProperties;
var __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$c = Object.getOwnPropertySymbols;
var __hasOwnProp$c = Object.prototype.hasOwnProperty;
var __propIsEnum$c = Object.prototype.propertyIsEnumerable;
var __defNormalProp$c = (obj, key3, value) => key3 in obj ? __defProp$c(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$c = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$c.call(b, prop))
      __defNormalProp$c(a, prop, b[prop]);
  if (__getOwnPropSymbols$c)
    for (var prop of __getOwnPropSymbols$c(b)) {
      if (__propIsEnum$c.call(b, prop))
        __defNormalProp$c(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));
const { name: name$J, n: n$M, classes: classes$C } = createNamespace("drag");
function __render__$K(_ctx, _cache) {
  return vue.openBlock(), vue.createBlock(vue.Teleport, {
    to: _ctx.teleport === false ? void 0 : _ctx.teleport,
    disabled: _ctx.teleportDisabled || _ctx.teleport === false
  }, [
    vue.createElementVNode(
      "div",
      vue.mergeProps({
        ref: "drag",
        class: _ctx.classes(_ctx.n(), _ctx.n("$--box"), [_ctx.enableTransition, _ctx.n("--transition")]),
        style: {
          "z-index": _ctx.zIndex
        }
      }, _ctx.getAttrs(), {
        onTouchstart: _cache[0] || (_cache[0] = (...args) => _ctx.handleTouchstart && _ctx.handleTouchstart(...args)),
        onTouchmove: _cache[1] || (_cache[1] = (...args) => _ctx.handleTouchmove && _ctx.handleTouchmove(...args)),
        onTouchend: _cache[2] || (_cache[2] = (...args) => _ctx.handleTouchend && _ctx.handleTouchend(...args)),
        onTouchcancel: _cache[3] || (_cache[3] = (...args) => _ctx.handleTouchend && _ctx.handleTouchend(...args)),
        onClick: _cache[4] || (_cache[4] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
      }),
      [
        vue.renderSlot(_ctx.$slots, "default")
      ],
      16
      /* FULL_PROPS */
    )
  ], 8, ["to", "disabled"]);
}
const __sfc__$N = vue.defineComponent({
  name: name$J,
  inheritAttrs: false,
  props: props$I,
  setup(props2, { attrs }) {
    const drag = vue.ref(null);
    const x = vue.ref(0);
    const y = vue.ref(0);
    const dragged = vue.ref(false);
    const enableTransition = vue.ref(false);
    const { touching, dragging, moveX, moveY, startTouch, moveTouch, endTouch, resetTouch } = useTouch();
    const { disabled: teleportDisabled } = useTeleport();
    const boundary = vue.reactive({
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    });
    vue.watch(() => props2.boundary, toPxBoundary);
    onWindowResize(resize);
    onSmartMounted(() => {
      toPxBoundary();
      resize();
    });
    function handleTouchstart(event) {
      if (props2.disabled) {
        return;
      }
      startTouch(event);
      saveXY();
    }
    function handleTouchmove(event) {
      if (!touching.value || props2.disabled) {
        return;
      }
      moveTouch(event);
      preventDefault(event);
      enableTransition.value = false;
      dragged.value = true;
      if (props2.direction.includes("x")) {
        x.value += moveX.value;
      }
      if (props2.direction.includes("y")) {
        y.value += moveY.value;
      }
      clampToBoundary();
    }
    function handleTouchend() {
      if (props2.disabled) {
        return;
      }
      endTouch();
      enableTransition.value = true;
      attract();
    }
    function handleClick(event) {
      if (dragging.value) {
        return;
      }
      call(props2.onClick, event);
    }
    function saveXY() {
      const { left: left2, top: top2 } = getOffset();
      x.value = left2;
      y.value = top2;
    }
    function getOffset() {
      const dragRect = getRect(drag.value);
      const windowRect = getRect(window);
      const top2 = dragRect.top - windowRect.top;
      const bottom2 = windowRect.bottom - dragRect.bottom;
      const left2 = dragRect.left - windowRect.left;
      const right2 = windowRect.right - dragRect.right;
      const { width, height } = dragRect;
      const { width: windowWidth, height: windowHeight } = windowRect;
      return {
        top: top2,
        bottom: bottom2,
        left: left2,
        right: right2,
        width,
        height,
        halfWidth: width / 2,
        halfHeight: height / 2,
        windowWidth,
        windowHeight
      };
    }
    function getRange() {
      const offset2 = getOffset();
      const x1 = boundary.left;
      const x2 = offset2.windowWidth - boundary.right - offset2.width;
      const y1 = boundary.top;
      const y2 = offset2.windowHeight - boundary.bottom - offset2.height;
      return {
        minX: x1,
        minY: y1,
        // fallback the drag element overflows boundary
        maxX: x1 < x2 ? x2 : x1,
        maxY: y1 < y2 ? y2 : y1
      };
    }
    function attract() {
      if (props2.attraction == null) {
        return;
      }
      const { halfWidth, halfHeight, top: top2, bottom: bottom2, left: left2, right: right2 } = getOffset();
      const { minX, minY, maxX, maxY } = getRange();
      const leftDistance = left2 + halfWidth - boundary.left;
      const rightDistance = right2 + halfWidth - boundary.right;
      const topDistance = top2 + halfHeight - boundary.top;
      const bottomDistance = bottom2 + halfHeight - boundary.bottom;
      const nearLeft = leftDistance <= rightDistance;
      const nearTop = topDistance <= bottomDistance;
      if (props2.attraction.includes("x")) {
        x.value = nearLeft ? minX : maxX;
      }
      if (props2.attraction.includes("y")) {
        y.value = nearTop ? minY : maxY;
      }
    }
    function clampToBoundary() {
      const { minX, minY, maxX, maxY } = getRange();
      x.value = clamp$1(x.value, minX, maxX);
      y.value = clamp$1(y.value, minY, maxY);
    }
    function toPxBoundary() {
      const { top: top2 = 0, bottom: bottom2 = 0, left: left2 = 0, right: right2 = 0 } = props2.boundary;
      boundary.top = toPxNum(top2);
      boundary.bottom = toPxNum(bottom2);
      boundary.left = toPxNum(left2);
      boundary.right = toPxNum(right2);
    }
    function getAttrs() {
      var _a;
      const style = (_a = attrs.style) != null ? _a : {};
      return __spreadProps$4(__spreadValues$c({}, attrs), {
        style: __spreadProps$4(__spreadValues$c({}, style), {
          // when the drag element is dragged for the first time, the inset should be cleared to avoid affecting translateX and translateY.
          top: dragged.value ? 0 : style.top,
          left: dragged.value ? 0 : style.left,
          right: dragged.value ? "auto" : style.right,
          bottom: dragged.value ? "auto" : style.bottom,
          transform: dragged.value ? `translate(${x.value}px, ${y.value}px)` : style.transform
        })
      });
    }
    function resize() {
      if (!dragged.value) {
        return;
      }
      saveXY();
      clampToBoundary();
    }
    function reset() {
      resetTouch();
      enableTransition.value = false;
      dragged.value = false;
      x.value = 0;
      y.value = 0;
    }
    return {
      drag,
      x,
      y,
      enableTransition,
      dragging,
      teleportDisabled,
      n: n$M,
      classes: classes$C,
      getAttrs,
      handleTouchstart,
      handleTouchmove,
      handleTouchend,
      handleClick,
      resize,
      reset
    };
  }
});
__sfc__$N.render = __render__$K;
var stdin_default$4G = __sfc__$N;
withInstall(stdin_default$4G);
withPropsDefaultsSetter(stdin_default$4G, props$I);
const _DragComponent = stdin_default$4G;
var stdin_default$4F = stdin_default$4G;
const props$H = {
  type: {
    type: String,
    default: "default"
  },
  color: String,
  textColor: String,
  content: String,
  show: Boolean,
  disabled: Boolean,
  trigger: {
    type: String,
    default: "hover"
  },
  reference: [String, Object],
  placement: {
    type: String,
    default: "bottom"
  },
  strategy: {
    type: String,
    default: "absolute"
  },
  offsetX: {
    type: [Number, String],
    default: 0
  },
  offsetY: {
    type: [Number, String],
    default: 0
  },
  teleport: {
    type: [String, Object, Boolean],
    default: "body"
  },
  sameWidth: Boolean,
  closeOnClickReference: Boolean,
  closeOnKeyEscape: {
    type: Boolean,
    default: true
  },
  onOpen: defineListenerProp(),
  onOpened: defineListenerProp(),
  onClose: defineListenerProp(),
  onClosed: defineListenerProp(),
  onClickOutside: defineListenerProp(),
  "onUpdate:show": defineListenerProp()
};
const { name: name$I, n: n$L, classes: classes$B } = createNamespace("tooltip");
function __render__$J(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      ref: "host",
      class: vue.normalizeClass(_ctx.classes(_ctx.n(), _ctx.n("$--box")))
    },
    [
      vue.renderSlot(_ctx.$slots, "default"),
      (vue.openBlock(), vue.createBlock(vue.Teleport, {
        to: _ctx.teleport === false ? void 0 : _ctx.teleport,
        disabled: _ctx.teleportDisabled || _ctx.teleport === false
      }, [
        vue.createVNode(vue.Transition, {
          name: _ctx.n(),
          onAfterEnter: _ctx.onOpened,
          onAfterLeave: _ctx.handleClosed,
          persisted: ""
        }, {
          default: vue.withCtx(() => [
            vue.withDirectives(vue.createElementVNode(
              "div",
              {
                ref: "popover",
                class: vue.normalizeClass(_ctx.classes(_ctx.n("tooltip"), _ctx.n("$--box"))),
                style: vue.normalizeStyle({ zIndex: _ctx.zIndex }),
                onClick: _cache[0] || (_cache[0] = vue.withModifiers(() => {
                }, ["stop"])),
                onMouseenter: _cache[1] || (_cache[1] = (...args) => _ctx.handlePopoverMouseenter && _ctx.handlePopoverMouseenter(...args)),
                onMouseleave: _cache[2] || (_cache[2] = (...args) => _ctx.handlePopoverMouseleave && _ctx.handlePopoverMouseleave(...args))
              },
              [
                vue.createElementVNode(
                  "div",
                  {
                    style: vue.normalizeStyle({
                      background: _ctx.color,
                      color: _ctx.textColor,
                      width: _ctx.sameWidth ? _ctx.toSizeUnit(Math.ceil(_ctx.referenceSize.width)) : void 0
                    }),
                    class: vue.normalizeClass(_ctx.classes(_ctx.n("content-container"), _ctx.n(`--${_ctx.type}`))),
                    role: "tooltip"
                  },
                  [
                    vue.renderSlot(_ctx.$slots, "content", {}, () => [
                      vue.createTextVNode(
                        vue.toDisplayString(_ctx.content),
                        1
                        /* TEXT */
                      )
                    ])
                  ],
                  6
                  /* CLASS, STYLE */
                )
              ],
              38
              /* CLASS, STYLE, NEED_HYDRATION */
            ), [
              [vue.vShow, _ctx.show]
            ])
          ]),
          _: 3
          /* FORWARDED */
        }, 8, ["name", "onAfterEnter", "onAfterLeave"])
      ], 8, ["to", "disabled"]))
    ],
    2
    /* CLASS */
  );
}
const __sfc__$M = vue.defineComponent({
  name: name$I,
  props: props$H,
  setup(props2) {
    const { disabled: teleportDisabled } = useTeleport();
    const {
      popover,
      host,
      referenceSize,
      show,
      zIndex,
      handlePopoverMouseenter,
      handlePopoverMouseleave,
      handlePopoverClose,
      handleClosed,
      // expose
      open,
      // expose
      close,
      // expose
      resize,
      // expose
      setReference
    } = usePopover(props2);
    return {
      popover,
      host,
      referenceSize,
      show,
      zIndex,
      teleportDisabled,
      toSizeUnit,
      n: n$L,
      classes: classes$B,
      handlePopoverClose,
      handlePopoverMouseenter,
      handlePopoverMouseleave,
      handleClosed,
      resize,
      open,
      close,
      setReference
    };
  }
});
__sfc__$M.render = __render__$J;
var stdin_default$4E = __sfc__$M;
withInstall(stdin_default$4E);
withPropsDefaultsSetter(stdin_default$4E, props$H);
const _TooltipComponent = stdin_default$4E;
var stdin_default$4D = stdin_default$4E;
const props$G = {
  expand: Boolean,
  expandTrigger: String,
  lineClamp: [Number, String],
  tooltip: {
    type: [Object, Boolean],
    default: true
  },
  "onUpdate:expand": defineListenerProp()
};
var __defProp$b = Object.defineProperty;
var __getOwnPropSymbols$b = Object.getOwnPropertySymbols;
var __hasOwnProp$b = Object.prototype.hasOwnProperty;
var __propIsEnum$b = Object.prototype.propertyIsEnumerable;
var __defNormalProp$b = (obj, key3, value) => key3 in obj ? __defProp$b(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$b = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$b.call(b, prop))
      __defNormalProp$b(a, prop, b[prop]);
  if (__getOwnPropSymbols$b)
    for (var prop of __getOwnPropSymbols$b(b)) {
      if (__propIsEnum$b.call(b, prop))
        __defNormalProp$b(a, prop, b[prop]);
    }
  return a;
};
const { name: name$H, n: n$K, classes: classes$A } = createNamespace("ellipsis");
const _hoisted_1$m = { key: 0 };
function __render__$I(_ctx, _cache) {
  const _component_var_tooltip = vue.resolveComponent("var-tooltip");
  return vue.openBlock(), vue.createBlock(
    _component_var_tooltip,
    vue.normalizeProps(vue.guardReactiveProps(_ctx.tooltipProps)),
    {
      content: vue.withCtx(() => [
        vue.renderSlot(_ctx.$slots, "tooltip-content", {}, () => {
          var _a;
          return [
            ((_a = _ctx.tooltipProps) == null ? void 0 : _a.content) ? (vue.openBlock(), vue.createElementBlock(
              "span",
              _hoisted_1$m,
              vue.toDisplayString(_ctx.tooltipProps.content),
              1
              /* TEXT */
            )) : vue.renderSlot(_ctx.$slots, "default", { key: 1 })
          ];
        })
      ]),
      default: vue.withCtx(() => [
        vue.createElementVNode(
          "span",
          {
            class: vue.normalizeClass(
              _ctx.classes(_ctx.n(), [_ctx.lineClamp, _ctx.n("--clamp"), _ctx.n("--line")], [_ctx.expandTrigger, _ctx.n("--cursor")], [_ctx.expanding, _ctx.n("--expand")])
            ),
            style: vue.normalizeStyle(_ctx.rootStyles),
            onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
          },
          [
            vue.renderSlot(_ctx.$slots, "default")
          ],
          6
          /* CLASS, STYLE */
        )
      ]),
      _: 3
      /* FORWARDED */
    },
    16
    /* FULL_PROPS */
  );
}
const __sfc__$L = vue.defineComponent({
  name: name$H,
  components: { VarTooltip: stdin_default$4D },
  props: props$G,
  setup(props2) {
    const expanding = useVModel(props2, "expand");
    const rootStyles = vue.computed(() => props2.lineClamp ? { "-webkit-line-clamp": props2.lineClamp } : {});
    const tooltipProps = vue.computed(() => {
      if (props2.tooltip === false) {
        return {
          disabled: true
        };
      }
      if (props2.tooltip === true) {
        return {
          sameWidth: true
        };
      }
      return __spreadValues$b({ sameWidth: true }, props2.tooltip);
    });
    function handleClick() {
      if (!props2.expandTrigger) {
        return;
      }
      expanding.value = !expanding.value;
    }
    return {
      tooltipProps,
      expanding,
      rootStyles,
      n: n$K,
      classes: classes$A,
      handleClick
    };
  }
});
__sfc__$L.render = __render__$I;
var stdin_default$4C = __sfc__$L;
withInstall(stdin_default$4C);
withPropsDefaultsSetter(stdin_default$4C, props$G);
const _EllipsisComponent = stdin_default$4C;
var stdin_default$4B = stdin_default$4C;
const props$F = {
  active: Boolean,
  show: {
    type: Boolean,
    default: true
  },
  drag: {
    type: [Object, Boolean],
    default: false
  },
  type: {
    type: String,
    default: "primary"
  },
  position: {
    type: String,
    default: "right-bottom"
  },
  direction: {
    type: String,
    default: "top"
  },
  trigger: {
    type: String,
    default: "click"
  },
  disabled: Boolean,
  color: String,
  inactiveIcon: {
    type: String,
    default: "plus"
  },
  activeIcon: {
    type: String,
    default: "window-close"
  },
  inactiveIconSize: pickProps(props$1j, "size"),
  activeIconSize: pickProps(props$1j, "size"),
  inactiveIconNamespace: pickProps(props$1j, "namespace"),
  activeIconNamespace: pickProps(props$1j, "namespace"),
  fixed: {
    type: Boolean,
    default: true
  },
  zIndex: {
    type: [Number, String],
    default: 90
  },
  top: [Number, String],
  bottom: [Number, String],
  left: [Number, String],
  right: [Number, String],
  elevation: {
    type: [Boolean, Number, String],
    default: true
  },
  safeArea: Boolean,
  teleport: {
    type: [String, Object, Boolean],
    default: "body"
  },
  onClick: defineListenerProp(),
  onOpen: defineListenerProp(),
  onOpened: defineListenerProp(),
  onClose: defineListenerProp(),
  onClosed: defineListenerProp(),
  "onUpdate:active": defineListenerProp()
};
const {
  name: name$G,
  classes: classes$z,
  n: n$J
} = createNamespace("fab");
var stdin_default$4A = vue.defineComponent({
  name: name$G,
  inheritAttrs: false,
  props: props$F,
  setup(props2, {
    slots,
    attrs
  }) {
    const isActive = useVModel(props2, "active");
    const host = vue.ref(null);
    const dragRef = vue.ref(null);
    vue.watch(() => props2.trigger, () => {
      isActive.value = false;
    });
    vue.watch(() => props2.disabled, () => {
      isActive.value = false;
    });
    vue.watch(() => [props2.position, props2.fixed, props2.top, props2.bottom, props2.left, props2.right], () => {
      var _a;
      (_a = dragRef.value) == null ? void 0 : _a.reset();
    });
    useClickOutside(host, "click", handleClickOutside);
    function handleClick(e, value, childrenLength) {
      e.stopPropagation();
      if (props2.trigger !== "click" || props2.disabled) {
        return;
      }
      if (childrenLength === 0) {
        call(props2.onClick, isActive.value, e);
        return;
      }
      isActive.value = value;
      call(props2.onClick, isActive.value, e);
      call(isActive.value ? props2.onOpen : props2.onClose);
    }
    function handleMouse(value, childrenLength) {
      if (props2.trigger !== "hover" || props2.disabled || childrenLength === 0) {
        return;
      }
      isActive.value = value;
      call(isActive.value ? props2.onOpen : props2.onClose);
    }
    function handleClickOutside() {
      if (props2.trigger !== "click" || props2.disabled) {
        return;
      }
      if (isActive.value !== false) {
        isActive.value = false;
        call(props2.onClose);
      }
    }
    function renderTrigger() {
      if (slots.trigger) {
        return props2.show ? slots.trigger({
          active: isActive.value
        }) : null;
      }
      return vue.withDirectives(vue.createVNode(stdin_default$5t, {
        "var-fab-cover": true,
        "class": n$J("trigger"),
        "type": props2.type,
        "color": props2.color,
        "disabled": props2.disabled,
        "elevation": props2.elevation,
        "iconContainer": true
      }, {
        default: () => [vue.createVNode(stdin_default$5_, {
          "var-fab-cover": true,
          "class": classes$z([isActive.value, n$J("trigger-active-icon"), n$J("trigger-inactive-icon")]),
          "name": isActive.value ? props2.activeIcon : props2.inactiveIcon,
          "size": isActive.value ? props2.activeIconSize : props2.inactiveIconSize,
          "namespace": isActive.value ? props2.activeIconNamespace : props2.inactiveIconNamespace,
          "transition": 200,
          "animationClass": n$J("--trigger-icon-animation")
        }, null)]
      }), [[vue.vShow, props2.show]]);
    }
    return () => {
      var _a;
      const children = flatFragment((_a = call(slots.default)) != null ? _a : []);
      const dragProps = isBoolean(props2.drag) ? {} : props2.drag;
      return vue.createVNode(stdin_default$4F, vue.mergeProps({
        "ref": dragRef,
        "class": classes$z(n$J(`--position-${props2.position}`), [!props2.fixed, n$J("--absolute")]),
        "style": {
          top: toSizeUnit(props2.top),
          bottom: toSizeUnit(props2.bottom),
          left: toSizeUnit(props2.left),
          right: toSizeUnit(props2.right)
        },
        "zIndex": props2.zIndex,
        "teleport": props2.teleport,
        "disabled": props2.disabled || !props2.drag || !props2.fixed,
        "direction": dragProps.direction,
        "attraction": dragProps.attraction,
        "boundary": dragProps.boundary,
        "onClick": (e) => handleClick(e, !isActive.value, children.length)
      }, attrs), {
        default: () => [vue.createVNode("div", {
          "class": classes$z(n$J(), n$J(`--direction-${props2.direction}`), [props2.safeArea, n$J("--safe-area")]),
          "ref": host,
          "onMouseleave": () => handleMouse(false, children.length),
          "onMouseenter": () => handleMouse(true, children.length)
        }, [vue.createVNode(vue.Transition, {
          "name": n$J(`--active-transition`)
        }, {
          default: () => [renderTrigger()]
        }), vue.createVNode(vue.Transition, {
          "name": n$J(`--actions-transition-${props2.direction}`),
          "onAfterEnter": props2.onOpened,
          "onAfterLeave": props2.onClosed
        }, {
          default: () => [vue.withDirectives(vue.createVNode("div", {
            "class": n$J("actions"),
            "onClick": (e) => e.stopPropagation()
          }, [children.map((child) => {
            var _a2;
            return vue.createVNode("div", {
              "class": n$J("action"),
              "key": (_a2 = child.key) != null ? _a2 : void 0
            }, [child]);
          })]), [[vue.vShow, props2.show && isActive.value && children.length]])]
        })])]
      });
    };
  }
});
withInstall(stdin_default$4A);
withPropsDefaultsSetter(stdin_default$4A, props$F);
const _FabComponent = stdin_default$4A;
var stdin_default$4z = stdin_default$4A;
const props$E = {
  anchor: Number,
  anchors: Array,
  contentDraggable: {
    type: Boolean,
    default: true
  },
  duration: {
    type: [Number, String],
    default: 300
  },
  elevation: {
    type: [Boolean, Number, String],
    default: true
  },
  teleport: {
    type: [String, Object, Boolean],
    default: "body"
  },
  safeArea: Boolean,
  "onUpdate:anchor": defineListenerProp(),
  onAnchorChange: defineListenerProp()
};
const { name: name$F, n: n$I, classes: classes$y } = createNamespace("floating-panel");
const DEFAULT_START_ANCHOR = 100;
const OVERFLOW_REDUCE_RATIO = 0.2;
function __render__$H(_ctx, _cache) {
  return vue.openBlock(), vue.createBlock(vue.Teleport, {
    to: _ctx.teleport === false ? void 0 : _ctx.teleport,
    disabled: _ctx.teleportDisabled || _ctx.teleport === false
  }, [
    vue.createElementVNode(
      "div",
      {
        class: vue.normalizeClass(_ctx.classes(_ctx.n(), [_ctx.safeArea, _ctx.n("--safe-area")], _ctx.formatElevation(_ctx.elevation, 3))),
        style: vue.normalizeStyle({
          height: `${_ctx.toSizeUnit(_ctx.maxAnchor)}`,
          transform: `translateY(calc(100% - ${_ctx.toSizeUnit(_ctx.visibleHeight)}))`,
          transition: _ctx.touching ? "none" : `transform ${_ctx.toNumber(
            _ctx.duration
          )}ms var(--floating-panel-transition-timing-function), background-color 0.25s`
        }),
        onTouchstart: _cache[0] || (_cache[0] = (...args) => _ctx.handleTouchstart && _ctx.handleTouchstart(...args)),
        onTouchmove: _cache[1] || (_cache[1] = (...args) => _ctx.handleTouchmove && _ctx.handleTouchmove(...args)),
        onTouchend: _cache[2] || (_cache[2] = (...args) => _ctx.handleTouchend && _ctx.handleTouchend(...args)),
        onTouchcancel: _cache[3] || (_cache[3] = (...args) => _ctx.handleTouchend && _ctx.handleTouchend(...args))
      },
      [
        vue.renderSlot(_ctx.$slots, "header", {}, () => [
          vue.createElementVNode(
            "div",
            {
              class: vue.normalizeClass(_ctx.n("header"))
            },
            [
              vue.createElementVNode(
                "div",
                {
                  class: vue.normalizeClass(_ctx.n("header-toolbar"))
                },
                null,
                2
                /* CLASS */
              )
            ],
            2
            /* CLASS */
          )
        ]),
        vue.createElementVNode(
          "div",
          {
            ref: "contentRef",
            class: vue.normalizeClass(_ctx.n("content"))
          },
          [
            vue.renderSlot(_ctx.$slots, "default")
          ],
          2
          /* CLASS */
        )
      ],
      38
      /* CLASS, STYLE, NEED_HYDRATION */
    )
  ], 8, ["to", "disabled"]);
}
const __sfc__$K = vue.defineComponent({
  name: name$F,
  props: props$E,
  setup(props2) {
    const visibleHeight = vue.ref(0);
    const contentRef = vue.ref(null);
    const { height: windowHeight } = useWindowSize();
    const defaultEndAnchor = vue.computed(() => windowHeight.value * 0.6);
    const anchor = useVModel(props2, "anchor", { defaultValue: DEFAULT_START_ANCHOR });
    const anchors = vue.computed(() => {
      const defaultAnchors = [DEFAULT_START_ANCHOR, defaultEndAnchor.value];
      const { anchors: anchors2 } = props2;
      return isEmpty(anchors2) ? defaultAnchors : anchors2;
    });
    const minAnchor = vue.computed(() => Math.min(...anchors.value));
    const maxAnchor = vue.computed(() => Math.max(...anchors.value));
    const { disabled: teleportDisabled } = useTeleport();
    const { deltaY, touching, startTouch, moveTouch, endTouch, isReachTop, isReachBottom } = useTouch();
    let startVisibleHeight;
    useLock(() => touching.value);
    vue.watch(() => anchor.value, matchAnchor, { immediate: true });
    vue.watch(
      () => anchors.value,
      () => {
        matchAnchor(anchor.value);
      },
      { immediate: true }
    );
    function matchAnchor(anchor2) {
      setVisibleHeight(anchor2 != null ? anchor2 : minAnchor.value);
    }
    function handleTouchstart(event) {
      startTouch(event);
      startVisibleHeight = visibleHeight.value;
    }
    function handleTouchmove(event) {
      var _a;
      moveTouch(event);
      const target = event.target;
      const eventFromContent = contentRef.value === target || ((_a = contentRef.value) == null ? void 0 : _a.contains(target));
      if (eventFromContent && !props2.contentDraggable) {
        return;
      }
      if (eventFromContent && props2.contentDraggable && visibleHeight.value >= maxAnchor.value && !isReachTop(contentRef.value)) {
        if (isReachBottom(contentRef.value)) {
          preventDefault(event);
        }
        return;
      }
      const targetVisibleHeight = startVisibleHeight - deltaY.value;
      setVisibleHeight(clampVisibleHeight(targetVisibleHeight));
      preventDefault(event);
    }
    function handleTouchend() {
      endTouch();
      const oldAnchor = anchor.value;
      setVisibleHeight(visibleHeight.value);
      anchor.value = visibleHeight.value;
      if (anchor.value !== oldAnchor) {
        call(props2.onAnchorChange, visibleHeight.value);
      }
    }
    function setVisibleHeight(targetVisibleHeight) {
      visibleHeight.value = touching.value ? targetVisibleHeight : findNearestAnchor(targetVisibleHeight);
    }
    function clampVisibleHeight(visibleHeight2) {
      if (visibleHeight2 > maxAnchor.value) {
        const overflowHeight = visibleHeight2 - maxAnchor.value;
        return maxAnchor.value + overflowHeight * OVERFLOW_REDUCE_RATIO;
      }
      if (visibleHeight2 < minAnchor.value) {
        const overflowHeight = minAnchor.value - visibleHeight2;
        return minAnchor.value - overflowHeight * OVERFLOW_REDUCE_RATIO;
      }
      return visibleHeight2;
    }
    function findNearestAnchor(targetAnchor) {
      if (anchors.value.includes(targetAnchor)) {
        return targetAnchor;
      }
      let minDifference = Infinity;
      let nearestAnchor = 0;
      anchors.value.forEach((anchor2) => {
        const difference2 = Math.abs(anchor2 - targetAnchor);
        if (difference2 < minDifference) {
          minDifference = difference2;
          nearestAnchor = anchor2;
        }
      });
      return nearestAnchor;
    }
    return {
      contentRef,
      teleportDisabled,
      touching,
      minAnchor,
      maxAnchor,
      visibleHeight,
      n: n$I,
      classes: classes$y,
      toSizeUnit,
      toNumber,
      formatElevation,
      handleTouchstart,
      handleTouchmove,
      handleTouchend
    };
  }
});
__sfc__$K.render = __render__$H;
var stdin_default$4y = __sfc__$K;
withInstall(stdin_default$4y);
withPropsDefaultsSetter(stdin_default$4y, props$E);
const _FloatingPanelComponent = stdin_default$4y;
var stdin_default$4x = stdin_default$4y;
const props$D = {
  disabled: Boolean,
  readonly: Boolean,
  scrollToError: String,
  scrollToErrorOffsetY: {
    type: [String, Number],
    default: 0
  },
  onSubmit: defineListenerProp(),
  onReset: defineListenerProp()
};
var __async$8 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const { name: name$E, n: n$H } = createNamespace("form");
function __render__$G(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock(
    "form",
    {
      class: vue.normalizeClass(_ctx.n()),
      onSubmit: _cache[0] || (_cache[0] = (...args) => _ctx.handleSubmit && _ctx.handleSubmit(...args)),
      onReset: _cache[1] || (_cache[1] = (...args) => _ctx.handleReset && _ctx.handleReset(...args))
    },
    [
      vue.renderSlot(_ctx.$slots, "default")
    ],
    34
    /* CLASS, NEED_HYDRATION */
  );
}
const __sfc__$J = vue.defineComponent({
  name: name$E,
  props: props$D,
  setup(props2) {
    const disabled = vue.computed(() => props2.disabled);
    const readonly = vue.computed(() => props2.readonly);
    const { formItems, bindFormItems } = useFormItems();
    const formProvider = {
      disabled,
      readonly
    };
    bindFormItems(formProvider);
    function scroll(formItemElement) {
      setTimeout(() => {
        const scroller = getParentScroller(formItemElement);
        const scrollerTop = scroller === window ? 0 : getTop$1(scroller);
        const top2 = getTop$1(formItemElement) - scrollerTop - toPxNum(props2.scrollToErrorOffsetY);
        scrollTo(scroller, {
          top: top2,
          animation: linear
        });
      }, 300);
    }
    function handleSubmit(event) {
      return __async$8(this, null, function* () {
        preventDefault(event);
        const valid = yield validate();
        call(props2.onSubmit, valid);
      });
    }
    function handleReset(event) {
      preventDefault(event);
      reset();
      call(props2.onReset);
    }
    function validate() {
      return __async$8(this, null, function* () {
        var _a;
        const res = yield Promise.all(formItems.map(({ validate: validate2 }) => validate2()));
        if (props2.scrollToError) {
          const [, errorIndex] = find(res, (r) => r === false, props2.scrollToError);
          const hasError = errorIndex > -1;
          if (hasError) {
            const formItemElement = (_a = formItems[errorIndex].instance.proxy) == null ? void 0 : _a.$el;
            scroll(formItemElement);
          }
          return !hasError;
        }
        return res.every((result) => result === true);
      });
    }
    function reset() {
      return formItems.forEach(({ reset: reset2 }) => reset2());
    }
    function resetValidation() {
      return formItems.forEach(({ resetValidation: resetValidation2 }) => resetValidation2());
    }
    return {
      n: n$H,
      handleSubmit,
      handleReset,
      validate,
      reset,
      resetValidation
    };
  }
});
__sfc__$J.render = __render__$G;
var stdin_default$4w = __sfc__$J;
stdin_default$4w.useValidation = useValidation;
stdin_default$4w.useForm = useForm;
withInstall(stdin_default$4w);
withPropsDefaultsSetter(stdin_default$4w, props$D);
const _FormComponent = stdin_default$4w;
var stdin_default$4v = stdin_default$4w;
const props$C = {
  highlighter: Object,
  theme: String,
  tag: {
    type: String,
    default: "div"
  }
};
const { name: name$D, n: n$G } = createNamespace("highlighter-provider");
const __sfc__$I = vue.defineComponent({
  name: name$D,
  props: props$C,
  setup(props2, { slots }) {
    const highlighter = vue.computed(() => props2.highlighter);
    const theme = vue.computed(() => props2.theme);
    provideHighlighterProvider({ highlighter, theme });
    return () => vue.h(
      props2.tag,
      {
        class: n$G()
      },
      call(slots.default)
    );
  }
});
var stdin_default$4u = __sfc__$I;
withInstall(stdin_default$4u);
withPropsDefaultsSetter(stdin_default$4u, props$C);
const _HighlighterProviderComponent = stdin_default$4u;
var stdin_default$4t = stdin_default$4u;
const props$B = {
  src: String,
  fit: {
    type: String,
    default: "fill"
  },
  position: {
    type: String,
    default: "50% 50%"
  },
  alt: String,
  title: String,
  referrerpolicy: String,
  width: [String, Number],
  height: [String, Number],
  radius: {
    type: [String, Number],
    default: 0
  },
  loading: String,
  error: String,
  lazy: Boolean,
  ripple: Boolean,
  block: {
    type: Boolean,
    default: true
  },
  onClick: defineListenerProp(),
  onLoad: defineListenerProp(),
  onError: defineListenerProp()
};
const { name: name$C, n: n$F, classes: classes$x } = createNamespace("image");
const _hoisted_1$l = ["alt", "title", "referrerpolicy", "lazy-loading", "lazy-error"];
const _hoisted_2$6 = ["alt", "title", "referrerpolicy", "src"];
function __render__$F(_ctx, _cache) {
  var _a;
  const _directive_lazy = vue.resolveDirective("lazy");
  const _directive_ripple = vue.resolveDirective("ripple");
  return vue.withDirectives((vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.classes(_ctx.n(), _ctx.n("$--box"), [!_ctx.block, _ctx.n("$--inline-block")])),
      style: vue.normalizeStyle({
        width: _ctx.toSizeUnit(_ctx.width),
        height: _ctx.toSizeUnit(_ctx.height),
        borderRadius: _ctx.toSizeUnit(_ctx.radius)
      })
    },
    [
      _ctx.lazy && !_ctx.showErrorSlot ? vue.withDirectives((vue.openBlock(), vue.createElementBlock("img", {
        key: 0,
        role: "img",
        class: vue.normalizeClass(_ctx.n("image")),
        alt: _ctx.alt,
        title: _ctx.title,
        referrerpolicy: _ctx.referrerpolicy,
        "lazy-loading": _ctx.loading,
        "lazy-error": _ctx.error,
        style: vue.normalizeStyle({ objectFit: _ctx.fit, objectPosition: _ctx.position }),
        onLoad: _cache[0] || (_cache[0] = (...args) => _ctx.handleLoad && _ctx.handleLoad(...args)),
        onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
      }, null, 46, _hoisted_1$l)), [
        [_directive_lazy, (_a = _ctx.src) != null ? _a : ""]
      ]) : vue.createCommentVNode("v-if", true),
      !_ctx.lazy && !_ctx.showErrorSlot ? (vue.openBlock(), vue.createElementBlock("img", {
        key: 1,
        role: "img",
        class: vue.normalizeClass(_ctx.n("image")),
        alt: _ctx.alt,
        title: _ctx.title,
        referrerpolicy: _ctx.referrerpolicy,
        style: vue.normalizeStyle({ objectFit: _ctx.fit, objectPosition: _ctx.position }),
        src: _ctx.src,
        onLoad: _cache[2] || (_cache[2] = (...args) => _ctx.handleLoad && _ctx.handleLoad(...args)),
        onError: _cache[3] || (_cache[3] = (...args) => _ctx.handleError && _ctx.handleError(...args)),
        onClick: _cache[4] || (_cache[4] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
      }, null, 46, _hoisted_2$6)) : vue.createCommentVNode("v-if", true),
      _ctx.showErrorSlot ? vue.renderSlot(_ctx.$slots, "error", { key: 2 }) : vue.createCommentVNode("v-if", true)
    ],
    6
    /* CLASS, STYLE */
  )), [
    [_directive_ripple, { disabled: !_ctx.ripple }]
  ]);
}
const __sfc__$H = vue.defineComponent({
  name: name$C,
  directives: {
    Lazy: stdin_default$5B,
    Ripple: stdin_default$63
  },
  props: props$B,
  setup(props2, { slots }) {
    const showErrorSlot = vue.ref(false);
    vue.watch(
      () => props2.src,
      () => {
        showErrorSlot.value = false;
      }
    );
    function handleError(e) {
      showErrorSlot.value = !!slots.error;
      call(props2.onError, e);
    }
    function handleLoad(e) {
      const el = e.currentTarget;
      if (props2.lazy) {
        if (el._lazy.state === "success") {
          call(props2.onLoad, e);
          return;
        }
        if (el._lazy.state === "error") {
          handleError(e);
        }
      } else {
        call(props2.onLoad, e);
      }
    }
    function handleClick(e) {
      call(props2.onClick, e);
    }
    return {
      showErrorSlot,
      n: n$F,
      classes: classes$x,
      toSizeUnit,
      handleLoad,
      handleError,
      handleClick
    };
  }
});
__sfc__$H.render = __render__$F;
var stdin_default$4s = __sfc__$H;
withInstall(stdin_default$4s);
withPropsDefaultsSetter(stdin_default$4s, props$B);
const _ImageComponent = stdin_default$4s;
var stdin_default$4r = stdin_default$4s;
const props$A = {
  loop: {
    type: Boolean,
    default: true
  },
  autoplay: [String, Number],
  duration: {
    type: [String, Number],
    default: 300
  },
  initialIndex: {
    type: [String, Number],
    default: 0
  },
  navigation: {
    type: [Boolean, String],
    default: false
  },
  indicator: {
    type: Boolean,
    default: true
  },
  indicatorColor: String,
  vertical: Boolean,
  touchable: {
    type: Boolean,
    default: true
  },
  onChange: defineListenerProp()
};
var __async$7 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const SWIPE_DELAY = 250;
const SWIPE_OFFSET = 20;
const { name: name$B, n: n$E, classes: classes$w } = createNamespace("swipe");
const _hoisted_1$k = ["onClick"];
function __render__$E(_ctx, _cache) {
  const _component_var_icon = vue.resolveComponent("var-icon");
  const _component_var_button = vue.resolveComponent("var-button");
  const _directive_hover = vue.resolveDirective("hover");
  return vue.withDirectives((vue.openBlock(), vue.createElementBlock(
    "div",
    {
      ref: "swipeEl",
      class: vue.normalizeClass(_ctx.n())
    },
    [
      vue.createElementVNode(
        "div",
        {
          class: vue.normalizeClass(_ctx.classes(_ctx.n("track"), [_ctx.vertical, _ctx.n("--vertical")])),
          style: vue.normalizeStyle({
            width: !_ctx.vertical ? _ctx.toSizeUnit(_ctx.trackSize) : void 0,
            height: _ctx.vertical ? _ctx.toSizeUnit(_ctx.trackSize) : void 0,
            transform: `translate${_ctx.vertical ? "Y" : "X"}(${_ctx.toSizeUnit(_ctx.trackTranslate)})`,
            transitionDuration: _ctx.lockDuration ? "0ms" : `${_ctx.toNumber(_ctx.duration)}ms`
          }),
          onTouchstart: _cache[0] || (_cache[0] = (...args) => _ctx.handleTouchstart && _ctx.handleTouchstart(...args)),
          onTouchmove: _cache[1] || (_cache[1] = (...args) => _ctx.handleTouchmove && _ctx.handleTouchmove(...args)),
          onTouchend: _cache[2] || (_cache[2] = (...args) => _ctx.handleTouchend && _ctx.handleTouchend(...args))
        },
        [
          vue.renderSlot(_ctx.$slots, "default")
        ],
        38
        /* CLASS, STYLE, NEED_HYDRATION */
      ),
      _ctx.navigation ? vue.renderSlot(_ctx.$slots, "prev", vue.normalizeProps(vue.mergeProps({ key: 0 }, {
        index: _ctx.index,
        length: _ctx.length,
        prev: _ctx.prev,
        next: _ctx.next,
        to: _ctx.to,
        hovering: _ctx.hovering
      })), () => [
        vue.createVNode(vue.Transition, {
          name: _ctx.getNavigationAnimation("prev")
        }, {
          default: vue.withCtx(() => [
            _ctx.navigation === true || _ctx.hovering ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 0,
                class: vue.normalizeClass(_ctx.classes(_ctx.n("navigation"), _ctx.n("navigation-prev"), [_ctx.vertical, _ctx.n("--navigation-vertical-prev")]))
              },
              [
                vue.createVNode(_component_var_button, {
                  "var-swipe-cover": "",
                  disabled: !_ctx.loop && _ctx.index === 0,
                  class: vue.normalizeClass(_ctx.n("navigation-prev-button")),
                  onClick: _cache[3] || (_cache[3] = ($event) => _ctx.prev())
                }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(_component_var_icon, {
                      "var-swipe-cover": "",
                      class: vue.normalizeClass(_ctx.n("navigation-prev-button-icon")),
                      name: _ctx.vertical ? "chevron-up" : "chevron-left"
                    }, null, 8, ["class", "name"])
                  ]),
                  _: 1
                  /* STABLE */
                }, 8, ["disabled", "class"])
              ],
              2
              /* CLASS */
            )) : vue.createCommentVNode("v-if", true)
          ]),
          _: 1
          /* STABLE */
        }, 8, ["name"])
      ]) : vue.createCommentVNode("v-if", true),
      _ctx.navigation ? vue.renderSlot(_ctx.$slots, "next", vue.normalizeProps(vue.mergeProps({ key: 1 }, {
        index: _ctx.index,
        length: _ctx.length,
        hovering: _ctx.hovering,
        prev: _ctx.prev,
        next: _ctx.next,
        to: _ctx.to
      })), () => [
        vue.createVNode(vue.Transition, {
          name: _ctx.getNavigationAnimation("next")
        }, {
          default: vue.withCtx(() => [
            _ctx.navigation === true || _ctx.hovering ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 0,
                class: vue.normalizeClass(_ctx.classes(_ctx.n("navigation"), _ctx.n("navigation-next"), [_ctx.vertical, _ctx.n("--navigation-vertical-next")]))
              },
              [
                vue.createVNode(_component_var_button, {
                  "var-swipe-cover": "",
                  class: vue.normalizeClass(_ctx.n("navigation-next-button")),
                  disabled: !_ctx.loop && _ctx.index === _ctx.length - 1,
                  onClick: _cache[4] || (_cache[4] = ($event) => _ctx.next())
                }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(_component_var_icon, {
                      "var-swipe-cover": "",
                      class: vue.normalizeClass(_ctx.n("navigation-next-button-icon")),
                      name: _ctx.vertical ? "chevron-down" : "chevron-right"
                    }, null, 8, ["class", "name"])
                  ]),
                  _: 1
                  /* STABLE */
                }, 8, ["class", "disabled"])
              ],
              2
              /* CLASS */
            )) : vue.createCommentVNode("v-if", true)
          ]),
          _: 1
          /* STABLE */
        }, 8, ["name"])
      ]) : vue.createCommentVNode("v-if", true),
      vue.renderSlot(_ctx.$slots, "indicator", vue.normalizeProps(vue.guardReactiveProps({
        index: _ctx.index,
        length: _ctx.length,
        hovering: _ctx.hovering,
        prev: _ctx.prev,
        next: _ctx.next,
        to: _ctx.to
      })), () => [
        _ctx.indicator && _ctx.length ? (vue.openBlock(), vue.createElementBlock(
          "div",
          {
            key: 0,
            class: vue.normalizeClass(_ctx.classes(_ctx.n("indicators"), [_ctx.vertical, _ctx.n("--indicators-vertical")]))
          },
          [
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList(_ctx.length, (l, idx) => {
                return vue.openBlock(), vue.createElementBlock("div", {
                  key: l,
                  class: vue.normalizeClass(
                    _ctx.classes(_ctx.n("indicator"), [_ctx.index === idx, _ctx.n("--indicator-active")], [_ctx.vertical, _ctx.n("--indicator-vertical")])
                  ),
                  style: vue.normalizeStyle({ background: _ctx.indicatorColor }),
                  onClick: ($event) => _ctx.to(idx)
                }, null, 14, _hoisted_1$k);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ],
          2
          /* CLASS */
        )) : vue.createCommentVNode("v-if", true)
      ])
    ],
    2
    /* CLASS */
  )), [
    [_directive_hover, _ctx.handleHovering]
  ]);
}
const __sfc__$G = vue.defineComponent({
  name: name$B,
  directives: { Hover: stdin_default$62 },
  components: { VarButton: stdin_default$5t, VarIcon: stdin_default$5_ },
  props: props$A,
  setup(props2) {
    const swipeEl = vue.ref(null);
    const size = vue.ref(0);
    const vertical = vue.computed(() => props2.vertical);
    const trackSize = vue.ref(0);
    const trackTranslate = vue.ref(0);
    const lockDuration = vue.ref(false);
    const index = vue.ref(0);
    const hovering = vue.ref(false);
    const { swipeItems, bindSwipeItems, length } = useSwipeItems();
    const { swipeResizeListeners, bindSwipeResizeListeners } = useSwipeResizeListeners();
    const { popup, bindPopup } = usePopup();
    const {
      deltaX,
      deltaY,
      moveX,
      moveY,
      offsetX,
      offsetY,
      touching,
      direction,
      startTime,
      startTouch,
      moveTouch,
      endTouch
    } = useTouch();
    const isExpectDirection = vue.computed(() => direction.value === (props2.vertical ? "vertical" : "horizontal"));
    let initializedIndex = false;
    let timer = -1;
    const swipeProvider = {
      size,
      currentIndex: index,
      vertical
    };
    bindSwipeItems(swipeProvider);
    useEventListener(() => window, "keydown", handleKeydown);
    call(bindPopup, null);
    call(bindSwipeResizeListeners, null);
    vue.watch(
      () => length.value,
      () => __async$7(this, null, function* () {
        yield doubleRaf();
        initialIndex();
        resize();
      })
    );
    if (popup) {
      vue.watch(
        () => popup.show.value,
        (show) => __async$7(this, null, function* () {
          if (show) {
            yield doubleRaf();
            resize();
          } else {
            stopAutoplay();
          }
        })
      );
    }
    vue.onActivated(resize);
    onSmartUnmounted(stopAutoplay);
    onWindowResize(resize);
    function findSwipeItem(idx) {
      return swipeItems.find(({ index: index2 }) => index2.value === idx);
    }
    function dispatchSwipeItems() {
      if (!props2.loop) {
        return;
      }
      if (trackTranslate.value >= 0) {
        findSwipeItem(length.value - 1).setTranslate(-trackSize.value);
      }
      if (trackTranslate.value <= -(trackSize.value - size.value)) {
        findSwipeItem(0).setTranslate(trackSize.value);
      }
      if (trackTranslate.value > -(trackSize.value - size.value) && trackTranslate.value < 0) {
        findSwipeItem(length.value - 1).setTranslate(0);
        findSwipeItem(0).setTranslate(0);
      }
    }
    function getSwipeIndex(targetSwipeIndex) {
      const swipeIndex = isNumber(targetSwipeIndex) ? targetSwipeIndex : Math.floor((trackTranslate.value - size.value / 2) / -size.value);
      const { loop } = props2;
      if (swipeIndex <= -1) {
        return loop ? -1 : 0;
      }
      if (swipeIndex >= length.value) {
        return loop ? length.value : length.value - 1;
      }
      return swipeIndex;
    }
    function swipeIndexToIndex(swipeIndex) {
      const { loop } = props2;
      if (swipeIndex === -1) {
        return loop ? length.value - 1 : 0;
      }
      if (swipeIndex === length.value) {
        return loop ? 0 : length.value - 1;
      }
      return swipeIndex;
    }
    function clampIndex(index2) {
      if (props2.loop) {
        if (index2 < 0) {
          return length.value + index2;
        }
        if (index2 >= length.value) {
          return index2 - length.value;
        }
        return index2;
      }
      return clamp$1(index2, 0, length.value - 1);
    }
    function fixPosition() {
      return __async$7(this, null, function* () {
        const overLeft = trackTranslate.value >= size.value;
        const overRight = trackTranslate.value <= -trackSize.value;
        const leftTranslate = 0;
        const rightTranslate = -(trackSize.value - size.value);
        lockDuration.value = true;
        if (overLeft || overRight) {
          lockDuration.value = true;
          trackTranslate.value = overRight ? leftTranslate : rightTranslate;
          findSwipeItem(0).setTranslate(0);
          findSwipeItem(length.value - 1).setTranslate(0);
        }
        yield doubleRaf();
        lockDuration.value = false;
      });
    }
    function initialIndex() {
      if (initializedIndex) {
        return;
      }
      index.value = clampIndex(toNumber(props2.initialIndex));
      initializedIndex = true;
    }
    function startAutoplay() {
      const { autoplay } = props2;
      if (!autoplay || length.value <= 1) {
        return;
      }
      stopAutoplay();
      timer = window.setTimeout(() => {
        next();
        startAutoplay();
      }, toNumber(autoplay));
    }
    function stopAutoplay() {
      timer && clearTimeout(timer);
    }
    function handleTouchstart(event) {
      return __async$7(this, null, function* () {
        if (length.value <= 1 || !props2.touchable) {
          return;
        }
        startTouch(event);
        stopAutoplay();
        yield fixPosition();
        lockDuration.value = true;
      });
    }
    function handleTouchmove(event) {
      const { touchable, vertical: vertical2 } = props2;
      if (!touching.value || !touchable) {
        return;
      }
      moveTouch(event);
      if (!isExpectDirection.value) {
        return;
      }
      preventDefault(event);
      trackTranslate.value += vertical2 ? moveY.value : moveX.value;
      dispatchSwipeItems();
    }
    function handleTouchend() {
      if (!touching.value) {
        return;
      }
      endTouch();
      if (!isExpectDirection.value) {
        return;
      }
      const { vertical: vertical2, onChange } = props2;
      const positive = vertical2 ? deltaY.value < 0 : deltaX.value < 0;
      const offset2 = vertical2 ? offsetY.value : offsetX.value;
      const quickSwiping = performance.now() - startTime.value <= SWIPE_DELAY && offset2 >= SWIPE_OFFSET;
      const swipeIndex = quickSwiping ? positive ? getSwipeIndex(index.value + 1) : getSwipeIndex(index.value - 1) : getSwipeIndex();
      lockDuration.value = false;
      trackTranslate.value = swipeIndex * -size.value;
      const prevIndex = index.value;
      index.value = swipeIndexToIndex(swipeIndex);
      startAutoplay();
      if (prevIndex !== index.value) {
        call(onChange, index.value);
      }
    }
    function handleHovering(value) {
      if (props2.navigation === "hover") {
        hovering.value = value;
      }
    }
    function getNavigationAnimation(type) {
      if (props2.navigation !== "hover") {
        return "";
      }
      return n$E(`--navigation${props2.vertical ? "-vertical" : ""}-${type}-animation`);
    }
    function handleKeydown(event) {
      if (!swipeItems.length) {
        return;
      }
      const focusingSwipeItemIndex = swipeItems.findIndex(({ isFocusing }) => isFocusing.value);
      if (focusingSwipeItemIndex === -1) {
        return;
      }
      const { key: key3 } = event;
      preventDefault(event);
      if (key3 === "ArrowLeft") {
        prev();
      }
      if (key3 === "ArrowRight") {
        next();
      }
    }
    function resize() {
      if (!swipeEl.value) {
        return;
      }
      lockDuration.value = true;
      size.value = props2.vertical ? swipeEl.value.offsetHeight : swipeEl.value.offsetWidth;
      trackSize.value = size.value * length.value;
      trackTranslate.value = index.value * -size.value;
      swipeItems.forEach((swipeItem) => {
        swipeItem.setTranslate(0);
      });
      startAutoplay();
      setTimeout(() => {
        lockDuration.value = false;
      });
      swipeResizeListeners.forEach(({ onResize }) => {
        onResize();
      });
    }
    function next(options) {
      return __async$7(this, null, function* () {
        if (length.value <= 1) {
          return;
        }
        initialIndex();
        const { loop, onChange } = props2;
        const currentIndex = index.value;
        index.value = clampIndex(currentIndex + 1);
        if ((options == null ? void 0 : options.event) !== false) {
          call(onChange, index.value);
        }
        yield fixPosition();
        if (currentIndex === length.value - 1 && loop) {
          findSwipeItem(0).setTranslate(trackSize.value);
          trackTranslate.value = length.value * -size.value;
          return;
        }
        if (currentIndex !== length.value - 1) {
          trackTranslate.value = index.value * -size.value;
        }
      });
    }
    function prev(options) {
      return __async$7(this, null, function* () {
        if (length.value <= 1) {
          return;
        }
        initialIndex();
        const { loop, onChange } = props2;
        const currentIndex = index.value;
        index.value = clampIndex(currentIndex - 1);
        if ((options == null ? void 0 : options.event) !== false) {
          call(onChange, index.value);
        }
        yield fixPosition();
        if (currentIndex === 0 && loop) {
          findSwipeItem(length.value - 1).setTranslate(-trackSize.value);
          trackTranslate.value = size.value;
          return;
        }
        if (currentIndex !== 0) {
          trackTranslate.value = index.value * -size.value;
        }
      });
    }
    function to(idx, options) {
      if (length.value <= 1 || idx === index.value) {
        return;
      }
      idx = idx < 0 ? 0 : idx;
      idx = idx >= length.value ? length.value : idx;
      const task = idx > index.value ? next : prev;
      const count = Math.abs(idx - index.value);
      Array.from({ length: count }).forEach((_, index2) => {
        task({ event: index2 === count - 1 ? options == null ? void 0 : options.event : false });
      });
    }
    return {
      length,
      index,
      swipeEl,
      trackSize,
      trackTranslate,
      lockDuration,
      hovering,
      n: n$E,
      toSizeUnit,
      classes: classes$w,
      handleTouchstart,
      handleTouchmove,
      handleTouchend,
      next,
      prev,
      to,
      resize,
      toNumber,
      handleHovering,
      getNavigationAnimation
    };
  }
});
__sfc__$G.render = __render__$E;
var stdin_default$4q = __sfc__$G;
withInstall(stdin_default$4q);
withPropsDefaultsSetter(stdin_default$4q, props$A);
const _SwipeComponent = stdin_default$4q;
var stdin_default$4p = stdin_default$4q;
function useSwipe() {
  const { bindParent, index, parentProvider } = useParent(SWIPE_BIND_SWIPE_ITEM_KEY);
  assert(!!bindParent, "SwipeItem", "<var-swipe-item/> must in <var-swipe/>");
  return {
    index,
    swipe: parentProvider,
    bindSwipe: bindParent
  };
}
const { name: name$A, n: n$D } = createNamespace("swipe-item");
const _hoisted_1$j = ["aria-hidden"];
function __render__$D(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock("div", {
    class: vue.normalizeClass(_ctx.n()),
    style: vue.normalizeStyle({
      width: !_ctx.vertical ? _ctx.toSizeUnit(_ctx.size) : void 0,
      height: _ctx.vertical ? _ctx.toSizeUnit(_ctx.size) : void 0,
      transform: `translate${_ctx.vertical ? "Y" : "X"}(${_ctx.toSizeUnit(_ctx.translate)})`
    }),
    tabindex: "-1",
    "aria-hidden": _ctx.currentIndex !== _ctx.index,
    onFocus: _cache[0] || (_cache[0] = ($event) => _ctx.isFocusing = true),
    onBlur: _cache[1] || (_cache[1] = ($event) => _ctx.isFocusing = false)
  }, [
    vue.renderSlot(_ctx.$slots, "default")
  ], 46, _hoisted_1$j);
}
const __sfc__$F = vue.defineComponent({
  name: name$A,
  setup() {
    const translate = vue.ref(0);
    const isFocusing = vue.ref(false);
    const { swipe, bindSwipe, index } = useSwipe();
    const { size, currentIndex, vertical } = swipe;
    const swipeItemProvider = {
      index,
      isFocusing: vue.computed(() => isFocusing.value),
      setTranslate
    };
    bindSwipe(swipeItemProvider);
    function setTranslate(x) {
      translate.value = x;
    }
    return {
      isFocusing,
      size,
      index,
      currentIndex,
      vertical,
      translate,
      n: n$D,
      toSizeUnit
    };
  }
});
__sfc__$F.render = __render__$D;
var stdin_default$4o = __sfc__$F;
withInstall(stdin_default$4o);
const _SwipeItemComponent = stdin_default$4o;
var stdin_default$4n = stdin_default$4o;
var __defProp$a = Object.defineProperty;
var __getOwnPropSymbols$a = Object.getOwnPropertySymbols;
var __hasOwnProp$a = Object.prototype.hasOwnProperty;
var __propIsEnum$a = Object.prototype.propertyIsEnumerable;
var __defNormalProp$a = (obj, key3, value) => key3 in obj ? __defProp$a(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$a = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$a.call(b, prop))
      __defNormalProp$a(a, prop, b[prop]);
  if (__getOwnPropSymbols$a)
    for (var prop of __getOwnPropSymbols$a(b)) {
      if (__propIsEnum$a.call(b, prop))
        __defNormalProp$a(a, prop, b[prop]);
    }
  return a;
};
const props$z = __spreadValues$a(__spreadValues$a({
  show: Boolean,
  imagePreventDefault: Boolean,
  images: {
    type: Array,
    default: () => []
  },
  initialIndex: {
    type: [String, Number],
    default: 0
  },
  zoom: {
    type: [String, Number],
    default: 2
  },
  closeable: Boolean,
  "onUpdate:show": defineListenerProp(),
  onLongPress: defineListenerProp()
}, pickProps(props$A, ["loop", "indicator", "onChange"])), pickProps(props$1l, [
  "lockScroll",
  "teleport",
  "closeOnKeyEscape",
  "onOpen",
  "onClose",
  "onOpened",
  "onClosed",
  "onKeyEscape",
  // internal for function call closes the dialog
  "onRouteChange"
]));
const { name: name$z, n: n$C, classes: classes$v } = createNamespace("image-preview");
const DISTANCE_OFFSET = 12;
const EVENT_DELAY = 200;
const TAP_DELAY = 350;
const ANIMATION_DURATION = 200;
const LONG_PRESS_DELAY = 500;
const BASE_RATIO = 1;
const _hoisted_1$i = ["onTouchstart"];
const _hoisted_2$5 = ["src", "alt"];
function __render__$C(_ctx, _cache) {
  const _component_var_swipe_item = vue.resolveComponent("var-swipe-item");
  const _component_var_swipe = vue.resolveComponent("var-swipe");
  const _component_var_icon = vue.resolveComponent("var-icon");
  const _component_var_popup = vue.resolveComponent("var-popup");
  return vue.openBlock(), vue.createBlock(_component_var_popup, {
    show: _ctx.show,
    "onUpdate:show": _cache[3] || (_cache[3] = ($event) => _ctx.show = $event),
    "var-image-preview-cover": "",
    class: vue.normalizeClass(_ctx.n("popup")),
    transition: _ctx.n("$-fade"),
    overlay: false,
    "close-on-click-overlay": false,
    "close-on-key-escape": _ctx.closeOnKeyEscape,
    "lock-scroll": _ctx.lockScroll,
    teleport: _ctx.teleport,
    onOpen: _ctx.onOpen,
    onClose: _ctx.onClose,
    onClosed: _ctx.onClosed,
    onOpened: _ctx.onOpened,
    onKeyEscape: _ctx.onKeyEscape,
    onRouteChange: _ctx.onRouteChange
  }, {
    default: vue.withCtx(() => [
      vue.createVNode(_component_var_swipe, vue.mergeProps({
        ref: "swipeRef",
        class: _ctx.n("swipe"),
        "var-image-preview-cover": "",
        touchable: _ctx.canSwipe,
        indicator: _ctx.indicator && _ctx.images.length > 1,
        "initial-index": _ctx.toNumber(_ctx.initialIndex),
        loop: _ctx.loop
      }, _ctx.$attrs, { onChange: _ctx.onChange }), {
        default: vue.withCtx(() => [
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList(_ctx.images, (image, idx) => {
              return vue.openBlock(), vue.createBlock(_component_var_swipe_item, {
                key: image,
                class: vue.normalizeClass(_ctx.n("swipe-item")),
                "var-image-preview-cover": ""
              }, {
                default: vue.withCtx(() => [
                  vue.createElementVNode("div", {
                    class: vue.normalizeClass(_ctx.n("zoom-container")),
                    style: vue.normalizeStyle({
                      transform: `scale(${_ctx.scale}) translate(${_ctx.translateX}px, ${_ctx.translateY}px)`,
                      transitionTimingFunction: _ctx.transitionTimingFunction,
                      transitionDuration: _ctx.transitionDuration
                    }),
                    onTouchstart: ($event) => _ctx.handleTouchstart($event, idx),
                    onTouchmove: _cache[0] || (_cache[0] = (...args) => _ctx.handleTouchmove && _ctx.handleTouchmove(...args)),
                    onTouchend: _cache[1] || (_cache[1] = (...args) => _ctx.handleTouchend && _ctx.handleTouchend(...args)),
                    onTouchcancel: _cache[2] || (_cache[2] = (...args) => _ctx.handleTouchcancel && _ctx.handleTouchcancel(...args))
                  }, [
                    vue.createElementVNode("img", {
                      role: "img",
                      class: vue.normalizeClass(_ctx.classes(_ctx.n("image"), [_ctx.isPreventDefault, _ctx.n("--prevent")])),
                      src: image,
                      alt: image
                    }, null, 10, _hoisted_2$5)
                  ], 46, _hoisted_1$i)
                ]),
                _: 2
                /* DYNAMIC */
              }, 1032, ["class"]);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ]),
        indicator: vue.withCtx(({ index, length }) => [
          vue.renderSlot(_ctx.$slots, "indicator", {
            index,
            length
          }, () => [
            _ctx.indicator && _ctx.images.length > 1 ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 0,
                class: vue.normalizeClass(_ctx.n("indicators"))
              },
              vue.toDisplayString(index + 1) + " / " + vue.toDisplayString(length),
              3
              /* TEXT, CLASS */
            )) : vue.createCommentVNode("v-if", true)
          ])
        ]),
        _: 3
        /* FORWARDED */
      }, 16, ["class", "touchable", "indicator", "initial-index", "loop", "onChange"]),
      vue.renderSlot(_ctx.$slots, "close-icon", {}, () => [
        _ctx.closeable ? (vue.openBlock(), vue.createBlock(_component_var_icon, {
          key: 0,
          class: vue.normalizeClass(_ctx.n("close-icon")),
          name: "close-circle",
          "var-image-preview-cover": "",
          onClick: _ctx.close
        }, null, 8, ["class", "onClick"])) : vue.createCommentVNode("v-if", true)
      ]),
      _ctx.$slots.extra ? (vue.openBlock(), vue.createElementBlock(
        "div",
        {
          key: 0,
          class: vue.normalizeClass(_ctx.n("extra"))
        },
        [
          vue.renderSlot(_ctx.$slots, "extra")
        ],
        2
        /* CLASS */
      )) : vue.createCommentVNode("v-if", true)
    ]),
    _: 3
    /* FORWARDED */
  }, 8, ["show", "class", "transition", "close-on-key-escape", "lock-scroll", "teleport", "onOpen", "onClose", "onClosed", "onOpened", "onKeyEscape", "onRouteChange"]);
}
const __sfc__$E = vue.defineComponent({
  name: name$z,
  components: {
    VarSwipe: stdin_default$4p,
    VarSwipeItem: stdin_default$4n,
    VarPopup: stdin_default$64,
    VarIcon: stdin_default$5_
  },
  inheritAttrs: false,
  props: props$z,
  setup(props2) {
    const show = useVModel(props2, "show");
    const scale = vue.ref(1);
    const translateX = vue.ref(0);
    const translateY = vue.ref(0);
    const transitionTimingFunction = vue.ref();
    const transitionDuration = vue.ref();
    const canSwipe = vue.ref(true);
    const swipeRef = vue.ref(null);
    const { moveX, moveY, distance, startTime, startTouch, moveTouch, endTouch } = useTouch();
    const isPreventDefault = vue.computed(() => {
      const { imagePreventDefault, show: show2 } = props2;
      return show2 && imagePreventDefault;
    });
    let closeRunner = null;
    let longPressRunner = null;
    let isLongPress = false;
    const targets = {
      start: null,
      prev: null
    };
    useEventListener(() => document, "contextmenu", preventImageDefault);
    function zoomIn(ratio) {
      scale.value = toNumber(ratio);
      canSwipe.value = false;
      targets.prev = null;
      window.setTimeout(() => {
        transitionTimingFunction.value = "linear";
        transitionDuration.value = "0s";
      }, ANIMATION_DURATION);
    }
    function zoomOut() {
      scale.value = 1;
      translateX.value = 0;
      translateY.value = 0;
      canSwipe.value = true;
      targets.prev = null;
      transitionTimingFunction.value = void 0;
      transitionDuration.value = void 0;
    }
    function isDoubleTouch(target) {
      if (!targets.prev) {
        return false;
      }
      return distance.value <= DISTANCE_OFFSET && performance.now() - startTime.value <= EVENT_DELAY && targets.prev === target;
    }
    function isTapTouch(target) {
      if (!target || !targets.start || !targets.prev) {
        return false;
      }
      return distance.value <= DISTANCE_OFFSET && performance.now() - startTime.value < TAP_DELAY && (target === targets.start || target.parentNode === targets.start);
    }
    function handleTouchcancel() {
      endTouch();
      window.clearTimeout(longPressRunner);
      isLongPress = false;
      targets.start = null;
    }
    function handleTouchend(event) {
      endTouch();
      window.clearTimeout(longPressRunner);
      if (isLongPress) {
        isLongPress = false;
        return;
      }
      const isTap = isTapTouch(event.target);
      closeRunner = window.setTimeout(() => {
        isTap && close();
        targets.start = null;
      }, EVENT_DELAY);
    }
    function handleTouchstart(event, idx) {
      window.clearTimeout(closeRunner);
      window.clearTimeout(longPressRunner);
      const target = event.currentTarget;
      targets.start = target;
      longPressRunner = window.setTimeout(() => {
        isLongPress = true;
        call(props2.onLongPress, idx);
      }, LONG_PRESS_DELAY);
      if (isDoubleTouch(target)) {
        scale.value > BASE_RATIO ? zoomOut() : zoomIn(props2.zoom);
        return;
      }
      startTouch(event);
      targets.prev = target;
    }
    function getZoom(target) {
      const { offsetWidth, offsetHeight } = target;
      const { naturalWidth, naturalHeight } = target.querySelector(`.${n$C("image")}`);
      return {
        width: offsetWidth,
        height: offsetHeight,
        imageRadio: naturalHeight / naturalWidth,
        rootRadio: offsetHeight / offsetWidth,
        zoom: toNumber(props2.zoom)
      };
    }
    function getLimitX(target) {
      const { zoom: zoom2, imageRadio, rootRadio, width, height } = getZoom(target);
      if (!imageRadio) {
        return 0;
      }
      const displayWidth = imageRadio > rootRadio ? height / imageRadio : width;
      return Math.max(0, (zoom2 * displayWidth - width) / 2) / zoom2;
    }
    function getLimitY(target) {
      const { zoom: zoom2, imageRadio, rootRadio, width, height } = getZoom(target);
      if (!imageRadio) {
        return 0;
      }
      const displayHeight = imageRadio > rootRadio ? height : width * imageRadio;
      return Math.max(0, (zoom2 * displayHeight - height) / 2) / zoom2;
    }
    function handleTouchmove(event) {
      if (!targets.prev) {
        return;
      }
      moveTouch(event);
      const target = event.currentTarget;
      if (distance.value > DISTANCE_OFFSET) {
        window.clearTimeout(longPressRunner);
      }
      if (scale.value > BASE_RATIO) {
        const limitX = getLimitX(target);
        const limitY = getLimitY(target);
        translateX.value = clamp$1(translateX.value + moveX.value, -limitX, limitX);
        translateY.value = clamp$1(translateY.value + moveY.value, -limitY, limitY);
      }
      targets.prev = target;
    }
    function close() {
      if (scale.value > BASE_RATIO) {
        zoomOut();
        setTimeout(() => call(props2["onUpdate:show"], false), ANIMATION_DURATION);
        return;
      }
      call(props2["onUpdate:show"], false);
    }
    function preventImageDefault(event) {
      if (isPreventDefault.value) {
        preventDefault(event);
      }
    }
    function prev(options) {
      var _a;
      (_a = swipeRef.value) == null ? void 0 : _a.prev(options);
    }
    function next(options) {
      var _a;
      (_a = swipeRef.value) == null ? void 0 : _a.next(options);
    }
    function to(idx, options) {
      var _a;
      (_a = swipeRef.value) == null ? void 0 : _a.to(idx, options);
    }
    function zoom(ratio) {
      ratio <= BASE_RATIO ? zoomOut() : zoomIn(ratio);
    }
    return {
      swipeRef,
      isPreventDefault,
      show,
      scale,
      translateX,
      translateY,
      canSwipe,
      transitionTimingFunction,
      transitionDuration,
      n: n$C,
      classes: classes$v,
      toNumber,
      handleTouchstart,
      handleTouchmove,
      handleTouchend,
      handleTouchcancel,
      close,
      prev,
      next,
      to,
      zoom
    };
  }
});
__sfc__$E.render = __render__$C;
var stdin_default$4m = __sfc__$E;
var __defProp$9 = Object.defineProperty;
var __defProps$3 = Object.defineProperties;
var __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;
var __hasOwnProp$9 = Object.prototype.hasOwnProperty;
var __propIsEnum$9 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$9 = (obj, key3, value) => key3 in obj ? __defProp$9(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$9 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$9.call(b, prop))
      __defNormalProp$9(a, prop, b[prop]);
  if (__getOwnPropSymbols$9)
    for (var prop of __getOwnPropSymbols$9(b)) {
      if (__propIsEnum$9.call(b, prop))
        __defNormalProp$9(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));
let singletonOptions$1;
let defaultOptions$1 = {};
function normalizeOptions$1(options = {}) {
  if (isString(options)) {
    return __spreadProps$3(__spreadValues$9({}, defaultOptions$1), { images: [options] });
  }
  if (isArray(options)) {
    return __spreadProps$3(__spreadValues$9({}, defaultOptions$1), { images: options });
  }
  return __spreadValues$9(__spreadValues$9({}, defaultOptions$1), options);
}
function ImagePreview(options) {
  if (!inBrowser()) {
    return;
  }
  ImagePreview.close();
  const imagePreviewOptions = normalizeOptions$1(options);
  const reactiveImagePreviewOptions = vue.reactive(imagePreviewOptions);
  reactiveImagePreviewOptions.teleport = "body";
  singletonOptions$1 = reactiveImagePreviewOptions;
  const { unmountInstance } = mountInstance(stdin_default$4m, reactiveImagePreviewOptions, {
    onClose: () => call(reactiveImagePreviewOptions.onClose),
    onClosed: () => {
      call(reactiveImagePreviewOptions.onClosed);
      unmountInstance();
      singletonOptions$1 === reactiveImagePreviewOptions && (singletonOptions$1 = null);
    },
    onRouteChange: () => {
      unmountInstance();
      singletonOptions$1 === reactiveImagePreviewOptions && (singletonOptions$1 = null);
    },
    "onUpdate:show": (value) => {
      reactiveImagePreviewOptions.show = value;
    }
  });
  reactiveImagePreviewOptions.show = true;
}
ImagePreview.close = () => {
  if (singletonOptions$1 != null) {
    const prevSingletonOptions = singletonOptions$1;
    singletonOptions$1 = null;
    vue.nextTick().then(() => {
      prevSingletonOptions.show = false;
    });
  }
};
ImagePreview.setDefaultOptions = (options) => {
  defaultOptions$1 = options;
};
ImagePreview.resetDefaultOptions = () => {
  defaultOptions$1 = {};
};
ImagePreview.Component = stdin_default$4m;
withInstall(stdin_default$4m);
withInstall(stdin_default$4m, ImagePreview);
withPropsDefaultsSetter(ImagePreview, props$z);
const _ImagePreviewComponent = stdin_default$4m;
var stdin_default$4l = ImagePreview;
const props$y = {
  index: [Number, String]
};
const INDEX_BAR_BIND_INDEX_ANCHOR_KEY = Symbol("INDEX_BAR_BIND_INDEX_ANCHOR_KEY");
function useIndexAnchors() {
  const { bindChildren, length, childProviders } = useChildren(
    INDEX_BAR_BIND_INDEX_ANCHOR_KEY
  );
  return {
    length,
    indexAnchors: childProviders,
    bindIndexAnchors: bindChildren
  };
}
function useIndexBar() {
  const { parentProvider, index, bindParent } = useParent(
    INDEX_BAR_BIND_INDEX_ANCHOR_KEY
  );
  assert(!!bindParent, "IndexAnchor", 'You should use this component in "IndexBar"');
  return {
    index,
    indexBar: parentProvider,
    bindIndexBar: bindParent
  };
}
const { name: name$y, n: n$B, classes: classes$u } = createNamespace("index-anchor");
function __render__$B(_ctx, _cache) {
  return vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.sticky ? _ctx.n("$-sticky") : _ctx.Transition), {
    ref: "anchorEl",
    "offset-top": _ctx.sticky ? _ctx.stickyOffsetTop : null,
    "z-index": _ctx.sticky ? _ctx.zIndex : null,
    disabled: _ctx.disabled && !_ctx.cssMode,
    "css-mode": _ctx.cssMode
  }, {
    default: vue.withCtx(() => [
      vue.createElementVNode(
        "div",
        vue.mergeProps({
          class: _ctx.n()
        }, _ctx.$attrs),
        [
          vue.renderSlot(_ctx.$slots, "default", {}, () => [
            vue.createTextVNode(
              vue.toDisplayString(_ctx.name),
              1
              /* TEXT */
            )
          ])
        ],
        16
        /* FULL_PROPS */
      )
    ]),
    _: 3
    /* FORWARDED */
  }, 8, ["offset-top", "z-index", "disabled", "css-mode"]);
}
const __sfc__$D = vue.defineComponent({
  name: name$y,
  components: { VarSticky: stdin_default$4O },
  inheritAttrs: false,
  props: props$y,
  setup(props2) {
    const disabled = vue.ref(false);
    const name2 = vue.computed(() => props2.index);
    const anchorEl = vue.ref(null);
    const { index, indexBar, bindIndexBar } = useIndexBar();
    const { active, sticky, cssMode, stickyOffsetTop, zIndex } = indexBar;
    const indexAnchorProvider = {
      index,
      name: name2,
      setDisabled,
      getOffsetTop
    };
    bindIndexBar(indexAnchorProvider);
    function getOffsetTop() {
      if (!anchorEl.value) {
        return 0;
      }
      return anchorEl.value.$el ? anchorEl.value.$el.offsetTop : anchorEl.value.offsetTop;
    }
    function setDisabled(value) {
      disabled.value = value;
    }
    return {
      n: n$B,
      classes: classes$u,
      name: name2,
      anchorEl,
      active,
      sticky,
      zIndex,
      disabled,
      cssMode,
      stickyOffsetTop,
      Transition: vue.Transition
    };
  }
});
__sfc__$D.render = __render__$B;
var stdin_default$4k = __sfc__$D;
withInstall(stdin_default$4k);
withPropsDefaultsSetter(stdin_default$4k, props$y);
const _IndexAnchorComponent = stdin_default$4k;
var stdin_default$4j = stdin_default$4k;
const props$x = {
  sticky: {
    type: Boolean,
    default: true
  },
  stickyOffsetTop: {
    type: [String, Number],
    default: 0
  },
  stickyCssMode: Boolean,
  hideList: Boolean,
  zIndex: {
    type: [Number, String],
    default: 1
  },
  highlightColor: String,
  duration: {
    type: [Number, String],
    default: 0
  },
  onClick: defineListenerProp(),
  onChange: defineListenerProp()
};
var __async$6 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const { name: name$x, n: n$A, classes: classes$t } = createNamespace("index-bar");
const _hoisted_1$h = ["onClick"];
function __render__$A(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      ref: "barEl",
      class: vue.normalizeClass(_ctx.n())
    },
    [
      vue.renderSlot(_ctx.$slots, "default"),
      vue.createElementVNode(
        "ul",
        {
          class: vue.normalizeClass(_ctx.n("anchor-list")),
          style: vue.normalizeStyle({ zIndex: _ctx.toNumber(_ctx.zIndex) + 2, display: _ctx.hideList ? "none" : "block" })
        },
        [
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList(_ctx.anchorNameList, (anchorName) => {
              return vue.openBlock(), vue.createElementBlock("li", {
                key: anchorName,
                class: vue.normalizeClass(_ctx.classes(_ctx.n("anchor-item"), [_ctx.active === anchorName, _ctx.n("anchor-item--active")])),
                style: vue.normalizeStyle({ color: _ctx.active === anchorName && _ctx.highlightColor ? _ctx.highlightColor : void 0 }),
                onClick: ($event) => _ctx.anchorClick({ anchorName, manualCall: true })
              }, [
                vue.renderSlot(_ctx.$slots, "anchor-name", { anchorName }, () => [
                  vue.createTextVNode(
                    vue.toDisplayString(anchorName),
                    1
                    /* TEXT */
                  )
                ])
              ], 14, _hoisted_1$h);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ],
        6
        /* CLASS, STYLE */
      )
    ],
    2
    /* CLASS */
  );
}
const __sfc__$C = vue.defineComponent({
  name: name$x,
  props: props$x,
  setup(props2) {
    const clickedName = vue.ref("");
    const barEl = vue.ref(null);
    const anchorNameList = vue.ref([]);
    const active = vue.ref();
    const sticky = vue.computed(() => props2.sticky);
    const cssMode = vue.computed(() => props2.stickyCssMode);
    const stickyOffsetTop = vue.computed(() => toPxNum(props2.stickyOffsetTop));
    const zIndex = vue.computed(() => props2.zIndex);
    const { length, indexAnchors, bindIndexAnchors } = useIndexAnchors();
    let scroller = null;
    let isDeactivated = false;
    const indexBarProvider = {
      active,
      sticky,
      cssMode,
      stickyOffsetTop,
      zIndex
    };
    vue.watch(
      () => length.value,
      () => __async$6(this, null, function* () {
        yield doubleRaf();
        anchorNameList.value = indexAnchors.filter(({ name: name2 }) => name2.value != null).map(({ name: name2 }) => name2.value);
      })
    );
    onSmartMounted(setupScroller);
    vue.onBeforeUnmount(removeScrollerListener);
    vue.onDeactivated(() => {
      isDeactivated = true;
      removeScrollerListener();
    });
    vue.onActivated(() => {
      if (!isDeactivated || active.value === void 0) {
        return;
      }
      anchorClick({
        anchorName: active.value,
        options: { event: false }
      });
      isDeactivated = false;
    });
    bindIndexAnchors(indexBarProvider);
    function emitEvent(anchor, options) {
      const anchorName = isPlainObject(anchor) ? anchor.name.value : anchor;
      if (anchorName === active.value || anchorName === void 0) {
        return;
      }
      active.value = anchorName;
      if ((options == null ? void 0 : options.event) !== false) {
        call(props2.onChange, anchorName);
      }
    }
    function getOffsetTop() {
      const { top: parentTop } = getRect(scroller);
      const { top: targetTop } = getRect(barEl.value);
      const scrollTop = getScrollTop(scroller);
      return scrollTop - parentTop + targetTop;
    }
    function handleScroll() {
      const scrollTop = getScrollTop(scroller);
      const scrollHeight = scroller === window ? document.body.scrollHeight : scroller.scrollHeight;
      const offsetTop = getOffsetTop();
      indexAnchors.forEach((anchor, index) => {
        const anchorTop = anchor.getOffsetTop();
        const top2 = scrollTop - anchorTop + stickyOffsetTop.value - offsetTop;
        const distance = index === indexAnchors.length - 1 ? scrollHeight : indexAnchors[index + 1].getOffsetTop() - anchor.getOffsetTop();
        anchor.setDisabled(true);
        if (top2 >= 0 && top2 < distance && clickedName.value === "") {
          anchor.setDisabled(false);
          emitEvent(anchor);
        }
      });
    }
    function anchorClick(_0) {
      return __async$6(this, arguments, function* ({ anchorName, manualCall = false, options }) {
        if (manualCall) {
          call(props2.onClick, anchorName);
        }
        if (anchorName === active.value && !isDeactivated) {
          return;
        }
        const indexAnchor = indexAnchors.find(({ name: name2 }) => anchorName === name2.value);
        if (!indexAnchor) {
          return;
        }
        const offsetTop = getOffsetTop();
        const indexAnchorTop = indexAnchor.getOffsetTop();
        const top2 = indexAnchorTop - stickyOffsetTop.value + offsetTop;
        const left2 = getScrollLeft(scroller);
        clickedName.value = anchorName;
        emitEvent(anchorName, options);
        yield scrollTo(scroller, {
          left: left2,
          top: top2,
          animation: easeInOutCubic,
          duration: toNumber(props2.duration)
        });
        yield doubleRaf();
        clickedName.value = "";
      });
    }
    function setupScroller() {
      scroller = getParentScroller(barEl.value);
      scroller.addEventListener("scroll", handleScroll);
    }
    function removeScrollerListener() {
      if (!scroller) {
        return;
      }
      scroller.removeEventListener("scroll", handleScroll);
    }
    function scrollTo$1(index, options) {
      requestAnimationFrame$1(() => anchorClick({ anchorName: index, options }));
    }
    return {
      barEl,
      active,
      zIndex,
      anchorNameList,
      n: n$A,
      classes: classes$t,
      toNumber,
      scrollTo: scrollTo$1,
      anchorClick
    };
  }
});
__sfc__$C.render = __render__$A;
var stdin_default$4i = __sfc__$C;
withInstall(stdin_default$4i);
withPropsDefaultsSetter(stdin_default$4i, props$x);
const _IndexBarComponent = stdin_default$4i;
var stdin_default$4h = stdin_default$4i;
const props$w = {
  type: {
    type: String,
    default: "default"
  },
  href: String,
  target: String,
  rel: String,
  to: [String, Object],
  replace: Boolean,
  underline: {
    type: String,
    default: "always"
  },
  disabled: Boolean,
  textSize: [String, Number],
  textColor: String,
  onClick: defineListenerProp()
};
const { name: name$w, n: n$z, classes: classes$s } = createNamespace("link");
function __render__$z(_ctx, _cache) {
  return vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.tag), vue.mergeProps(_ctx.linkProps, {
    class: _ctx.classes(
      _ctx.n(),
      _ctx.n("$--box"),
      _ctx.n("$--inline-flex"),
      _ctx.n(`--${_ctx.type}`),
      [_ctx.underline !== "none", _ctx.n(`--underline-${_ctx.underline}`)],
      [_ctx.disabled, _ctx.n("--disabled")],
      [_ctx.isFocusing && !_ctx.inMobile(), _ctx.n("--focusing")]
    ),
    style: {
      color: _ctx.textColor,
      fontSize: _ctx.toSizeUnit(_ctx.textSize)
    },
    onClick: _ctx.handleClick,
    onFocus: _cache[0] || (_cache[0] = ($event) => _ctx.isFocusing = true),
    onBlur: _cache[1] || (_cache[1] = ($event) => _ctx.isFocusing = false)
  }), {
    default: vue.withCtx(() => [
      vue.renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
    /* FORWARDED */
  }, 16, ["class", "style", "onClick"]);
}
const __sfc__$B = vue.defineComponent({
  name: name$w,
  props: props$w,
  setup(props2) {
    const isFocusing = vue.ref(false);
    const tag2 = vue.computed(() => {
      const { disabled, href, to } = props2;
      if (disabled) {
        return "span";
      }
      if (href) {
        return "a";
      }
      if (to) {
        return "router-link";
      }
      return "a";
    });
    const linkProps = vue.computed(() => {
      const { disabled, href, target, to, replace, rel } = props2;
      if (disabled) {
        return {};
      }
      if (href) {
        return { href, target, rel };
      }
      if (to) {
        return { to, target, replace };
      }
      return {};
    });
    function handleClick(e) {
      if (props2.disabled) {
        return;
      }
      call(props2.onClick, e);
    }
    return {
      tag: tag2,
      linkProps,
      isFocusing,
      inMobile,
      n: n$z,
      classes: classes$s,
      handleClick,
      toSizeUnit
    };
  }
});
__sfc__$B.render = __render__$z;
var stdin_default$4g = __sfc__$B;
withInstall(stdin_default$4g);
withPropsDefaultsSetter(stdin_default$4g, props$w);
const _LinkComponent = stdin_default$4g;
var stdin_default$4f = stdin_default$4g;
const props$v = {
  loading: Boolean,
  immediateCheck: {
    type: Boolean,
    default: true
  },
  finished: Boolean,
  error: Boolean,
  offset: {
    type: [String, Number],
    default: 0
  },
  loadingText: String,
  finishedText: String,
  errorText: String,
  onLoad: defineListenerProp(),
  "onUpdate:loading": defineListenerProp(),
  "onUpdate:error": defineListenerProp()
};
const TABS_ITEMS_BIND_TAB_ITEM_KEY = Symbol("TABS_ITEMS_BIND_TAB_ITEM_KEY");
function useTabItem$1() {
  const { bindChildren, childProviders, length } = useChildren(
    TABS_ITEMS_BIND_TAB_ITEM_KEY
  );
  return {
    length,
    tabItemList: childProviders,
    bindTabItem: bindChildren
  };
}
const TAB_ITEM_BIND_LIST_KEY = Symbol("TAB_ITEM_BIND_LIST_KEY");
function useTabsItems() {
  const { parentProvider, bindParent, index } = useParent(
    TABS_ITEMS_BIND_TAB_ITEM_KEY
  );
  assert(!!bindParent, "TabItem", "<var-tab-item/> must in <var-tabs-items/>");
  return {
    index,
    tabsItems: parentProvider,
    bindTabsItems: bindParent
  };
}
function useLists() {
  const { childProviders, bindChildren, length } = useChildren(TAB_ITEM_BIND_LIST_KEY);
  return {
    length,
    lists: childProviders,
    bindLists: bindChildren
  };
}
function useTabItem() {
  const { parentProvider, bindParent, index } = useParent(TAB_ITEM_BIND_LIST_KEY);
  return {
    index,
    tabItem: parentProvider,
    bindTabItem: bindParent
  };
}
var __async$5 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const { name: name$v, n: n$y, classes: classes$r } = createNamespace("list");
function __render__$y(_ctx, _cache) {
  const _component_var_loading = vue.resolveComponent("var-loading");
  const _directive_ripple = vue.resolveDirective("ripple");
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      ref: "listEl",
      class: vue.normalizeClass(_ctx.classes(_ctx.n(), _ctx.n("$--box")))
    },
    [
      vue.renderSlot(_ctx.$slots, "default"),
      _ctx.loading ? vue.renderSlot(_ctx.$slots, "loading", { key: 0 }, () => {
        var _a;
        return [
          vue.createElementVNode(
            "div",
            {
              class: vue.normalizeClass(_ctx.n("loading"))
            },
            [
              vue.createElementVNode(
                "div",
                {
                  class: vue.normalizeClass(_ctx.n("loading-text"))
                },
                vue.toDisplayString((_a = _ctx.loadingText) != null ? _a : (_ctx.pt ? _ctx.pt : _ctx.t)("listLoadingText")),
                3
                /* TEXT, CLASS */
              ),
              vue.createVNode(_component_var_loading, {
                size: "mini",
                radius: 10
              })
            ],
            2
            /* CLASS */
          )
        ];
      }) : vue.createCommentVNode("v-if", true),
      _ctx.finished ? vue.renderSlot(_ctx.$slots, "finished", { key: 1 }, () => {
        var _a;
        return [
          vue.createElementVNode(
            "div",
            {
              class: vue.normalizeClass(_ctx.n("finished"))
            },
            vue.toDisplayString((_a = _ctx.finishedText) != null ? _a : (_ctx.pt ? _ctx.pt : _ctx.t)("listFinishedText")),
            3
            /* TEXT, CLASS */
          )
        ];
      }) : vue.createCommentVNode("v-if", true),
      _ctx.error ? vue.renderSlot(_ctx.$slots, "error", { key: 2 }, () => {
        var _a;
        return [
          vue.withDirectives((vue.openBlock(), vue.createElementBlock(
            "div",
            {
              class: vue.normalizeClass(_ctx.n("error")),
              onClick: _cache[0] || (_cache[0] = (...args) => _ctx.load && _ctx.load(...args))
            },
            [
              vue.createTextVNode(
                vue.toDisplayString((_a = _ctx.errorText) != null ? _a : (_ctx.pt ? _ctx.pt : _ctx.t)("listErrorText")),
                1
                /* TEXT */
              )
            ],
            2
            /* CLASS */
          )), [
            [_directive_ripple]
          ])
        ];
      }) : vue.createCommentVNode("v-if", true),
      vue.createElementVNode(
        "div",
        {
          ref: "detectorEl",
          class: vue.normalizeClass(_ctx.n("detector"))
        },
        null,
        2
        /* CLASS */
      )
    ],
    2
    /* CLASS */
  );
}
const __sfc__$A = vue.defineComponent({
  name: name$v,
  directives: { Ripple: stdin_default$63 },
  components: { VarLoading: stdin_default$5v },
  props: props$v,
  setup(props2) {
    const listEl = vue.ref(null);
    const detectorEl = vue.ref(null);
    const { tabItem, bindTabItem } = useTabItem();
    const { t: pt } = injectLocaleProvider();
    let scroller;
    call(bindTabItem, {});
    if (tabItem) {
      vue.watch(() => tabItem.current.value, check2);
    }
    vue.watch(() => [props2.loading, props2.error, props2.finished], check2);
    onSmartMounted(() => {
      scroller = getParentScroller(listEl.value);
      scroller.addEventListener("scroll", check2);
      if (props2.immediateCheck) {
        check2();
      }
    });
    onSmartUnmounted(removeScrollerListener);
    function load() {
      call(props2["onUpdate:error"], false);
      call(props2["onUpdate:loading"], true);
      call(props2.onLoad);
    }
    function isReachBottom() {
      const { bottom: containerBottom } = getRect(scroller);
      const { bottom: detectorBottom } = getRect(detectorEl.value);
      return Math.floor(detectorBottom) - toPxNum(props2.offset) <= containerBottom;
    }
    function removeScrollerListener() {
      if (!scroller) {
        return;
      }
      scroller.removeEventListener("scroll", check2);
    }
    function check2() {
      return __async$5(this, null, function* () {
        yield vue.nextTick();
        if (props2.loading || props2.finished || props2.error || (tabItem == null ? void 0 : tabItem.current.value) === false || !isReachBottom()) {
          return;
        }
        load();
      });
    }
    return {
      listEl,
      detectorEl,
      pt,
      t,
      isNumber,
      load,
      check: check2,
      n: n$y,
      classes: classes$r
    };
  }
});
__sfc__$A.render = __render__$y;
var stdin_default$4e = __sfc__$A;
withInstall(stdin_default$4e);
withPropsDefaultsSetter(stdin_default$4e, props$v);
const _ListComponent = stdin_default$4e;
var stdin_default$4d = stdin_default$4e;
const props$u = {
  value: {
    type: Number,
    default: 0
  },
  opacity: {
    type: Number,
    default: 0
  },
  error: Boolean,
  color: String,
  errorColor: String,
  height: [Number, String],
  top: [Number, String],
  transitionDuration: Number
};
const {
  name: name$u,
  classes: classes$q,
  n: n$x
} = createNamespace("loading-bar");
var stdin_default$4c = vue.defineComponent({
  name: name$u,
  props: props$u,
  setup(props2) {
    return () => vue.createVNode("div", {
      "class": classes$q(n$x(), [props2.error, n$x("--error")]),
      "style": {
        zIndex: stdin_default$66.zIndex + 10,
        width: `${props2.value}%`,
        opacity: props2.opacity,
        height: toSizeUnit(props2.height),
        backgroundColor: props2.error ? props2.errorColor : props2.color,
        top: toSizeUnit(props2.top),
        transitionDuration: props2.transitionDuration == null ? void 0 : `${props2.transitionDuration}ms`
      }
    }, null);
  }
});
const OPACITY_DELAY = 200;
let valueTimer;
let errorTimer;
let finishTimer;
let finishErrorTimer;
let opacityTimer;
let isMount$1;
let internalOptions = {};
const internalProps = {
  value: 0,
  opacity: 0,
  error: false
};
const ctx = vue.reactive(internalProps);
function setDefaultOptions(options) {
  Object.assign(ctx, options);
  internalOptions = options;
}
const resetDefaultOptions = () => {
  Object.keys(internalOptions).forEach((key3) => {
    if (ctx[key3] !== void 0) {
      ctx[key3] = void 0;
    }
  });
};
const mount = () => {
  if (!isMount$1) {
    isMount$1 = true;
    mountInstance(stdin_default$4c, ctx);
  }
};
const tick = () => {
  valueTimer = window.setTimeout(() => {
    ctx.transitionDuration = void 0;
    if (ctx.value >= 95) {
      return;
    }
    ctx.value += ctx.value < 70 ? Math.round(5 * Math.random()) : Math.random();
    tick();
  }, 200);
};
const clearTimer = () => {
  window.clearTimeout(valueTimer);
  window.clearTimeout(opacityTimer);
  window.clearTimeout(finishTimer);
  window.clearTimeout(errorTimer);
  window.clearTimeout(finishErrorTimer);
};
const finishTask = () => {
  clearTimer();
  ctx.value = 100;
  opacityTimer = window.setTimeout(() => {
    ctx.opacity = 0;
    finishErrorTimer = window.setTimeout(() => {
      ctx.error = false;
    }, 250);
  }, OPACITY_DELAY + 100);
};
const start = () => {
  clearTimer();
  ctx.error = false;
  ctx.value = 0;
  ctx.transitionDuration = 0;
  mount();
  opacityTimer = window.setTimeout(() => {
    ctx.opacity = 1;
  }, OPACITY_DELAY);
  tick();
};
const finish = () => {
  var _a;
  finishTimer = window.setTimeout(finishTask, (_a = ctx.finishDelay) != null ? _a : 0);
};
const error = () => {
  clearTimer();
  ctx.error = true;
  if (ctx.value === 100) {
    ctx.value = 0;
    ctx.transitionDuration = 0;
  }
  mount();
  opacityTimer = window.setTimeout(() => {
    ctx.opacity = 1;
  }, OPACITY_DELAY);
  tick();
  errorTimer = window.setTimeout(finishTask, 300);
};
const LoadingBar = {
  start,
  finish,
  error,
  setDefaultOptions,
  resetDefaultOptions
};
const _LoadingBarComponent = LoadingBar;
var stdin_default$4b = LoadingBar;
const props$t = {
  tag: {
    type: String,
    default: "div"
  },
  locale: {
    type: String,
    default: "zh-CN"
  },
  messages: {
    type: Object
  }
};
var __defProp$8 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$8 = (obj, key3, value) => key3 in obj ? __defProp$8(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$8 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$8.call(b, prop))
      __defNormalProp$8(a, prop, b[prop]);
  if (__getOwnPropSymbols$8)
    for (var prop of __getOwnPropSymbols$8(b)) {
      if (__propIsEnum$8.call(b, prop))
        __defNormalProp$8(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
const { name: name$t, n: n$w } = createNamespace("locale-provider");
const __sfc__$z = vue.defineComponent({
  name: name$t,
  props: props$t,
  setup(props2, { slots }) {
    const messages2 = vue.computed(
      () => {
        var _a;
        return Object.entries((_a = props2.messages) != null ? _a : {}).reduce(
          (messages22, [key3, value]) => {
            messages22[key3] = __spreadProps$2(__spreadValues$8({}, value), {
              lang: key3
            });
            return messages22;
          },
          {}
        );
      }
    );
    provideLocaleProvider({
      t: t2
    });
    function t2(id) {
      if (hasOwn(messages2.value, props2.locale) && hasOwn(messages2.value[props2.locale], id)) {
        return messages2.value[props2.locale][id];
      }
    }
    return () => vue.h(
      props2.tag,
      {
        class: n$w()
      },
      call(slots.default)
    );
  }
});
var stdin_default$4a = __sfc__$z;
withInstall(stdin_default$4a);
withPropsDefaultsSetter(stdin_default$4a, props$t);
const _LocaleProviderComponent = stdin_default$4a;
var stdin_default$49 = stdin_default$4a;
const props$s = {
  label: {},
  value: {},
  disabled: Boolean,
  ripple: {
    type: Boolean,
    default: true
  },
  // internal
  option: Object
};
const SELECT_BIND_OPTION_KEY = Symbol("SELECT_BIND_OPTION_KEY");
function useOptions() {
  const { length, childProviders, bindChildren } = useChildren(SELECT_BIND_OPTION_KEY);
  return {
    length,
    options: childProviders,
    bindOptions: bindChildren
  };
}
function useSelect() {
  const { index, parentProvider, bindParent } = useParent(SELECT_BIND_OPTION_KEY);
  assert(!!bindParent, "Option", "<var-option/> must in <var-select/>");
  return {
    index,
    select: parentProvider,
    bindSelect: bindParent
  };
}
const { name: name$s, n: n$v, classes: classes$p } = createNamespace("option");
const _hoisted_1$g = ["tabindex"];
function __render__$x(_ctx, _cache) {
  const _component_var_checkbox = vue.resolveComponent("var-checkbox");
  const _component_maybe_v_node = vue.resolveComponent("maybe-v-node");
  const _component_var_hover_overlay = vue.resolveComponent("var-hover-overlay");
  const _directive_ripple = vue.resolveDirective("ripple");
  const _directive_hover = vue.resolveDirective("hover");
  return vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", {
    ref: "root",
    class: vue.normalizeClass(_ctx.classes(_ctx.n(), _ctx.n("$--box"), [_ctx.optionSelected, _ctx.n("--selected-color")], [_ctx.disabled, _ctx.n("--disabled")])),
    style: vue.normalizeStyle({
      color: _ctx.optionSelected ? _ctx.focusColor : void 0
    }),
    tabindex: _ctx.disabled ? void 0 : "-1",
    onFocus: _cache[2] || (_cache[2] = ($event) => _ctx.isFocusing = true),
    onBlur: _cache[3] || (_cache[3] = ($event) => _ctx.isFocusing = false),
    onClick: _cache[4] || (_cache[4] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    vue.createElementVNode(
      "div",
      {
        class: vue.normalizeClass(_ctx.classes(_ctx.n("cover"), [_ctx.optionSelected, _ctx.n("--selected-background")])),
        style: vue.normalizeStyle({
          background: _ctx.optionSelected ? _ctx.focusColor : void 0
        })
      },
      null,
      6
      /* CLASS, STYLE */
    ),
    _ctx.multiple ? (vue.openBlock(), vue.createBlock(_component_var_checkbox, {
      key: 0,
      ref: "checkbox",
      modelValue: _ctx.optionSelected,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.optionSelected = $event),
      "checked-color": _ctx.focusColor,
      disabled: _ctx.disabled,
      onClick: _cache[1] || (_cache[1] = vue.withModifiers(() => {
      }, ["stop"])),
      onChange: _ctx.handleSelect
    }, null, 8, ["modelValue", "checked-color", "disabled", "onChange"])) : vue.createCommentVNode("v-if", true),
    vue.renderSlot(_ctx.$slots, "default", { selected: _ctx.optionSelected }, () => [
      vue.createElementVNode(
        "div",
        {
          class: vue.normalizeClass(_ctx.classes(_ctx.n("text"), _ctx.n("$--ellipsis")))
        },
        [
          vue.createVNode(_component_maybe_v_node, { is: _ctx.labelVNode }, null, 8, ["is"])
        ],
        2
        /* CLASS */
      )
    ]),
    vue.createVNode(_component_var_hover_overlay, {
      hovering: _ctx.hovering && !_ctx.disabled,
      focusing: _ctx.isFocusing && !_ctx.disabled
    }, null, 8, ["hovering", "focusing"])
  ], 46, _hoisted_1$g)), [
    [_directive_ripple, { disabled: _ctx.disabled || !_ctx.ripple }],
    [_directive_hover, _ctx.handleHovering, "desktop"]
  ]);
}
const __sfc__$y = vue.defineComponent({
  name: name$s,
  directives: { Ripple: stdin_default$63, Hover: stdin_default$62 },
  components: {
    VarCheckbox: stdin_default$5L,
    VarHoverOverlay: stdin_default$60,
    MaybeVNode
  },
  props: props$s,
  setup(props2) {
    const root = vue.ref();
    const isFocusing = vue.ref(false);
    const optionSelected = vue.ref(false);
    const selected = vue.computed(() => optionSelected.value);
    const value = vue.computed(() => props2.value);
    const disabled = vue.computed(() => props2.disabled);
    const ripple = vue.computed(() => props2.ripple);
    const { select, bindSelect } = useSelect();
    const { multiple, focusColor, onSelect, computeLabel } = select;
    const { hovering, handleHovering } = useHoverOverlay();
    const labelVNode = vue.computed(
      () => {
        var _a;
        return isFunction(props2.label) ? props2.label(
          (_a = props2.option) != null ? _a : {
            label: props2.label,
            value: props2.value,
            disabled: props2.disabled
          },
          optionSelected.value
        ) : props2.label;
      }
    );
    const optionProvider = {
      label: labelVNode,
      value,
      disabled,
      ripple,
      selected,
      sync
    };
    vue.watch([() => props2.label, () => props2.value], computeLabel);
    bindSelect(optionProvider);
    useEventListener(() => window, "keydown", handleKeydown);
    useEventListener(() => window, "keyup", handleKeyup);
    function handleClick() {
      if (props2.disabled) {
        return;
      }
      handleSelect();
    }
    function handleKeydown(event) {
      if (!isFocusing.value) {
        return;
      }
      if (event.key === " " || event.key === "Enter") {
        preventDefault(event);
      }
      if (event.key === "Enter") {
        root.value.click();
      }
    }
    function handleKeyup(event) {
      if (!isFocusing.value) {
        return;
      }
      if (event.key === " ") {
        preventDefault(event);
        root.value.click();
      }
    }
    function handleSelect() {
      if (multiple.value) {
        optionSelected.value = !optionSelected.value;
      }
      onSelect(optionProvider);
    }
    function sync(checked) {
      optionSelected.value = checked;
    }
    return {
      root,
      optionSelected,
      multiple,
      focusColor,
      hovering,
      isFocusing,
      labelVNode,
      n: n$v,
      classes: classes$p,
      handleHovering,
      handleClick,
      handleSelect
    };
  }
});
__sfc__$y.render = __render__$x;
var stdin_default$48 = __sfc__$y;
withInstall(stdin_default$48);
withPropsDefaultsSetter(stdin_default$48, props$s);
const _OptionComponent = stdin_default$48;
var stdin_default$47 = stdin_default$48;
const props$r = {
  show: Boolean,
  lockScroll: {
    type: Boolean,
    default: true
  },
  teleport: [String, Object, Boolean],
  closeOnKeyEscape: {
    type: Boolean,
    default: true
  },
  onClick: defineListenerProp(),
  onKeyEscape: defineListenerProp(),
  "onUpdate:show": defineListenerProp()
};
const {
  name: name$r,
  n: n$u
} = createNamespace("overlay");
var stdin_default$46 = vue.defineComponent({
  name: name$r,
  inheritAttrs: false,
  props: props$r,
  setup(props2, {
    slots,
    attrs
  }) {
    const {
      zIndex
    } = useZIndex(() => props2.show, 3);
    const {
      onStackTop
    } = useStack(() => props2.show, zIndex);
    const {
      disabled
    } = useTeleport();
    useLock(() => props2.show, () => props2.lockScroll);
    useEventListener(() => window, "keydown", handleKeydown);
    function handleKeydown(event) {
      if (!onStackTop() || event.key !== "Escape" || !props2.show) {
        return;
      }
      call(props2.onKeyEscape);
      if (!props2.closeOnKeyEscape) {
        return;
      }
      preventDefault(event);
      call(props2["onUpdate:show"], false);
    }
    function handleClickOverlay() {
      call(props2.onClick);
      call(props2["onUpdate:show"], false);
    }
    function renderOverlay() {
      return vue.createVNode("div", vue.mergeProps({
        "class": n$u(),
        "style": {
          zIndex: zIndex.value - 2
        }
      }, attrs), [vue.createVNode("div", {
        "class": n$u("overlay"),
        "style": {
          zIndex: zIndex.value - 1
        },
        "onClick": handleClickOverlay
      }, null), vue.createVNode("div", {
        "class": n$u("content"),
        "style": {
          zIndex: zIndex.value
        }
      }, [call(slots.default)])]);
    }
    function renderTransitionOverlay() {
      return vue.createVNode(vue.Transition, {
        "name": n$u("--fade")
      }, {
        default: () => [props2.show && renderOverlay()]
      });
    }
    return () => {
      const {
        teleport
      } = props2;
      if (teleport) {
        return vue.createVNode(vue.Teleport, {
          "to": teleport,
          "disabled": disabled.value
        }, {
          default: () => [renderTransitionOverlay()]
        });
      }
      return renderTransitionOverlay();
    };
  }
});
withInstall(stdin_default$46);
withPropsDefaultsSetter(stdin_default$46, props$r);
const _OverlayComponent = stdin_default$46;
var stdin_default$45 = stdin_default$46;
const props$q = {
  current: [Number, String],
  size: {
    type: [Number, String],
    default: 10
  },
  total: {
    type: [Number, String],
    default: 0
  },
  elevation: {
    type: [Boolean, Number, String],
    default: true
  },
  maxPagerCount: {
    type: Number,
    default: 3
  },
  disabled: Boolean,
  simple: {
    type: Boolean,
    default: true
  },
  showSizeChanger: {
    type: Boolean,
    default: true
  },
  showQuickJumper: Boolean,
  sizeOption: {
    type: Array,
    default: () => [10, 20, 50, 100]
  },
  showTotal: Function,
  onChange: defineListenerProp(),
  "onUpdate:current": defineListenerProp(),
  "onUpdate:size": defineListenerProp()
};
const { name: name$q, n: n$t, classes: classes$o } = createNamespace("pagination");
const _hoisted_1$f = ["item-mode", "onClick"];
function __render__$w(_ctx, _cache) {
  const _component_var_icon = vue.resolveComponent("var-icon");
  const _component_var_input = vue.resolveComponent("var-input");
  const _component_var_menu_option = vue.resolveComponent("var-menu-option");
  const _component_var_menu_select = vue.resolveComponent("var-menu-select");
  const _directive_ripple = vue.resolveDirective("ripple");
  return vue.openBlock(), vue.createElementBlock(
    "ul",
    {
      class: vue.normalizeClass(_ctx.n())
    },
    [
      vue.withDirectives((vue.openBlock(), vue.createElementBlock(
        "li",
        {
          class: vue.normalizeClass(
            _ctx.classes(
              _ctx.n("item"),
              _ctx.n("prev"),
              [_ctx.current <= 1 || _ctx.disabled, _ctx.n("item--disabled")],
              [_ctx.simple, _ctx.n("item--simple"), _ctx.formatElevation(_ctx.elevation, 2)]
            )
          ),
          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.clickItem("prev"))
        },
        [
          vue.renderSlot(_ctx.$slots, "prev", {}, () => [
            vue.createVNode(_component_var_icon, { name: "chevron-left" })
          ])
        ],
        2
        /* CLASS */
      )), [
        [_directive_ripple, { disabled: _ctx.current <= 1 || _ctx.disabled }]
      ]),
      _ctx.simple ? (vue.openBlock(), vue.createElementBlock(
        "li",
        {
          key: 0,
          class: vue.normalizeClass(_ctx.classes(_ctx.n("simple"), [_ctx.disabled, _ctx.n("item--disabled")]))
        },
        [
          vue.createVNode(_component_var_input, {
            modelValue: _ctx.simpleCurrentValue,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.simpleCurrentValue = $event),
            "var-pagination-cover": "",
            hint: false,
            disabled: _ctx.disabled,
            onBlur: _cache[2] || (_cache[2] = ($event) => _ctx.setPage("simple", _ctx.simpleCurrentValue, $event)),
            onKeydown: _cache[3] || (_cache[3] = vue.withKeys(($event) => _ctx.setPage("simple", _ctx.simpleCurrentValue, $event), ["enter"]))
          }, null, 8, ["modelValue", "disabled"]),
          vue.createElementVNode("span", null, [
            vue.createTextVNode(
              " / " + vue.toDisplayString(_ctx.pageCount) + " ",
              1
              /* TEXT */
            ),
            vue.createElementVNode(
              "div",
              {
                class: vue.normalizeClass(_ctx.n("simple-line"))
              },
              null,
              2
              /* CLASS */
            )
          ])
        ],
        2
        /* CLASS */
      )) : (vue.openBlock(true), vue.createElementBlock(
        vue.Fragment,
        { key: 1 },
        vue.renderList(_ctx.pageList, (item, index) => {
          return vue.withDirectives((vue.openBlock(), vue.createElementBlock("li", {
            key: index,
            "item-mode": _ctx.getMode(item, index),
            class: vue.normalizeClass(
              _ctx.classes(
                _ctx.n("item"),
                _ctx.formatElevation(_ctx.elevation, 2),
                [item === _ctx.current && !_ctx.disabled, _ctx.n("item--active")],
                [_ctx.isHideEllipsis(item, index), _ctx.n("item--hide")],
                [_ctx.disabled, _ctx.n("item--disabled")],
                [item === _ctx.current && _ctx.disabled, _ctx.n("item--disabled--active")]
              )
            ),
            onClick: ($event) => _ctx.clickItem(item, index)
          }, [
            vue.createTextVNode(
              vue.toDisplayString(item),
              1
              /* TEXT */
            )
          ], 10, _hoisted_1$f)), [
            [_directive_ripple, { disabled: _ctx.disabled }]
          ]);
        }),
        128
        /* KEYED_FRAGMENT */
      )),
      vue.withDirectives((vue.openBlock(), vue.createElementBlock(
        "li",
        {
          class: vue.normalizeClass(
            _ctx.classes(
              _ctx.n("item"),
              _ctx.n("next"),
              [_ctx.current >= _ctx.pageCount || _ctx.disabled, _ctx.n("item--disabled")],
              [_ctx.simple, _ctx.n("item--simple"), _ctx.formatElevation(_ctx.elevation, 2)]
            )
          ),
          onClick: _cache[4] || (_cache[4] = ($event) => _ctx.clickItem("next"))
        },
        [
          vue.renderSlot(_ctx.$slots, "next", {}, () => [
            vue.createVNode(_component_var_icon, { name: "chevron-right" })
          ])
        ],
        2
        /* CLASS */
      )), [
        [_directive_ripple, { disabled: _ctx.current >= _ctx.pageCount || _ctx.disabled }]
      ]),
      _ctx.showSizeChanger ? (vue.openBlock(), vue.createElementBlock(
        "li",
        {
          key: 2,
          class: vue.normalizeClass(_ctx.classes(_ctx.n("size"), [_ctx.disabled, _ctx.n("item--disabled")]))
        },
        [
          vue.createVNode(_component_var_menu_select, {
            modelValue: _ctx.size,
            "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => _ctx.size = $event),
            placement: "cover-top",
            disabled: _ctx.disabled
          }, {
            options: vue.withCtx(() => [
              (vue.openBlock(true), vue.createElementBlock(
                vue.Fragment,
                null,
                vue.renderList(_ctx.sizeOption, (option, index) => {
                  return vue.openBlock(), vue.createBlock(_component_var_menu_option, {
                    key: index,
                    value: option,
                    onClick: _ctx.clickSize
                  }, {
                    default: vue.withCtx(() => [
                      vue.createTextVNode(
                        vue.toDisplayString(option) + vue.toDisplayString((_ctx.pt ? _ctx.pt : _ctx.t)("paginationItem")) + " / " + vue.toDisplayString((_ctx.pt ? _ctx.pt : _ctx.t)("paginationPage")),
                        1
                        /* TEXT */
                      )
                    ]),
                    _: 2
                    /* DYNAMIC */
                  }, 1032, ["value", "onClick"]);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ]),
            default: vue.withCtx(() => [
              vue.createElementVNode(
                "div",
                {
                  class: vue.normalizeClass(_ctx.classes(_ctx.n("size--open"), [_ctx.current <= 1 || _ctx.disabled, _ctx.n("size--open--disabled")]))
                },
                [
                  vue.createElementVNode(
                    "span",
                    null,
                    vue.toDisplayString(_ctx.size) + vue.toDisplayString((_ctx.pt ? _ctx.pt : _ctx.t)("paginationItem")) + " / " + vue.toDisplayString((_ctx.pt ? _ctx.pt : _ctx.t)("paginationPage")),
                    1
                    /* TEXT */
                  ),
                  vue.createVNode(_component_var_icon, {
                    class: vue.normalizeClass(_ctx.n("size--open-icon")),
                    "var-pagination-cover": "",
                    name: "menu-down"
                  }, null, 8, ["class"])
                ],
                2
                /* CLASS */
              )
            ]),
            _: 1
            /* STABLE */
          }, 8, ["modelValue", "disabled"])
        ],
        2
        /* CLASS */
      )) : vue.createCommentVNode("v-if", true),
      _ctx.showQuickJumper && !_ctx.simple ? (vue.openBlock(), vue.createElementBlock(
        "li",
        {
          key: 3,
          class: vue.normalizeClass(_ctx.classes(_ctx.n("quickly"), [_ctx.disabled, _ctx.n("item--disabled")]))
        },
        [
          vue.createTextVNode(
            vue.toDisplayString((_ctx.pt ? _ctx.pt : _ctx.t)("paginationJump")) + " ",
            1
            /* TEXT */
          ),
          vue.createVNode(_component_var_input, {
            modelValue: _ctx.quickJumperValue,
            "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => _ctx.quickJumperValue = $event),
            disabled: _ctx.disabled,
            hint: false,
            "var-pagination-cover": "",
            onBlur: _cache[7] || (_cache[7] = ($event) => _ctx.setPage("quick", _ctx.quickJumperValue, $event)),
            onKeydown: _cache[8] || (_cache[8] = vue.withKeys(($event) => _ctx.setPage("quick", _ctx.quickJumperValue, $event), ["enter"]))
          }, null, 8, ["modelValue", "disabled"])
        ],
        2
        /* CLASS */
      )) : vue.createCommentVNode("v-if", true),
      _ctx.totalText ? (vue.openBlock(), vue.createElementBlock(
        "li",
        {
          key: 4,
          class: vue.normalizeClass(_ctx.classes(_ctx.n("total"), [_ctx.disabled, _ctx.n("item--disabled")]))
        },
        vue.toDisplayString(_ctx.totalText),
        3
        /* TEXT, CLASS */
      )) : vue.createCommentVNode("v-if", true)
    ],
    2
    /* CLASS */
  );
}
const __sfc__$x = vue.defineComponent({
  name: name$q,
  components: {
    VarMenuSelect: stdin_default$5E,
    VarMenuOption: stdin_default$5J,
    VarIcon: stdin_default$5_,
    VarInput: stdin_default$5N
  },
  directives: { Ripple: stdin_default$63 },
  props: props$q,
  setup(props2) {
    const quickJumperValue = vue.ref("");
    const simpleCurrentValue = vue.ref("1");
    const isHideEllipsisHead = vue.ref(false);
    const isHideEllipsisTail = vue.ref(false);
    const current = vue.ref(toNumber(props2.current) || 1);
    const size = vue.ref(toNumber(props2.size) || 10);
    const pageList = vue.ref([]);
    const activePosition = vue.computed(() => Math.ceil(props2.maxPagerCount / 2));
    const pageCount = vue.computed(() => Math.ceil(toNumber(props2.total) / toNumber(size.value)));
    const range = vue.computed(() => {
      const start2 = size.value * (current.value - 1) + 1;
      const end2 = Math.min(size.value * current.value, toNumber(props2.total));
      return [start2, end2];
    });
    const totalText = vue.computed(() => {
      if (!props2.showTotal) {
        return "";
      }
      return props2.showTotal(toNumber(props2.total), range.value);
    });
    const { t: pt } = injectLocaleProvider();
    vue.watch([() => props2.current, () => props2.size], ([newCurrent, newSize]) => {
      current.value = toNumber(newCurrent) || 1;
      size.value = toNumber(newSize || 10);
    });
    vue.watch(
      [current, size, pageCount],
      ([newCurrent, newSize, newCount], [oldCurrent, oldSize]) => {
        let list = [];
        const { maxPagerCount, total, onChange } = props2;
        const oldCount = Math.ceil(toNumber(total) / toNumber(oldSize));
        const rEllipseSign = newCount - (maxPagerCount - activePosition.value) - 1;
        simpleCurrentValue.value = `${newCurrent}`;
        if (newCount - 2 > maxPagerCount) {
          if (oldCurrent === void 0 || newCount !== oldCount) {
            for (let i = 2; i < maxPagerCount + 2; i++) {
              list.push(i);
            }
          }
          if (newCurrent <= maxPagerCount && newCurrent < rEllipseSign) {
            list = [];
            for (let i = 1; i < maxPagerCount + 1; i++) {
              list.push(i + 1);
            }
            isHideEllipsisHead.value = true;
            isHideEllipsisTail.value = false;
          }
          if (newCurrent > maxPagerCount && newCurrent < rEllipseSign) {
            list = [];
            for (let i = 1; i < maxPagerCount + 1; i++) {
              list.push(newCurrent + i - activePosition.value);
            }
            isHideEllipsisHead.value = newCurrent === 2 && maxPagerCount === 1;
            isHideEllipsisTail.value = false;
          }
          if (newCurrent >= rEllipseSign) {
            list = [];
            for (let i = 1; i < maxPagerCount + 1; i++) {
              list.push(newCount - (maxPagerCount - i) - 1);
            }
            isHideEllipsisHead.value = false;
            isHideEllipsisTail.value = true;
          }
          list = [1, "...", ...list, "...", newCount];
        } else {
          for (let i = 1; i <= newCount; i++) {
            list.push(i);
          }
        }
        pageList.value = list;
        if (oldCurrent != null && newCount > 0) {
          call(onChange, newCurrent, newSize);
        }
        call(props2["onUpdate:current"], newCurrent);
        call(props2["onUpdate:size"], newSize);
      },
      {
        immediate: true
      }
    );
    function isHideEllipsis(item, index) {
      if (isNumber(item)) {
        return false;
      }
      return index === 1 ? isHideEllipsisHead.value : isHideEllipsisTail.value;
    }
    function getMode(item, index) {
      if (isNumber(item)) {
        return "basic";
      }
      return index === 1 ? "head" : "tail";
    }
    function clickItem(item, index) {
      if (item === current.value || props2.disabled) {
        return;
      }
      if (item === "...") {
        current.value = index === 1 ? Math.max(current.value - props2.maxPagerCount, 1) : Math.min(current.value + props2.maxPagerCount, pageCount.value);
        return;
      }
      if (item === "prev") {
        current.value = ensureCurrentBoundary(current.value - 1);
        return;
      }
      if (item === "next") {
        current.value = ensureCurrentBoundary(current.value + 1);
        return;
      }
      if (isNumber(item)) {
        current.value = item;
      }
    }
    function clickSize() {
      const targetCurrent = ensureCurrentBoundary(current.value);
      simpleCurrentValue.value = String(targetCurrent);
      current.value = targetCurrent;
    }
    function ensureCurrentBoundary(targetCurrent) {
      if (targetCurrent > pageCount.value) {
        return pageCount.value;
      }
      if (targetCurrent < 1) {
        return 1;
      }
      return targetCurrent;
    }
    function setPage(type, page, event) {
      event.target.blur();
      const targetCurrent = ensureCurrentBoundary(toNumber(page));
      simpleCurrentValue.value = String(targetCurrent);
      current.value = targetCurrent;
      if (type === "quick") {
        quickJumperValue.value = "";
      }
    }
    return {
      current,
      size,
      pageCount,
      pageList,
      quickJumperValue,
      simpleCurrentValue,
      totalText,
      pt,
      t,
      n: n$t,
      classes: classes$o,
      getMode,
      isHideEllipsis,
      clickItem,
      clickSize,
      setPage,
      toNumber,
      formatElevation
    };
  }
});
__sfc__$x.render = __render__$w;
var stdin_default$44 = __sfc__$x;
withInstall(stdin_default$44);
withPropsDefaultsSetter(stdin_default$44, props$q);
const _PaginationComponent = stdin_default$44;
var stdin_default$43 = stdin_default$44;
const props$p = {
  elevation: {
    type: [Boolean, Number, String],
    default: false
  },
  ripple: Boolean,
  radius: [Number, String],
  width: [Number, String],
  height: [Number, String],
  round: Boolean,
  inline: Boolean,
  onClick: defineListenerProp()
};
const { name: name$p, n: n$s, classes: classes$n } = createNamespace("paper");
function __render__$v(_ctx, _cache) {
  const _directive_ripple = vue.resolveDirective("ripple");
  return vue.withDirectives((vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(
        _ctx.classes(
          _ctx.n(),
          _ctx.n("$--box"),
          _ctx.formatElevation(_ctx.elevation, 2),
          [_ctx.onClick, _ctx.n("--cursor")],
          [_ctx.round, _ctx.n("--round")],
          [_ctx.inline, _ctx.n("$--inline-flex")]
        )
      ),
      style: vue.normalizeStyle({
        width: _ctx.toSizeUnit(_ctx.width),
        height: _ctx.toSizeUnit(_ctx.height),
        "border-radius": _ctx.toSizeUnit(_ctx.radius)
      }),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    },
    [
      vue.renderSlot(_ctx.$slots, "default")
    ],
    6
    /* CLASS, STYLE */
  )), [
    [_directive_ripple, { disabled: !_ctx.ripple }]
  ]);
}
const __sfc__$w = vue.defineComponent({
  name: name$p,
  directives: { Ripple: stdin_default$63 },
  props: props$p,
  setup(props2) {
    function handleClick(e) {
      call(props2.onClick, e);
    }
    return {
      n: n$s,
      classes: classes$n,
      formatElevation,
      toSizeUnit,
      handleClick
    };
  }
});
__sfc__$w.render = __render__$v;
var stdin_default$42 = __sfc__$w;
withInstall(stdin_default$42);
withPropsDefaultsSetter(stdin_default$42, props$p);
const _PaperComponent = stdin_default$42;
var stdin_default$41 = stdin_default$42;
var __defProp$7 = Object.defineProperty;
var __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;
var __hasOwnProp$7 = Object.prototype.hasOwnProperty;
var __propIsEnum$7 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$7 = (obj, key3, value) => key3 in obj ? __defProp$7(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$7 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$7.call(b, prop))
      __defNormalProp$7(a, prop, b[prop]);
  if (__getOwnPropSymbols$7)
    for (var prop of __getOwnPropSymbols$7(b)) {
      if (__propIsEnum$7.call(b, prop))
        __defNormalProp$7(a, prop, b[prop]);
    }
  return a;
};
const props$o = __spreadValues$7({
  modelValue: {
    type: Array,
    default: () => []
  },
  columns: {
    type: Array,
    default: () => []
  },
  title: String,
  textKey: {
    type: String,
    default: "text"
  },
  valueKey: {
    type: String,
    default: "value"
  },
  childrenKey: {
    type: String,
    default: "children"
  },
  toolbar: {
    type: Boolean,
    default: true
  },
  cascade: Boolean,
  optionHeight: {
    type: [Number, String],
    default: 44
  },
  optionCount: {
    type: [Number, String],
    default: 6
  },
  columnsCount: [String, Number],
  confirmButtonText: String,
  cancelButtonText: String,
  confirmButtonTextColor: String,
  cancelButtonTextColor: String,
  // dynamic internal
  dynamic: Boolean,
  onChange: defineListenerProp(),
  onConfirm: defineListenerProp(),
  onCancel: defineListenerProp(),
  "onUpdate:modelValue": defineListenerProp()
}, pickProps(props$1l, [
  "show",
  "onUpdate:show",
  "closeOnClickOverlay",
  "closeOnKeyEscape",
  "teleport",
  "safeArea",
  "onOpen",
  "onClose",
  "onOpened",
  "onClosed",
  "onClickOverlay",
  "onRouteChange",
  "onKeyEscape"
]));
const { name: name$o, n: n$r, classes: classes$m } = createNamespace("picker");
const MOMENTUM_RECORD_TIME = 300;
const MOMENTUM_ALLOW_DISTANCE = 15;
const TRANSITION_DURATION = 200;
const MOMENTUM_TRANSITION_DURATION = 1e3;
let sid$1 = 0;
const _hoisted_1$e = ["onTouchstartPassive", "onTouchmove", "onTouchend"];
const _hoisted_2$4 = ["onTransitionend"];
const _hoisted_3$3 = ["onClick"];
function __render__$u(_ctx, _cache) {
  const _component_var_button = vue.resolveComponent("var-button");
  return vue.openBlock(), vue.createBlock(
    vue.resolveDynamicComponent(_ctx.dynamic ? _ctx.n("$-popup") : _ctx.Transition),
    vue.mergeProps(
      _ctx.dynamic ? {
        onOpen: _ctx.onOpen,
        onOpened: _ctx.onOpened,
        onClose: _ctx.onClose,
        onClosed: _ctx.onClosed,
        onClickOverlay: _ctx.onClickOverlay,
        onRouteChange: _ctx.onRouteChange,
        onKeyEscape: _ctx.onKeyEscape,
        closeOnClickOverlay: _ctx.closeOnClickOverlay,
        closeOnKeyEscape: _ctx.closeOnKeyEscape,
        teleport: _ctx.teleport,
        show: _ctx.show,
        safeArea: _ctx.safeArea,
        "onUpdate:show": _ctx.handlePopupUpdateShow,
        position: "bottom",
        class: _ctx.n("popup")
      } : null,
      { "var-picker-cover": "" }
    ),
    {
      default: vue.withCtx(() => [
        vue.createElementVNode(
          "div",
          vue.mergeProps({
            class: _ctx.n()
          }, _ctx.$attrs),
          [
            _ctx.toolbar ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 0,
                class: vue.normalizeClass(_ctx.n("toolbar"))
              },
              [
                vue.renderSlot(_ctx.$slots, "cancel", {}, () => [
                  vue.createVNode(_component_var_button, {
                    class: vue.normalizeClass(_ctx.n("cancel-button")),
                    "var-picker-cover": "",
                    text: "",
                    "text-color": _ctx.cancelButtonTextColor,
                    onClick: _ctx.cancel
                  }, {
                    default: vue.withCtx(() => {
                      var _a;
                      return [
                        vue.createTextVNode(
                          vue.toDisplayString((_a = _ctx.cancelButtonText) != null ? _a : (_ctx.pt ? _ctx.pt : _ctx.t)("pickerCancelButtonText")),
                          1
                          /* TEXT */
                        )
                      ];
                    }),
                    _: 1
                    /* STABLE */
                  }, 8, ["class", "text-color", "onClick"])
                ]),
                vue.renderSlot(_ctx.$slots, "title", {}, () => {
                  var _a;
                  return [
                    vue.createElementVNode(
                      "div",
                      {
                        class: vue.normalizeClass(_ctx.n("title"))
                      },
                      vue.toDisplayString((_a = _ctx.title) != null ? _a : (_ctx.pt ? _ctx.pt : _ctx.t)("pickerTitle")),
                      3
                      /* TEXT, CLASS */
                    )
                  ];
                }),
                vue.renderSlot(_ctx.$slots, "confirm", {}, () => [
                  vue.createVNode(_component_var_button, {
                    class: vue.normalizeClass(_ctx.n("confirm-button")),
                    text: "",
                    "var-picker-cover": "",
                    "text-color": _ctx.confirmButtonTextColor,
                    onClick: _ctx.confirm
                  }, {
                    default: vue.withCtx(() => {
                      var _a;
                      return [
                        vue.createTextVNode(
                          vue.toDisplayString((_a = _ctx.confirmButtonText) != null ? _a : (_ctx.pt ? _ctx.pt : _ctx.t)("pickerConfirmButtonText")),
                          1
                          /* TEXT */
                        )
                      ];
                    }),
                    _: 1
                    /* STABLE */
                  }, 8, ["class", "text-color", "onClick"])
                ])
              ],
              2
              /* CLASS */
            )) : vue.createCommentVNode("v-if", true),
            vue.createElementVNode(
              "div",
              {
                class: vue.normalizeClass(_ctx.n("columns")),
                style: vue.normalizeStyle({ height: `${_ctx.columnHeight}px` })
              },
              [
                (vue.openBlock(true), vue.createElementBlock(
                  vue.Fragment,
                  null,
                  vue.renderList(_ctx.scrollColumns, (c) => {
                    return vue.openBlock(), vue.createElementBlock("div", {
                      key: c.id,
                      class: vue.normalizeClass(_ctx.n("column")),
                      onTouchstartPassive: ($event) => _ctx.handleTouchstart($event, c),
                      onTouchmove: vue.withModifiers(($event) => _ctx.handleTouchmove($event, c), ["prevent"]),
                      onTouchend: ($event) => _ctx.handleTouchend(c)
                    }, [
                      vue.createElementVNode("div", {
                        ref_for: true,
                        ref: (el) => _ctx.setScrollEl(el, c),
                        class: vue.normalizeClass(_ctx.n("scroller")),
                        style: vue.normalizeStyle({
                          transform: `translateY(${c.translate}px)`,
                          transitionDuration: `${c.duration}ms`,
                          transitionProperty: c.duration ? "transform" : "none"
                        }),
                        onTransitionend: ($event) => _ctx.handleTransitionend(c)
                      }, [
                        (vue.openBlock(true), vue.createElementBlock(
                          vue.Fragment,
                          null,
                          vue.renderList(c.column, (option, index) => {
                            return vue.openBlock(), vue.createElementBlock("div", {
                              key: _ctx.getValue(option),
                              class: vue.normalizeClass(_ctx.classes(_ctx.n("option"), option.className)),
                              style: vue.normalizeStyle({ height: `${_ctx.optionHeight}px` }),
                              onClick: ($event) => _ctx.handleClick(c, index)
                            }, [
                              vue.createElementVNode(
                                "div",
                                {
                                  class: vue.normalizeClass(_ctx.classes(_ctx.n("text"), option.textClassName))
                                },
                                vue.toDisplayString(option[_ctx.getOptionKey("text")]),
                                3
                                /* TEXT, CLASS */
                              )
                            ], 14, _hoisted_3$3);
                          }),
                          128
                          /* KEYED_FRAGMENT */
                        ))
                      ], 46, _hoisted_2$4)
                    ], 42, _hoisted_1$e);
                  }),
                  128
                  /* KEYED_FRAGMENT */
                )),
                vue.createElementVNode(
                  "div",
                  {
                    class: vue.normalizeClass(_ctx.n("picked")),
                    style: vue.normalizeStyle({
                      top: `${_ctx.center}px`,
                      height: `${_ctx.optionHeight}px`
                    })
                  },
                  null,
                  6
                  /* CLASS, STYLE */
                ),
                vue.createElementVNode(
                  "div",
                  {
                    class: vue.normalizeClass(_ctx.n("mask")),
                    style: vue.normalizeStyle({ backgroundSize: `100% ${(_ctx.columnHeight - _ctx.optionHeight) / 2}px` })
                  },
                  null,
                  6
                  /* CLASS, STYLE */
                )
              ],
              6
              /* CLASS, STYLE */
            )
          ],
          16
          /* FULL_PROPS */
        )
      ]),
      _: 3
      /* FORWARDED */
    },
    16
    /* FULL_PROPS */
  );
}
const __sfc__$v = vue.defineComponent({
  name: name$o,
  components: {
    VarButton: stdin_default$5t,
    VarPopup: stdin_default$64
  },
  inheritAttrs: false,
  props: props$o,
  setup(props2) {
    const modelValue = useVModel(props2, "modelValue");
    const scrollColumns = vue.ref([]);
    const visibleColumnsCount = vue.computed(() => toNumber(props2.columnsCount));
    const optionHeight = vue.computed(() => toPxNum(props2.optionHeight));
    const optionCount = vue.computed(() => toPxNum(props2.optionCount));
    const center = vue.computed(() => optionCount.value * optionHeight.value / 2 - optionHeight.value / 2);
    const columnHeight = vue.computed(() => optionCount.value * optionHeight.value);
    const { prevY, moveY, dragging, startTouch, moveTouch, endTouch } = useTouch();
    const { t: pt } = injectLocaleProvider();
    let prevIndexes = [];
    initScrollColumns();
    vue.watch(() => props2.columns, initScrollColumns, { deep: true });
    vue.watch(() => modelValue.value, initScrollColumns);
    function getOptionKey(key3) {
      const keyMap = {
        text: props2.textKey,
        value: props2.valueKey,
        children: props2.childrenKey
      };
      return keyMap[key3];
    }
    function getValue(option) {
      var _a;
      return (_a = option[getOptionKey("value")]) != null ? _a : option[getOptionKey("text")];
    }
    function setPrevIndexes(indexes) {
      prevIndexes = [...indexes];
    }
    function normalizeNormalMode(columns) {
      const visibleColumns = props2.columnsCount != null ? columns.slice(0, visibleColumnsCount.value) : columns;
      return visibleColumns.map((column, idx) => {
        const scrollColumn = {
          id: sid$1++,
          prevY: 0,
          momentumPrevY: 0,
          touching: false,
          translate: center.value,
          index: 0,
          duration: 0,
          momentumTime: 0,
          column,
          scrollEl: null,
          scrolling: false
        };
        const value = modelValue.value[idx];
        const index = scrollColumn.column.findIndex((option) => value === getValue(option));
        scrollColumn.index = index === -1 ? 0 : index;
        scrollTo2(scrollColumn);
        return scrollColumn;
      });
    }
    function normalizeCascadeMode(column) {
      const scrollColumns2 = [];
      createChildren(scrollColumns2, column);
      return scrollColumns2;
    }
    function createChildren(scrollColumns2, children, syncModelValue = true, depth = 1) {
      var _a;
      if (children.length && (props2.columnsCount == null || depth <= visibleColumnsCount.value)) {
        const scrollColumn = {
          id: sid$1++,
          prevY: 0,
          momentumPrevY: 0,
          touching: false,
          translate: center.value,
          index: 0,
          duration: 0,
          momentumTime: 0,
          column: children,
          scrollEl: null,
          scrolling: false
        };
        scrollColumns2.push(scrollColumn);
        if (syncModelValue) {
          const value = modelValue.value[scrollColumns2.length - 1];
          const index = children.findIndex((option) => value === getValue(option));
          scrollColumn.index = index === -1 ? 0 : index;
        }
        scrollTo2(scrollColumn);
        createChildren(
          scrollColumns2,
          (_a = scrollColumn.column[scrollColumn.index][getOptionKey("children")]) != null ? _a : [],
          syncModelValue,
          depth + 1
        );
      }
    }
    function rebuildChildren(scrollColumn) {
      var _a;
      scrollColumns.value.splice(scrollColumns.value.indexOf(scrollColumn) + 1);
      createChildren(
        scrollColumns.value,
        (_a = scrollColumn.column[scrollColumn.index][getOptionKey("children")]) != null ? _a : [],
        false,
        scrollColumns.value.length + 1
      );
    }
    function initScrollColumns() {
      scrollColumns.value = props2.cascade ? normalizeCascadeMode(props2.columns) : normalizeNormalMode(props2.columns);
      const { indexes } = getPicked();
      setPrevIndexes(indexes);
    }
    function setScrollEl(el, scrollColumn) {
      scrollColumn.scrollEl = el;
    }
    function handlePopupUpdateShow(value) {
      call(props2["onUpdate:show"], value);
    }
    function clampTranslate(scrollColumn) {
      const minTranslate = center.value - scrollColumn.column.length * optionHeight.value;
      const maxTranslate = optionHeight.value + center.value;
      scrollColumn.translate = clamp$1(scrollColumn.translate, minTranslate, maxTranslate);
    }
    function getTargetIndex(scrollColumn, viewTranslate) {
      const index = Math.round((center.value - viewTranslate) / optionHeight.value);
      return clampArrayRange(index, scrollColumn.column);
    }
    function updateTranslate(scrollColumn) {
      scrollColumn.translate = center.value - scrollColumn.index * optionHeight.value;
      return scrollColumn.translate;
    }
    function getPicked() {
      const values = [];
      const indexes = [];
      const options = [];
      scrollColumns.value.forEach(({ column, index }) => {
        const option = column[index];
        values.push(getValue(option));
        indexes.push(index);
        options.push(option);
      });
      return {
        values,
        indexes,
        options
      };
    }
    function scrollTo2(scrollColumn, duration = 0) {
      updateTranslate(scrollColumn);
      scrollColumn.duration = duration;
    }
    function momentum(scrollColumn, distance, duration) {
      scrollColumn.translate += Math.abs(distance / duration) / 3e-3 * (distance < 0 ? -1 : 1);
    }
    function handleClick(scrollColumn, index) {
      if (dragging.value) {
        return;
      }
      scrollColumn.index = index;
      scrollTo2(scrollColumn, TRANSITION_DURATION);
    }
    function handleTouchstart(event, scrollColumn) {
      scrollColumn.touching = true;
      scrollColumn.translate = getTranslateY(scrollColumn.scrollEl);
      startTouch(event);
    }
    function handleTouchmove(event, scrollColumn) {
      if (!scrollColumn.touching) {
        return;
      }
      moveTouch(event);
      scrollColumn.scrolling = false;
      scrollColumn.duration = 0;
      scrollColumn.prevY = prevY.value;
      scrollColumn.translate += moveY.value;
      clampTranslate(scrollColumn);
      const now = performance.now();
      if (now - scrollColumn.momentumTime > MOMENTUM_RECORD_TIME) {
        scrollColumn.momentumTime = now;
        scrollColumn.momentumPrevY = scrollColumn.translate;
      }
    }
    function handleTouchend(scrollColumn) {
      endTouch();
      scrollColumn.touching = false;
      scrollColumn.prevY = 0;
      const distance = scrollColumn.translate - scrollColumn.momentumPrevY;
      const duration = performance.now() - scrollColumn.momentumTime;
      const shouldMomentum = Math.abs(distance) >= MOMENTUM_ALLOW_DISTANCE && duration <= MOMENTUM_RECORD_TIME;
      const oldTranslate = scrollColumn.translate;
      if (shouldMomentum) {
        momentum(scrollColumn, distance, duration);
      }
      scrollColumn.index = getTargetIndex(scrollColumn, scrollColumn.translate);
      scrollTo2(scrollColumn, shouldMomentum ? MOMENTUM_TRANSITION_DURATION : TRANSITION_DURATION);
      scrollColumn.scrolling = scrollColumn.translate !== oldTranslate;
      if (!scrollColumn.scrolling) {
        handleScrollColumnChange(scrollColumn);
      }
    }
    function handleTransitionend(scrollColumn) {
      scrollColumn.scrolling = false;
      handleScrollColumnChange(scrollColumn);
    }
    function isSamePicked() {
      const { indexes } = getPicked();
      return indexes.every((index, idx) => index === prevIndexes[idx]);
    }
    function handleScrollColumnChange(scrollColumn) {
      const { onChange, cascade } = props2;
      if (isSamePicked()) {
        return;
      }
      if (cascade) {
        rebuildChildren(scrollColumn);
      }
      const hasScrolling = scrollColumns.value.some((scrollColumn2) => scrollColumn2.scrolling);
      const hasTouching = scrollColumns.value.some((scrollColumn2) => scrollColumn2.touching);
      if (hasScrolling || hasTouching) {
        return;
      }
      const { values, indexes, options } = getPicked();
      setPrevIndexes(indexes);
      call(onChange, values, indexes, options);
      modelValue.value = values;
    }
    function stopScroll() {
      if (props2.cascade) {
        const currentScrollColumn = scrollColumns.value.find((scrollColumn) => scrollColumn.scrolling);
        if (currentScrollColumn) {
          currentScrollColumn.index = getTargetIndex(currentScrollColumn, getTranslateY(currentScrollColumn.scrollEl));
          currentScrollColumn.scrolling = false;
          scrollTo2(currentScrollColumn);
          rebuildChildren(currentScrollColumn);
        }
      } else {
        scrollColumns.value.forEach((scrollColumn) => {
          scrollColumn.index = getTargetIndex(scrollColumn, getTranslateY(scrollColumn.scrollEl));
          scrollTo2(scrollColumn);
        });
      }
    }
    function confirm() {
      stopScroll();
      const { values, indexes, options } = getPicked();
      setPrevIndexes(indexes);
      call(props2.onConfirm, values, indexes, options);
    }
    function cancel() {
      stopScroll();
      const { values, indexes, options } = getPicked();
      setPrevIndexes(indexes);
      call(props2.onCancel, values, indexes, options);
    }
    return {
      optionHeight,
      optionCount,
      scrollColumns,
      columnHeight,
      center,
      Transition: vue.Transition,
      pt,
      t,
      n: n$r,
      classes: classes$m,
      setScrollEl,
      getOptionKey,
      getValue,
      handlePopupUpdateShow,
      handleTouchstart,
      handleTouchmove,
      handleTouchend,
      handleTransitionend,
      confirm,
      cancel,
      handleClick
    };
  }
});
__sfc__$v.render = __render__$u;
var stdin_default$40 = __sfc__$v;
let singletonOptions;
function Picker(options) {
  return new Promise((resolve) => {
    Picker.close();
    const pickerOptions = isArray(options) ? { columns: options } : options;
    const reactivePickerOptions = vue.reactive(pickerOptions);
    reactivePickerOptions.dynamic = true;
    reactivePickerOptions.teleport = "body";
    singletonOptions = reactivePickerOptions;
    function resetSingletonOptions() {
      singletonOptions === reactivePickerOptions && (singletonOptions = null);
    }
    const { unmountInstance } = mountInstance(stdin_default$40, reactivePickerOptions, {
      onConfirm: (values, indexes, options2) => {
        call(reactivePickerOptions.onConfirm, values, indexes, options2);
        resolve({
          state: "confirm",
          values,
          indexes,
          options: options2
        });
        reactivePickerOptions.show = false;
        resetSingletonOptions();
      },
      onCancel: (values, indexes, options2) => {
        call(reactivePickerOptions.onCancel, values, indexes, options2);
        resolve({
          state: "cancel",
          values,
          indexes,
          options: options2
        });
        reactivePickerOptions.show = false;
        resetSingletonOptions();
      },
      onClose: () => {
        call(reactivePickerOptions.onClose);
        resolve({
          state: "close"
        });
        resetSingletonOptions();
      },
      onClosed: () => {
        call(reactivePickerOptions.onClosed);
        unmountInstance();
        resetSingletonOptions();
      },
      onRouteChange: () => {
        unmountInstance();
        resetSingletonOptions();
      },
      "onUpdate:show": (value) => {
        reactivePickerOptions.show = value;
      }
    });
    reactivePickerOptions.show = true;
  });
}
Picker.close = function() {
  if (singletonOptions == null) {
    return;
  }
  const prevSingletonOptions = singletonOptions;
  singletonOptions = null;
  vue.nextTick().then(() => {
    prevSingletonOptions.show = false;
  });
};
Picker.Component = stdin_default$40;
withInstall(stdin_default$40);
withInstall(stdin_default$40, Picker);
withPropsDefaultsSetter(Picker, props$o);
const _PickerComponent = stdin_default$40;
var stdin_default$3$ = Picker;
const props$n = {
  mode: {
    type: String,
    default: "linear"
  },
  lineWidth: {
    type: [Number, String],
    default: 4
  },
  color: [String, Object],
  trackColor: String,
  value: {
    type: [Number, String],
    default: 0
  },
  label: Boolean,
  labelClass: String,
  size: {
    type: [Number, String],
    default: 40
  },
  rotate: {
    type: Number,
    default: 0
  },
  track: {
    type: Boolean,
    default: true
  },
  indeterminate: Boolean,
  type: {
    type: String,
    default: "primary"
  }
};
const MAX = 100;
const MIN = 0;
const RADIUS = 20;
const CIRCUMFERENCE = 2 * Math.PI * RADIUS;
const { name: name$n, n: n$q, classes: classes$l } = createNamespace("progress");
const _hoisted_1$d = ["aria-valuenow"];
const _hoisted_2$3 = ["viewBox"];
const _hoisted_3$2 = { key: 0 };
const _hoisted_4$2 = ["id"];
const _hoisted_5$1 = ["offset", "stop-color"];
const _hoisted_6$1 = ["d", "stroke-width", "stroke-dasharray"];
const _hoisted_7 = ["d", "stroke-width", "stroke-dasharray", "stroke-dashoffset"];
function __render__$t(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock("div", {
    class: vue.normalizeClass(_ctx.n()),
    role: "progressbar",
    "aria-valuemin": "0",
    "aria-valuemax": "100",
    "aria-valuenow": _ctx.indeterminate ? void 0 : _ctx.mode === "linear" ? _ctx.linearProps.value : _ctx.circleProps.value
  }, [
    _ctx.mode === "linear" ? (vue.openBlock(), vue.createElementBlock(
      "div",
      {
        key: 0,
        class: vue.normalizeClass(_ctx.n("linear"))
      },
      [
        vue.createElementVNode(
          "div",
          {
            class: vue.normalizeClass(_ctx.classes(_ctx.n("linear-block"), [_ctx.track, _ctx.n("linear-background")])),
            style: vue.normalizeStyle({ height: _ctx.toSizeUnit(_ctx.lineWidth), background: _ctx.trackColor })
          },
          [
            _ctx.indeterminate ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 0,
                class: vue.normalizeClass(_ctx.n("linear-indeterminate"))
              },
              [
                vue.createElementVNode(
                  "div",
                  {
                    class: vue.normalizeClass(_ctx.classes(_ctx.n(`linear--${_ctx.type}`))),
                    style: vue.normalizeStyle({ background: _ctx.progressColor })
                  },
                  null,
                  6
                  /* CLASS, STYLE */
                ),
                vue.createElementVNode(
                  "div",
                  {
                    class: vue.normalizeClass(_ctx.classes(_ctx.n(`linear--${_ctx.type}`))),
                    style: vue.normalizeStyle({ background: _ctx.progressColor })
                  },
                  null,
                  6
                  /* CLASS, STYLE */
                )
              ],
              2
              /* CLASS */
            )) : (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 1,
                class: vue.normalizeClass(_ctx.classes(_ctx.n("linear-certain"), _ctx.n(`linear--${_ctx.type}`))),
                style: vue.normalizeStyle({ background: _ctx.progressColor, width: _ctx.linearProps.width })
              },
              null,
              6
              /* CLASS, STYLE */
            ))
          ],
          6
          /* CLASS, STYLE */
        ),
        _ctx.label ? (vue.openBlock(), vue.createElementBlock(
          "div",
          {
            key: 0,
            class: vue.normalizeClass(_ctx.classes(_ctx.n("linear-label"), [_ctx.labelClass, _ctx.labelClass]))
          },
          [
            vue.renderSlot(_ctx.$slots, "default", {}, () => [
              vue.createTextVNode(
                vue.toDisplayString(_ctx.linearProps.roundValue),
                1
                /* TEXT */
              )
            ])
          ],
          2
          /* CLASS */
        )) : vue.createCommentVNode("v-if", true)
      ],
      2
      /* CLASS */
    )) : vue.createCommentVNode("v-if", true),
    _ctx.mode === "circle" ? (vue.openBlock(), vue.createElementBlock(
      "div",
      {
        key: 1,
        class: vue.normalizeClass(_ctx.classes(_ctx.n("circle"), [_ctx.indeterminate, _ctx.n("circle-indeterminate")])),
        style: vue.normalizeStyle({ width: _ctx.toSizeUnit(_ctx.size), height: _ctx.toSizeUnit(_ctx.size) })
      },
      [
        (vue.openBlock(), vue.createElementBlock("svg", {
          class: vue.normalizeClass(_ctx.n("circle-svg")),
          viewBox: _ctx.circleProps.viewBox
        }, [
          _ctx.isPlainObject(_ctx.color) ? (vue.openBlock(), vue.createElementBlock("defs", _hoisted_3$2, [
            vue.createElementVNode("linearGradient", {
              id: _ctx.id,
              x1: "100%",
              y1: "0%",
              x2: "0%",
              y2: "0%"
            }, [
              (vue.openBlock(true), vue.createElementBlock(
                vue.Fragment,
                null,
                vue.renderList(_ctx.linearGradientProgress, (progress, idx) => {
                  return vue.openBlock(), vue.createElementBlock("stop", {
                    key: idx,
                    offset: progress,
                    "stop-color": _ctx.color[progress]
                  }, null, 8, _hoisted_5$1);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ], 8, _hoisted_4$2)
          ])) : vue.createCommentVNode("v-if", true),
          _ctx.track ? (vue.openBlock(), vue.createElementBlock("path", {
            key: 1,
            class: vue.normalizeClass(_ctx.n("circle-background")),
            d: _ctx.circleProps.path,
            fill: "transparent",
            "stroke-width": _ctx.circleProps.strokeWidth,
            "stroke-dasharray": _ctx.CIRCUMFERENCE,
            style: vue.normalizeStyle({
              stroke: _ctx.trackColor
            })
          }, null, 14, _hoisted_6$1)) : vue.createCommentVNode("v-if", true),
          vue.createElementVNode("path", {
            class: vue.normalizeClass(_ctx.classes(_ctx.n("circle-certain"), _ctx.n(`circle--${_ctx.type}`), [_ctx.indeterminate, _ctx.n("circle-overlay")])),
            d: _ctx.circleProps.path,
            fill: "transparent",
            "stroke-width": _ctx.circleProps.strokeWidth,
            "stroke-dasharray": _ctx.CIRCUMFERENCE,
            "stroke-dashoffset": _ctx.circleProps.strokeOffset,
            style: vue.normalizeStyle({
              stroke: _ctx.progressColor,
              transform: `rotateZ(${_ctx.rotate}deg)`,
              transformOrigin: "50% 50%"
            })
          }, null, 14, _hoisted_7)
        ], 10, _hoisted_2$3)),
        _ctx.label ? (vue.openBlock(), vue.createElementBlock(
          "div",
          {
            key: 0,
            class: vue.normalizeClass(_ctx.classes(_ctx.n("circle-label"), _ctx.labelClass))
          },
          [
            vue.renderSlot(_ctx.$slots, "default", {}, () => [
              vue.createTextVNode(
                vue.toDisplayString(_ctx.circleProps.roundValue),
                1
                /* TEXT */
              )
            ])
          ],
          2
          /* CLASS */
        )) : vue.createCommentVNode("v-if", true)
      ],
      6
      /* CLASS, STYLE */
    )) : vue.createCommentVNode("v-if", true)
  ], 10, _hoisted_1$d);
}
const __sfc__$u = vue.defineComponent({
  name: name$n,
  props: props$n,
  setup(props2) {
    const id = useClientId();
    const linearProps = vue.computed(() => {
      const value = toNumber(props2.value);
      const width = clamp$1(value, MIN, MAX);
      const roundValue = clamp$1(Math.round(value), MIN, MAX);
      return {
        width: `${width}%`,
        roundValue: `${roundValue}%`,
        value: width
      };
    });
    const circleProps = vue.computed(() => {
      const { size, lineWidth, value } = props2;
      const diameter = RADIUS / (1 - toPxNum(lineWidth) / toPxNum(size)) * 2;
      const viewBox = `0 0 ${diameter} ${diameter}`;
      const roundValue = clamp$1(Math.round(toNumber(value)), MIN, MAX);
      const strokeOffset = `${(MAX - roundValue) / MAX * CIRCUMFERENCE}`;
      const strokeWidth = toPxNum(lineWidth) / toPxNum(size) * diameter;
      const beginPositionX = 0;
      const beginPositionY = -RADIUS;
      const endPositionX = 0;
      const endPositionY = -2 * RADIUS;
      const path = `M ${diameter / 2} ${diameter / 2} m ${beginPositionX} ${beginPositionY} a ${RADIUS} ${RADIUS} 
        0 1 1 ${endPositionX} ${-endPositionY} a ${RADIUS} ${RADIUS} 0 1 1 ${-endPositionX} ${endPositionY}`;
      return {
        strokeWidth,
        viewBox,
        strokeOffset,
        roundValue: `${roundValue}%`,
        path,
        value: clamp$1(toNumber(value), MIN, MAX)
      };
    });
    const progressColor = vue.computed(() => {
      if (isPlainObject(props2.color)) {
        return `url(#${id.value})`;
      }
      return props2.color;
    });
    const linearGradientProgress = vue.computed(
      () => Object.keys(props2.color).sort((a, b) => parseFloat(a) - parseFloat(b))
    );
    return {
      id,
      linearProps,
      CIRCUMFERENCE,
      RADIUS,
      circleProps,
      progressColor,
      linearGradientProgress,
      n: n$q,
      classes: classes$l,
      toSizeUnit,
      isPlainObject
    };
  }
});
__sfc__$u.render = __render__$t;
var stdin_default$3_ = __sfc__$u;
withInstall(stdin_default$3_);
withPropsDefaultsSetter(stdin_default$3_, props$n);
const _ProgressComponent = stdin_default$3_;
var stdin_default$3Z = stdin_default$3_;
const props$m = {
  modelValue: Boolean,
  disabled: Boolean,
  animationDuration: {
    type: [Number, String],
    default: 300
  },
  successDuration: {
    type: [Number, String],
    default: 2e3
  },
  bgColor: String,
  successBgColor: String,
  color: String,
  successColor: String,
  target: [String, Object],
  onRefresh: defineListenerProp(),
  "onUpdate:modelValue": defineListenerProp()
};
var __async$4 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const { name: name$m, n: n$p, classes: classes$k } = createNamespace("pull-refresh");
const ICON_TRANSITION = 150;
function __render__$s(_ctx, _cache) {
  const _component_var_icon = vue.resolveComponent("var-icon");
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      ref: "freshNode",
      class: vue.normalizeClass(_ctx.n()),
      onTouchstart: _cache[0] || (_cache[0] = (...args) => _ctx.handleTouchstart && _ctx.handleTouchstart(...args)),
      onTouchend: _cache[1] || (_cache[1] = (...args) => _ctx.handleTouchend && _ctx.handleTouchend(...args)),
      onTouchcancel: _cache[2] || (_cache[2] = (...args) => _ctx.handleTouchend && _ctx.handleTouchend(...args))
    },
    [
      vue.createElementVNode(
        "div",
        {
          ref: "controlNode",
          class: vue.normalizeClass(_ctx.classes(_ctx.n("control"), _ctx.n("$-elevation--2"), [_ctx.isSuccess, _ctx.n("control-success")])),
          style: vue.normalizeStyle(_ctx.controlStyle)
        },
        [
          vue.createVNode(_component_var_icon, {
            name: _ctx.iconName,
            transition: _ctx.ICON_TRANSITION,
            class: vue.normalizeClass(_ctx.classes(_ctx.n("icon"), [_ctx.refreshStatus === "loading", _ctx.n("animation")])),
            "var-pull-refresh-cover": ""
          }, null, 8, ["name", "transition", "class"])
        ],
        6
        /* CLASS, STYLE */
      ),
      vue.renderSlot(_ctx.$slots, "default")
    ],
    34
    /* CLASS, NEED_HYDRATION */
  );
}
const __sfc__$t = vue.defineComponent({
  name: name$m,
  components: { VarIcon: stdin_default$5_ },
  props: props$m,
  setup(props2) {
    const controlPosition = vue.ref(0);
    const freshNode = vue.ref(null);
    const controlNode = vue.ref(null);
    const startPosition = vue.ref(0);
    const distance = vue.ref("-125%");
    const iconName = vue.ref("arrow-down");
    const refreshStatus = vue.ref("default");
    const isEnd = vue.ref(false);
    const maxDistance = vue.computed(() => Math.abs(2 * controlPosition.value));
    const isSuccess = vue.computed(() => refreshStatus.value === "success");
    const isTouchable = vue.computed(
      () => refreshStatus.value !== "loading" && refreshStatus.value !== "success" && !props2.disabled
    );
    const controlStyle = vue.computed(() => ({
      transform: `translate3d(0px, ${isString(distance.value) ? distance.value : `${distance.value}px`}, 0px) translate(-50%, 0)`,
      transition: isEnd.value ? `transform ${props2.animationDuration}ms` : void 0,
      background: isSuccess.value ? props2.successBgColor : props2.bgColor,
      color: isSuccess.value ? props2.successColor : props2.color
    }));
    const { startTouch, moveTouch, endTouch, isReachTop } = useTouch();
    let scroller;
    let eventTargetScroller;
    vue.watch(
      () => props2.modelValue,
      (newValue) => {
        if (newValue === false) {
          isEnd.value = true;
          refreshStatus.value = "success";
          iconName.value = "checkbox-marked-circle";
          setTimeout(() => {
            distance.value = controlPosition.value;
            reset();
          }, toNumber(props2.successDuration));
        }
      }
    );
    onSmartMounted(setScroller);
    useEventListener(freshNode, "touchmove", handleTouchmove);
    function startIconTransition(name2) {
      if (iconName.value === name2) {
        return;
      }
      iconName.value = name2;
      return new Promise((resolve) => {
        window.setTimeout(resolve, ICON_TRANSITION);
      });
    }
    function lockEvent(action) {
      const el = "classList" in scroller ? scroller : document.body;
      el.classList[action](`${n$p()}--lock`);
    }
    function handleTouchstart(event) {
      startTouch(event);
      if (controlPosition.value === 0) {
        const { width } = getRect(controlNode.value);
        controlPosition.value = -(width + width * 0.25);
      }
      eventTargetScroller = getParentScroller(event.target);
    }
    function handleTouchmove(event) {
      moveTouch(event);
      if (!isTouchable.value || !eventTargetScroller) {
        return;
      }
      if (eventTargetScroller !== scroller && getScrollTop(eventTargetScroller) > 0) {
        return;
      }
      const scrollTop = getScrollTop(scroller);
      if (scrollTop > 0) {
        return;
      }
      if (isReachTop(scroller)) {
        preventDefault(event);
      }
      if (refreshStatus.value !== "pulling") {
        refreshStatus.value = "pulling";
        startPosition.value = event.touches[0].clientY;
      }
      if (isReachTop(scroller) && isNumber(distance.value) && distance.value > controlPosition.value) {
        lockEvent("add");
      }
      const moveDistance = (event.touches[0].clientY - startPosition.value) / 2 + controlPosition.value;
      distance.value = moveDistance >= maxDistance.value ? maxDistance.value : moveDistance;
      startIconTransition(distance.value >= maxDistance.value * 0.2 ? "refresh" : "arrow-down");
    }
    function handleTouchend() {
      return __async$4(this, null, function* () {
        endTouch();
        if (!isTouchable.value) {
          return;
        }
        isEnd.value = true;
        if (toNumber(distance.value) >= maxDistance.value * 0.2) {
          yield startIconTransition("refresh");
          refreshStatus.value = "loading";
          distance.value = maxDistance.value * 0.3;
          call(props2["onUpdate:modelValue"], true);
          vue.nextTick(() => {
            call(props2.onRefresh);
          });
          lockEvent("remove");
        } else {
          refreshStatus.value = "loosing";
          iconName.value = "arrow-down";
          distance.value = controlPosition.value;
          setTimeout(() => {
            isEnd.value = false;
            lockEvent("remove");
          }, toNumber(props2.animationDuration));
        }
        eventTargetScroller = null;
      });
    }
    function setScroller() {
      scroller = props2.target ? getTarget(props2.target, "PullRefresh") : getParentScroller(freshNode.value);
    }
    function reset() {
      setTimeout(() => {
        refreshStatus.value = "default";
        iconName.value = "arrow-down";
        isEnd.value = false;
      }, toNumber(props2.animationDuration));
    }
    return {
      ICON_TRANSITION,
      refreshStatus,
      freshNode,
      controlNode,
      iconName,
      controlStyle,
      isSuccess,
      n: n$p,
      classes: classes$k,
      handleTouchstart,
      handleTouchmove,
      handleTouchend
    };
  }
});
__sfc__$t.render = __render__$s;
var stdin_default$3Y = __sfc__$t;
withInstall(stdin_default$3Y);
withPropsDefaultsSetter(stdin_default$3Y, props$m);
const _PullRefreshComponent = stdin_default$3Y;
var stdin_default$3X = stdin_default$3Y;
const props$l = {
  modelValue: {
    type: [String, Number, Boolean, Object, Array],
    default: false
  },
  checkedValue: {
    type: [String, Number, Boolean, Object, Array],
    default: true
  },
  uncheckedValue: {
    type: [String, Number, Boolean, Object, Array],
    default: false
  },
  disabled: Boolean,
  readonly: Boolean,
  checkedColor: String,
  uncheckedColor: String,
  iconSize: [String, Number],
  ripple: {
    type: Boolean,
    default: true
  },
  validateTrigger: {
    type: Array,
    default: () => ["onChange"]
  },
  rules: [Array, Function, Object],
  onClick: defineListenerProp(),
  onChange: defineListenerProp(),
  "onUpdate:modelValue": defineListenerProp()
};
const RADIO_GROUP_BIND_RADIO_KEY = Symbol("RADIO_GROUP_BIND_RADIO_KEY");
function useRadios() {
  const { bindChildren, childProviders, length } = useChildren(
    RADIO_GROUP_BIND_RADIO_KEY
  );
  return {
    length,
    radios: childProviders,
    bindRadios: bindChildren
  };
}
function useRadioGroup() {
  const { bindParent, parentProvider, index } = useParent(RADIO_GROUP_BIND_RADIO_KEY);
  return {
    index,
    radioGroup: parentProvider,
    bindRadioGroup: bindParent
  };
}
const { name: name$l, n: n$o, classes: classes$j } = createNamespace("radio");
const _hoisted_1$c = ["tabindex"];
function __render__$r(_ctx, _cache) {
  const _component_var_icon = vue.resolveComponent("var-icon");
  const _component_var_hover_overlay = vue.resolveComponent("var-hover-overlay");
  const _component_var_form_details = vue.resolveComponent("var-form-details");
  const _directive_ripple = vue.resolveDirective("ripple");
  const _directive_hover = vue.resolveDirective("hover");
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.n("wrap"))
    },
    [
      vue.createElementVNode(
        "div",
        vue.mergeProps({
          class: _ctx.n()
        }, _ctx.$attrs, {
          onClick: _cache[3] || (_cache[3] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
        }),
        [
          vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", {
            ref: "action",
            class: vue.normalizeClass(
              _ctx.classes(
                _ctx.n("action"),
                [_ctx.checked, _ctx.n("--checked"), _ctx.n("--unchecked")],
                [_ctx.errorMessage || _ctx.radioGroupErrorMessage, _ctx.n("--error")],
                [_ctx.formDisabled || _ctx.disabled, _ctx.n("--disabled")]
              )
            ),
            tabindex: _ctx.formDisabled || _ctx.disabled ? void 0 : "0",
            style: vue.normalizeStyle({ color: _ctx.checked ? _ctx.checkedColor : _ctx.uncheckedColor }),
            onFocus: _cache[0] || (_cache[0] = ($event) => _ctx.isFocusing = true),
            onBlur: _cache[1] || (_cache[1] = ($event) => _ctx.isFocusing = false)
          }, [
            _ctx.checked ? vue.renderSlot(_ctx.$slots, "checked-icon", { key: 0 }, () => [
              vue.createVNode(_component_var_icon, {
                class: vue.normalizeClass(_ctx.n("icon")),
                "var-radio-cover": "",
                name: "radio-marked",
                size: _ctx.iconSize
              }, null, 8, ["class", "size"])
            ]) : vue.renderSlot(_ctx.$slots, "unchecked-icon", { key: 1 }, () => [
              vue.createVNode(_component_var_icon, {
                class: vue.normalizeClass(_ctx.n("icon")),
                "var-radio-cover": "",
                name: "radio-blank",
                size: _ctx.iconSize
              }, null, 8, ["class", "size"])
            ]),
            vue.createVNode(_component_var_hover_overlay, {
              hovering: !_ctx.disabled && !_ctx.formDisabled && _ctx.hovering,
              focusing: !_ctx.disabled && !_ctx.formDisabled && _ctx.isFocusing
            }, null, 8, ["hovering", "focusing"])
          ], 46, _hoisted_1$c)), [
            [_directive_ripple, { disabled: _ctx.formReadonly || _ctx.readonly || _ctx.formDisabled || _ctx.disabled || !_ctx.ripple }],
            [_directive_hover, _ctx.handleHovering, "desktop"]
          ]),
          _ctx.$slots.default ? (vue.openBlock(), vue.createElementBlock(
            "div",
            {
              key: 0,
              class: vue.normalizeClass(
                _ctx.classes(
                  _ctx.n("text"),
                  [_ctx.errorMessage || _ctx.radioGroupErrorMessage, _ctx.n("--error")],
                  [_ctx.formDisabled || _ctx.disabled, _ctx.n("--disabled")]
                )
              ),
              onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleTextClick && _ctx.handleTextClick(...args))
            },
            [
              vue.renderSlot(_ctx.$slots, "default", { checked: _ctx.checked })
            ],
            2
            /* CLASS */
          )) : vue.createCommentVNode("v-if", true)
        ],
        16
        /* FULL_PROPS */
      ),
      vue.createVNode(_component_var_form_details, { "error-message": _ctx.errorMessage }, null, 8, ["error-message"])
    ],
    2
    /* CLASS */
  );
}
const __sfc__$s = vue.defineComponent({
  name: name$l,
  directives: { Ripple: stdin_default$63, Hover: stdin_default$62 },
  components: {
    VarIcon: stdin_default$5_,
    VarFormDetails: stdin_default$5R,
    VarHoverOverlay: stdin_default$60
  },
  inheritAttrs: false,
  props: props$l,
  setup(props2) {
    const action = vue.ref();
    const isFocusing = vue.ref(false);
    const value = useVModel(props2, "modelValue");
    const checked = vue.computed(() => value.value === props2.checkedValue);
    const { radioGroup, bindRadioGroup } = useRadioGroup();
    const { hovering, handleHovering } = useHoverOverlay();
    const { form, bindForm } = useForm();
    const {
      errorMessage,
      validateWithTrigger: vt,
      validate: v,
      // expose
      resetValidation
    } = useValidation();
    const radioProvider = {
      sync,
      validate,
      resetValidation,
      reset,
      isFocusing: vue.computed(() => isFocusing.value),
      // keyboard arrow move
      move() {
        action.value.focus();
        action.value.click();
      },
      moveable() {
        return !(form == null ? void 0 : form.disabled.value) && !props2.disabled && !(form == null ? void 0 : form.readonly.value) && !props2.readonly;
      }
    };
    call(bindRadioGroup, radioProvider);
    call(bindForm, radioProvider);
    useEventListener(() => window, "keydown", handleKeydown);
    useEventListener(() => window, "keyup", handleKeyup);
    function handleKeydown(event) {
      if (!isFocusing.value) {
        return;
      }
      const { key: key3 } = event;
      if (key3 === "Enter" || key3 === " ") {
        preventDefault(event);
      }
      if (key3 === "Enter") {
        action.value.click();
      }
    }
    function handleKeyup(event) {
      if (!isFocusing.value) {
        return;
      }
      if (event.key === " ") {
        preventDefault(event);
        action.value.click();
      }
    }
    function validateWithTrigger(trigger) {
      vue.nextTick(() => {
        const { validateTrigger, rules, modelValue } = props2;
        vt(validateTrigger, trigger, rules, modelValue);
      });
    }
    function change(changedValue) {
      const { checkedValue, onChange } = props2;
      if (radioGroup && value.value === checkedValue) {
        return;
      }
      value.value = changedValue;
      call(onChange, value.value);
      radioGroup == null ? void 0 : radioGroup.onToggle(checkedValue);
      validateWithTrigger("onChange");
    }
    function handleClick(e) {
      const { disabled, readonly, uncheckedValue, checkedValue, onClick } = props2;
      if ((form == null ? void 0 : form.disabled.value) || disabled) {
        return;
      }
      call(onClick, e);
      if ((form == null ? void 0 : form.readonly.value) || readonly) {
        return;
      }
      change(checked.value ? uncheckedValue : checkedValue);
    }
    function handleTextClick() {
      action.value.focus();
    }
    function sync(v2) {
      const { checkedValue, uncheckedValue } = props2;
      value.value = v2 === checkedValue ? checkedValue : uncheckedValue;
    }
    function reset() {
      value.value = props2.uncheckedValue;
      resetValidation();
    }
    function validate() {
      return v(props2.rules, props2.modelValue);
    }
    function toggle(changedValue) {
      const { uncheckedValue, checkedValue } = props2;
      const shouldReverse = ![uncheckedValue, checkedValue].includes(changedValue);
      if (shouldReverse) {
        changedValue = checked.value ? uncheckedValue : checkedValue;
      }
      change(changedValue);
    }
    return {
      action,
      isFocusing,
      checked,
      errorMessage,
      radioGroupErrorMessage: radioGroup == null ? void 0 : radioGroup.errorMessage,
      formDisabled: form == null ? void 0 : form.disabled,
      formReadonly: form == null ? void 0 : form.readonly,
      hovering,
      handleHovering,
      n: n$o,
      classes: classes$j,
      handleClick,
      handleTextClick,
      toggle,
      reset,
      validate,
      resetValidation
    };
  }
});
__sfc__$s.render = __render__$r;
var stdin_default$3W = __sfc__$s;
withInstall(stdin_default$3W);
withPropsDefaultsSetter(stdin_default$3W, props$l);
const _RadioComponent = stdin_default$3W;
var stdin_default$3V = stdin_default$3W;
const props$k = {
  modelValue: {
    type: [String, Number, Boolean, Object, Array],
    default: void 0
  },
  direction: {
    type: String,
    default: "horizontal"
  },
  options: {
    type: Array,
    default: () => []
  },
  labelKey: {
    type: String,
    default: "label"
  },
  valueKey: {
    type: String,
    default: "value"
  },
  validateTrigger: {
    type: Array,
    default: () => ["onChange"]
  },
  rules: [Array, Function, Object],
  onChange: defineListenerProp(),
  "onUpdate:modelValue": defineListenerProp()
};
const { name: name$k, n: n$n, classes: classes$i } = createNamespace("radio-group");
function __render__$q(_ctx, _cache) {
  const _component_maybe_v_node = vue.resolveComponent("maybe-v-node");
  const _component_var_radio = vue.resolveComponent("var-radio");
  const _component_var_form_details = vue.resolveComponent("var-form-details");
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.n("wrap"))
    },
    [
      vue.createElementVNode(
        "div",
        {
          class: vue.normalizeClass(_ctx.classes(_ctx.n(), _ctx.n(`--${_ctx.direction}`)))
        },
        [
          _ctx.options.length ? (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            { key: 0 },
            vue.renderList(_ctx.options, (option) => {
              return vue.openBlock(), vue.createBlock(_component_var_radio, {
                key: option[_ctx.valueKey],
                "checked-value": option[_ctx.valueKey],
                disabled: option.disabled
              }, {
                default: vue.withCtx(({ checked }) => [
                  vue.createVNode(_component_maybe_v_node, {
                    is: _ctx.isFunction(option[_ctx.labelKey]) ? option[_ctx.labelKey](option, checked) : option[_ctx.labelKey]
                  }, null, 8, ["is"])
                ]),
                _: 2
                /* DYNAMIC */
              }, 1032, ["checked-value", "disabled"]);
            }),
            128
            /* KEYED_FRAGMENT */
          )) : vue.createCommentVNode("v-if", true),
          vue.renderSlot(_ctx.$slots, "default")
        ],
        2
        /* CLASS */
      ),
      vue.createVNode(_component_var_form_details, { "error-message": _ctx.errorMessage }, null, 8, ["error-message"])
    ],
    2
    /* CLASS */
  );
}
const __sfc__$r = vue.defineComponent({
  name: name$k,
  components: { VarFormDetails: stdin_default$5R, VarRadio: stdin_default$3V, MaybeVNode },
  props: props$k,
  setup(props2) {
    const { length, radios, bindRadios } = useRadios();
    const { bindForm } = useForm();
    const {
      errorMessage,
      validateWithTrigger: vt,
      validate: v,
      // expose
      resetValidation
    } = useValidation();
    const radioGroupErrorMessage = vue.computed(() => errorMessage.value);
    const radioGroupProvider = {
      onToggle,
      validate,
      reset,
      resetValidation,
      errorMessage: radioGroupErrorMessage
    };
    vue.watch(() => props2.modelValue, syncRadios);
    vue.watch(() => length.value, syncRadios);
    call(bindForm, radioGroupProvider);
    bindRadios(radioGroupProvider);
    useEventListener(() => window, "keydown", handleKeydown);
    function handleKeydown(event) {
      const focusingRadioIndex = radios.findIndex(({ isFocusing }) => isFocusing.value);
      if (focusingRadioIndex === -1) {
        return;
      }
      const hasMoveableRadio = radios.some(({ moveable }, index) => index === focusingRadioIndex ? false : moveable());
      if (!hasMoveableRadio) {
        return;
      }
      if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        preventDefault(event);
      }
      if (event.key === "ArrowUp" || event.key === "ArrowLeft") {
        moveRadio(focusingRadioIndex, "prev");
        return;
      }
      if (event.key === "ArrowDown" || event.key === "ArrowRight") {
        moveRadio(focusingRadioIndex, "next");
      }
    }
    function moveRadio(fromIndex, method) {
      const looping = true;
      while (looping) {
        if (method === "prev") {
          fromIndex--;
        } else {
          fromIndex++;
        }
        if (fromIndex < 0) {
          fromIndex = radios.length - 1;
        }
        if (fromIndex > radios.length - 1) {
          fromIndex = 0;
        }
        const radio = radios[fromIndex];
        if (radio.moveable()) {
          radio.move();
          break;
        }
      }
    }
    function validateWithTrigger(trigger) {
      vue.nextTick(() => {
        const { validateTrigger, rules, modelValue } = props2;
        vt(validateTrigger, trigger, rules, modelValue);
      });
    }
    function syncRadios() {
      return radios.forEach(({ sync }) => sync(props2.modelValue));
    }
    function onToggle(changedValue) {
      call(props2["onUpdate:modelValue"], changedValue);
      call(props2.onChange, changedValue);
      validateWithTrigger("onChange");
    }
    function validate() {
      return v(props2.rules, props2.modelValue);
    }
    function reset() {
      call(props2["onUpdate:modelValue"], void 0);
      resetValidation();
    }
    return {
      errorMessage,
      n: n$n,
      classes: classes$i,
      reset,
      validate,
      resetValidation,
      isFunction
    };
  }
});
__sfc__$r.render = __render__$q;
var stdin_default$3U = __sfc__$r;
withInstall(stdin_default$3U);
withPropsDefaultsSetter(stdin_default$3U, props$k);
const _RadioGroupComponent = stdin_default$3U;
var stdin_default$3T = stdin_default$3U;
const props$j = {
  modelValue: {
    type: Number,
    default: 0
  },
  count: {
    type: [String, Number],
    default: 5
  },
  color: String,
  icon: {
    type: String,
    default: "star"
  },
  emptyIcon: {
    type: String,
    default: "star-outline"
  },
  halfIcon: {
    type: String,
    default: "star-half-full"
  },
  namespace: pickProps(props$1j, "namespace"),
  emptyIconNamespace: pickProps(props$1j, "namespace"),
  halfIconNamespace: pickProps(props$1j, "namespace"),
  emptyColor: String,
  size: [String, Number],
  gap: [String, Number],
  half: Boolean,
  disabled: Boolean,
  disabledColor: String,
  readonly: Boolean,
  ripple: {
    type: Boolean,
    default: true
  },
  clearable: Boolean,
  rules: Array,
  onChange: defineListenerProp(),
  "onUpdate:modelValue": defineListenerProp()
};
const { name: name$j, n: n$m } = createNamespace("rate");
const _hoisted_1$b = ["onClick"];
function __render__$p(_ctx, _cache) {
  const _component_var_icon = vue.resolveComponent("var-icon");
  const _component_var_hover_overlay = vue.resolveComponent("var-hover-overlay");
  const _component_var_form_details = vue.resolveComponent("var-form-details");
  const _directive_ripple = vue.resolveDirective("ripple");
  const _directive_hover = vue.resolveDirective("hover");
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.n("wrap"))
    },
    [
      vue.createElementVNode(
        "div",
        {
          class: vue.normalizeClass(_ctx.n())
        },
        [
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList(_ctx.toNumber(_ctx.count), (value) => {
              return vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", {
                key: value,
                style: vue.normalizeStyle(_ctx.getStyle(value)),
                class: vue.normalizeClass(_ctx.getClass(value)),
                onClick: ($event) => _ctx.handleClick(value, $event)
              }, [
                vue.createVNode(_component_var_icon, {
                  class: vue.normalizeClass(_ctx.n("content-icon")),
                  "var-rate-cover": "",
                  transition: 0,
                  namespace: _ctx.getCurrentState(value).namespace,
                  name: _ctx.getCurrentState(value).name,
                  style: vue.normalizeStyle({ fontSize: _ctx.toSizeUnit(_ctx.size) })
                }, null, 8, ["class", "namespace", "name", "style"]),
                vue.createVNode(_component_var_hover_overlay, {
                  hovering: _ctx.hovering && value === _ctx.currentHoveringValue && !_ctx.disabled && !_ctx.formDisabled
                }, null, 8, ["hovering"])
              ], 14, _hoisted_1$b)), [
                [_directive_ripple, { disabled: _ctx.formReadonly || _ctx.readonly || _ctx.formDisabled || _ctx.disabled || !_ctx.ripple }],
                [_directive_hover, _ctx.createHoverHandler(value), "desktop"]
              ]);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ],
        2
        /* CLASS */
      ),
      vue.createVNode(_component_var_form_details, { "error-message": _ctx.errorMessage }, null, 8, ["error-message"])
    ],
    2
    /* CLASS */
  );
}
const __sfc__$q = vue.defineComponent({
  name: name$j,
  components: {
    VarIcon: stdin_default$5_,
    VarFormDetails: stdin_default$5R,
    VarHoverOverlay: stdin_default$60
  },
  directives: { Ripple: stdin_default$63, Hover: stdin_default$62 },
  props: props$j,
  setup(props2) {
    const currentHoveringValue = vue.ref(-1);
    const { form, bindForm } = useForm();
    const { errorMessage, validateWithTrigger: vt, validate: v, resetValidation } = useValidation();
    const { hovering } = useHoverOverlay();
    let lastScore = toNumber(props2.modelValue);
    const rateProvider = {
      reset,
      validate,
      resetValidation
    };
    call(bindForm, rateProvider);
    function getStyle2(val) {
      const { count, gap } = props2;
      return {
        color: getCurrentState(val).color,
        marginRight: val !== toNumber(count) ? toSizeUnit(gap) : 0
      };
    }
    function getClass(val) {
      const { name: name2, color } = getCurrentState(val);
      return {
        [n$m("content")]: true,
        [n$m("--disabled")]: (form == null ? void 0 : form.disabled.value) || props2.disabled,
        [n$m("--error")]: errorMessage.value,
        [n$m("--primary")]: name2 !== props2.emptyIcon && !color
      };
    }
    function getCurrentState(index) {
      const {
        modelValue,
        disabled,
        disabledColor,
        color,
        half: half2,
        emptyColor,
        icon,
        halfIcon,
        emptyIcon,
        namespace,
        halfIconNamespace,
        emptyIconNamespace
      } = props2;
      let iconColor = color;
      if (disabled || (form == null ? void 0 : form.disabled.value)) {
        iconColor = disabledColor;
      }
      if (index <= modelValue) {
        return { color: iconColor, name: icon, namespace };
      }
      if (half2 && index <= modelValue + 0.5) {
        return { color: iconColor, name: halfIcon, namespace: halfIconNamespace };
      }
      return {
        color: disabled || (form == null ? void 0 : form.disabled.value) ? disabledColor : emptyColor,
        name: emptyIcon,
        namespace: emptyIconNamespace
      };
    }
    function changeValue(score, event) {
      const { half: half2, clearable } = props2;
      const { offsetWidth } = event.target;
      if (half2 && event.offsetX <= Math.floor(offsetWidth / 2)) {
        score -= 0.5;
      }
      if (lastScore === score && clearable) {
        score = 0;
      }
      if (lastScore !== score) {
        call(props2["onUpdate:modelValue"], score);
        call(props2.onChange, score);
      }
      lastScore = score;
    }
    function validate() {
      return v(props2.rules, props2.modelValue);
    }
    function validateWithTrigger() {
      vue.nextTick(() => vt(["onChange"], "onChange", props2.rules, props2.modelValue));
    }
    function handleClick(score, event) {
      const { readonly, disabled } = props2;
      if (readonly || disabled || (form == null ? void 0 : form.disabled.value) || (form == null ? void 0 : form.readonly.value)) {
        return;
      }
      changeValue(score, event);
      validateWithTrigger();
    }
    function createHoverHandler(value) {
      return (isHover) => {
        currentHoveringValue.value = value;
        hovering.value = isHover;
      };
    }
    function reset() {
      call(props2["onUpdate:modelValue"], 0);
      resetValidation();
    }
    return {
      errorMessage,
      formDisabled: form == null ? void 0 : form.disabled,
      formReadonly: form == null ? void 0 : form.readonly,
      hovering,
      currentHoveringValue,
      getStyle: getStyle2,
      getClass,
      getCurrentState,
      handleClick,
      createHoverHandler,
      reset,
      validate,
      resetValidation,
      toSizeUnit,
      toNumber,
      n: n$m
    };
  }
});
__sfc__$q.render = __render__$p;
var stdin_default$3S = __sfc__$q;
withInstall(stdin_default$3S);
withPropsDefaultsSetter(stdin_default$3S, props$j);
const _RateComponent = stdin_default$3S;
var stdin_default$3R = stdin_default$3S;
const props$i = {
  imageSize: [String, Number],
  type: {
    type: String,
    default: "success"
  },
  title: String,
  description: String,
  animation: {
    type: Boolean,
    default: true
  }
};
const _hoisted_1$a = { viewBox: "-4 -4 32 32" };
function __render__$o(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock("svg", _hoisted_1$a, _cache[0] || (_cache[0] = [
    vue.createElementVNode(
      "path",
      {
        fill: "currentColor",
        d: "M2,10.96C1.5,10.68 1.35,10.07 1.63,9.59L3.13,7C3.24,6.8 3.41,6.66 3.6,6.58L11.43,2.18C11.59,2.06 11.79,2 12,2C12.21,2 12.41,2.06 12.57,2.18L20.47,6.62C20.66,6.72 20.82,6.88 20.91,7.08L22.36,9.6C22.64,10.08 22.47,10.69 22,10.96L21,11.54V16.5C21,16.88 20.79,17.21 20.47,17.38L12.57,21.82C12.41,21.94 12.21,22 12,22C11.79,22 11.59,21.94 11.43,21.82L3.53,17.38C3.21,17.21 3,16.88 3,16.5V10.96C2.7,11.13 2.32,11.14 2,10.96M12,4.15V4.15L12,10.85V10.85L17.96,7.5L12,4.15M5,15.91L11,19.29V12.58L5,9.21V15.91M19,15.91V12.69L14,15.59C13.67,15.77 13.3,15.76 13,15.6V19.29L19,15.91M13.85,13.36L20.13,9.73L19.55,8.72L13.27,12.35L13.85,13.36Z"
      },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
const __sfc__$p = vue.defineComponent({});
__sfc__$p.render = __render__$o;
var stdin_default$3Q = __sfc__$p;
const _hoisted_1$9 = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "2 2 20 20"
};
function __render__$n(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock("svg", _hoisted_1$9, _cache[0] || (_cache[0] = [
    vue.createElementVNode(
      "path",
      { d: "M19,3V5H19V19M17,8.4L13.4,12L17,15.6L15.6,17L12,13.4L8.4,17L7,15.6L10.6,12L7,8.4L8.4,7L12,10.6L15.6,7L17,8.4Z" },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
const __sfc__$o = vue.defineComponent({});
__sfc__$o.render = __render__$n;
var stdin_default$3P = __sfc__$o;
const _hoisted_1$8 = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "2 3.6 20 20"
};
function __render__$m(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock("svg", _hoisted_1$8, _cache[0] || (_cache[0] = [
    vue.createElementVNode(
      "path",
      { d: "M11,9H13V7H11M11,20H13V11H11V20Z" },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
const __sfc__$n = vue.defineComponent({});
__sfc__$n.render = __render__$m;
var stdin_default$3O = __sfc__$n;
const _hoisted_1$7 = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "-3 -3 30 30"
};
function __render__$l(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock("svg", _hoisted_1$7, _cache[0] || (_cache[0] = [
    vue.createElementVNode(
      "path",
      { d: "M10,19H13V22H10V19M12,2C17.35,2.22 19.68,7.62 16.5,11.67C15.67,12.67 14.33,13.33 13.67,14.17C13,15 13,16 13,17H10C10,15.33 10,13.92 10.67,12.92C11.33,11.92 12.67,11.33 13.5,10.67C15.92,8.43 15.32,5.26 12,5A3,3 0 0,0 9,8H6A6,6 0 0,1 12,2Z" },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
const __sfc__$m = vue.defineComponent({});
__sfc__$m.render = __render__$l;
var stdin_default$3N = __sfc__$m;
const { n: n$l, classes: classes$h } = createNamespace("result");
function __render__$k(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock(
    vue.Fragment,
    null,
    [
      vue.createElementVNode(
        "span",
        {
          class: vue.normalizeClass(_ctx.n("success-cover-left"))
        },
        null,
        2
        /* CLASS */
      ),
      vue.createElementVNode(
        "span",
        {
          class: vue.normalizeClass(_ctx.classes(_ctx.n("success-line"), _ctx.n("success-line-tip"))),
          style: vue.normalizeStyle({
            animationDuration: _ctx.animation ? "760ms" : "0ms",
            borderRadius: `calc(${_ctx.borderSize} * 0.625)`
          })
        },
        null,
        6
        /* CLASS, STYLE */
      ),
      vue.createElementVNode(
        "span",
        {
          class: vue.normalizeClass(_ctx.classes(_ctx.n("success-line"), _ctx.n("success-line-long"))),
          style: vue.normalizeStyle({
            animationDuration: _ctx.animation ? "770ms" : "0ms",
            borderRadius: `calc(${_ctx.borderSize} * 0.625)`
          })
        },
        null,
        6
        /* CLASS, STYLE */
      ),
      vue.createElementVNode(
        "span",
        {
          ref: "circle",
          class: vue.normalizeClass(_ctx.n("success-circle")),
          style: vue.normalizeStyle({ left: `-${_ctx.borderSize}`, top: `-${_ctx.borderSize}`, borderWidth: _ctx.borderSize })
        },
        null,
        6
        /* CLASS, STYLE */
      ),
      vue.createElementVNode(
        "span",
        {
          class: vue.normalizeClass(_ctx.n("success-line-fix"))
        },
        null,
        2
        /* CLASS */
      ),
      vue.createElementVNode(
        "span",
        {
          class: vue.normalizeClass(_ctx.n("success-cover-right")),
          style: vue.normalizeStyle({
            animationDuration: _ctx.animation ? "4250ms" : "0ms"
          })
        },
        null,
        6
        /* CLASS, STYLE */
      )
    ],
    64
    /* STABLE_FRAGMENT */
  );
}
const __sfc__$l = vue.defineComponent({
  props: {
    animation: {
      type: Boolean
    },
    borderSize: {
      type: String
    }
  },
  setup() {
    return {
      n: n$l,
      classes: classes$h
    };
  }
});
__sfc__$l.render = __render__$k;
var stdin_default$3M = __sfc__$l;
const _hoisted_1$6 = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "-6 -4 35 35"
};
function __render__$j(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock("svg", _hoisted_1$6, _cache[0] || (_cache[0] = [
    vue.createElementVNode(
      "path",
      { d: "M10,21H14A2,2 0 0,1 12,23A2,2 0 0,1 10,21M21,19V20H3V19L5,17V11C5,7.9 7.03,5.17 10,4.29C10,4.19 10,4.1 10,4A2,2 0 0,1 12,2A2,2 0 0,1 14,4C14,4.1 14,4.19 14,4.29C16.97,5.17 19,7.9 19,11V17L21,19M17,11A5,5 0 0,0 12,6A5,5 0 0,0 7,11V18H17V11M19.75,3.19L18.33,4.61M1,11" },
      null,
      -1
      /* HOISTED */
    )
  ]));
}
const __sfc__$k = vue.defineComponent({});
__sfc__$k.render = __render__$j;
var stdin_default$3L = __sfc__$k;
const { name: name$i, n: n$k, classes: classes$g } = createNamespace("result");
function __render__$i(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.classes(_ctx.n(), _ctx.n("$--box")))
    },
    [
      vue.renderSlot(_ctx.$slots, "image", {}, () => [
        _ctx.type ? (vue.openBlock(), vue.createElementBlock(
          "div",
          {
            key: 0,
            class: vue.normalizeClass(_ctx.n("image-container"))
          },
          [
            vue.createElementVNode(
              "div",
              {
                class: vue.normalizeClass(_ctx.classes(_ctx.n("image"), _ctx.n(_ctx.type))),
                style: vue.normalizeStyle({
                  width: _ctx.circleSize,
                  height: _ctx.circleSize,
                  borderWidth: _ctx.borderSize
                })
              },
              [
                (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.type), {
                  "border-size": _ctx.borderSize,
                  animation: _ctx.animation
                }, null, 8, ["border-size", "animation"]))
              ],
              6
              /* CLASS, STYLE */
            )
          ],
          2
          /* CLASS */
        )) : vue.createCommentVNode("v-if", true)
      ]),
      vue.renderSlot(_ctx.$slots, "title", {}, () => [
        _ctx.title ? (vue.openBlock(), vue.createElementBlock(
          "div",
          {
            key: 0,
            class: vue.normalizeClass(_ctx.n("title"))
          },
          vue.toDisplayString(_ctx.title),
          3
          /* TEXT, CLASS */
        )) : vue.createCommentVNode("v-if", true)
      ]),
      vue.renderSlot(_ctx.$slots, "description", {}, () => [
        _ctx.description ? (vue.openBlock(), vue.createElementBlock(
          "div",
          {
            key: 0,
            class: vue.normalizeClass(_ctx.n("description"))
          },
          vue.toDisplayString(_ctx.description),
          3
          /* TEXT, CLASS */
        )) : vue.createCommentVNode("v-if", true)
      ]),
      _ctx.$slots.footer ? (vue.openBlock(), vue.createElementBlock(
        "div",
        {
          key: 0,
          class: vue.normalizeClass(_ctx.n("footer"))
        },
        [
          vue.renderSlot(_ctx.$slots, "footer")
        ],
        2
        /* CLASS */
      )) : vue.createCommentVNode("v-if", true)
    ],
    2
    /* CLASS */
  );
}
const __sfc__$j = vue.defineComponent({
  name: name$i,
  components: {
    Info: stdin_default$3O,
    Success: stdin_default$3M,
    Warning: stdin_default$3L,
    Error: stdin_default$3P,
    Question: stdin_default$3N,
    Empty: stdin_default$3Q
  },
  props: props$i,
  setup(props2) {
    const circleSize = vue.computed(
      () => `calc(${props2.imageSize ? toSizeUnit(props2.imageSize) : "var(--result-image-size)"} * 0.9)`
    );
    const borderSize = vue.computed(
      () => `calc(${props2.imageSize ? toSizeUnit(props2.imageSize) : "var(--result-image-size)"} * 0.05)`
    );
    return {
      circleSize,
      borderSize,
      n: n$k,
      classes: classes$g
    };
  }
});
__sfc__$j.render = __render__$i;
var stdin_default$3K = __sfc__$j;
withInstall(stdin_default$3K);
withPropsDefaultsSetter(stdin_default$3K, props$i);
const _ResultComponent = stdin_default$3K;
var stdin_default$3J = stdin_default$3K;
const props$h = {
  gutter: {
    type: [String, Number, Array],
    default: 0
  },
  justify: {
    type: String,
    default: "flex-start"
  },
  align: {
    type: String,
    default: "flex-start"
  },
  onClick: defineListenerProp()
};
const { name: name$h, n: n$j, classes: classes$f } = createNamespace("row");
function __render__$h(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.classes(_ctx.n(), _ctx.n("$--box"))),
      style: vue.normalizeStyle({
        justifyContent: _ctx.padStartFlex(_ctx.justify),
        alignItems: _ctx.padStartFlex(_ctx.align),
        margin: `${-_ctx.average[0]}px ${-_ctx.average[1]}px`
      }),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    },
    [
      vue.renderSlot(_ctx.$slots, "default")
    ],
    6
    /* CLASS, STYLE */
  );
}
const __sfc__$i = vue.defineComponent({
  name: name$h,
  props: props$h,
  setup(props2) {
    const average = vue.computed(
      () => isArray(props2.gutter) ? props2.gutter.map((numeric) => toPxNum(numeric) / 2) : [0, toPxNum(props2.gutter) / 2]
    );
    const { bindCols } = useCols();
    bindCols({ average });
    function handleClick(e) {
      call(props2.onClick, e);
    }
    return {
      average,
      n: n$j,
      classes: classes$f,
      handleClick,
      padStartFlex
    };
  }
});
__sfc__$i.render = __render__$h;
var stdin_default$3I = __sfc__$i;
withInstall(stdin_default$3I);
withPropsDefaultsSetter(stdin_default$3I, props$h);
const _RowComponent = stdin_default$3I;
var stdin_default$3H = stdin_default$3I;
var __defProp$6 = Object.defineProperty;
var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$6 = (obj, key3, value) => key3 in obj ? __defProp$6(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$6 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$6.call(b, prop))
      __defNormalProp$6(a, prop, b[prop]);
  if (__getOwnPropSymbols$6)
    for (var prop of __getOwnPropSymbols$6(b)) {
      if (__propIsEnum$6.call(b, prop))
        __defNormalProp$6(a, prop, b[prop]);
    }
  return a;
};
const props$g = __spreadValues$6({
  modelValue: {
    type: [String, Number, Boolean, Array],
    default: void 0
  },
  options: {
    type: Array,
    default: () => []
  },
  labelKey: {
    type: String,
    default: "label"
  },
  valueKey: {
    type: String,
    default: "value"
  },
  multiple: Boolean,
  offsetY: {
    type: [String, Number],
    default: 0
  },
  chip: Boolean,
  readonly: Boolean,
  separator: {
    type: String,
    default: ","
  },
  textAlign: {
    type: String,
    default: "left"
  },
  validateTrigger: {
    type: Array,
    default: () => ["onChange", "onClear", "onClose"]
  },
  rules: [Array, Function, Object],
  onFocus: defineListenerProp(),
  onBlur: defineListenerProp(),
  onClose: defineListenerProp(),
  onChange: defineListenerProp(),
  onClear: defineListenerProp(),
  "onUpdate:modelValue": defineListenerProp()
}, pickProps(props$1e, [
  "size",
  "variant",
  "placeholder",
  "line",
  "hint",
  "textColor",
  "focusColor",
  "blurColor",
  "disabled",
  "clearable",
  "onClick"
]));
const { name: name$g, n: n$i, classes: classes$e } = createNamespace("select");
const _hoisted_1$5 = ["tabindex"];
function __render__$g(_ctx, _cache) {
  const _component_maybe_v_node = vue.resolveComponent("maybe-v-node");
  const _component_var_chip = vue.resolveComponent("var-chip");
  const _component_var_icon = vue.resolveComponent("var-icon");
  const _component_var_field_decorator = vue.resolveComponent("var-field-decorator");
  const _component_var_option = vue.resolveComponent("var-option");
  const _component_var_menu = vue.resolveComponent("var-menu");
  const _component_var_form_details = vue.resolveComponent("var-form-details");
  return vue.openBlock(), vue.createElementBlock("div", {
    ref: "root",
    class: vue.normalizeClass(_ctx.n()),
    tabindex: _ctx.disabled || _ctx.formDisabled ? void 0 : "0",
    onFocus: _cache[3] || (_cache[3] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
    onBlur: _cache[4] || (_cache[4] = (...args) => _ctx.handleRootBlur && _ctx.handleRootBlur(...args))
  }, [
    vue.createVNode(_component_var_menu, {
      show: _ctx.showMenu,
      "onUpdate:show": _cache[1] || (_cache[1] = ($event) => _ctx.showMenu = $event),
      "var-select-cover": "",
      "same-width": "",
      "close-on-click-reference": "",
      "close-on-key-escape": false,
      class: vue.normalizeClass(_ctx.n("menu")),
      "popover-class": _ctx.variant === "standard" && _ctx.hint ? _ctx.n("--standard-menu-margin") : void 0,
      "offset-y": _ctx.offsetY,
      disabled: _ctx.formReadonly || _ctx.readonly || _ctx.formDisabled || _ctx.disabled,
      placement: _ctx.placement,
      "default-style": false,
      onClickOutside: _ctx.handleClickOutside
    }, {
      menu: vue.withCtx(() => [
        vue.createElementVNode(
          "div",
          {
            ref: "menuEl",
            class: vue.normalizeClass(_ctx.classes(_ctx.n("scroller"), _ctx.n("$-elevation--3")))
          },
          [
            _ctx.options.length ? (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              { key: 0 },
              vue.renderList(_ctx.options, (option) => {
                return vue.openBlock(), vue.createBlock(_component_var_option, {
                  key: option[_ctx.valueKey],
                  label: option[_ctx.labelKey],
                  value: option[_ctx.valueKey],
                  option,
                  disabled: option.disabled,
                  ripple: option.ripple
                }, null, 8, ["label", "value", "option", "disabled", "ripple"]);
              }),
              128
              /* KEYED_FRAGMENT */
            )) : vue.createCommentVNode("v-if", true),
            vue.renderSlot(_ctx.$slots, "default")
          ],
          2
          /* CLASS */
        )
      ]),
      default: vue.withCtx(() => [
        vue.createVNode(
          _component_var_field_decorator,
          vue.normalizeProps(vue.guardReactiveProps({
            value: _ctx.modelValue,
            size: _ctx.size,
            variant: _ctx.variant,
            placeholder: _ctx.placeholder,
            line: _ctx.line,
            hint: _ctx.hint,
            textColor: _ctx.textColor,
            focusColor: _ctx.focusColor,
            blurColor: _ctx.blurColor,
            isFocusing: _ctx.isFocusing,
            isError: !!_ctx.errorMessage,
            formDisabled: _ctx.formDisabled,
            disabled: _ctx.disabled,
            clearable: _ctx.clearable,
            cursor: _ctx.cursor,
            onClick: _ctx.handleClick,
            onClear: _ctx.handleClear
          })),
          vue.createSlots({
            "clear-icon": vue.withCtx(({ clear: clear2 }) => [
              vue.renderSlot(_ctx.$slots, "clear-icon", { clear: clear2 })
            ]),
            "append-icon": vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "append-icon")
            ]),
            default: vue.withCtx(() => [
              vue.createElementVNode(
                "div",
                {
                  class: vue.normalizeClass(_ctx.classes(_ctx.n("select"), [_ctx.errorMessage, _ctx.n("--error")], [_ctx.formDisabled || _ctx.disabled, _ctx.n("--disabled")])),
                  style: vue.normalizeStyle({
                    textAlign: _ctx.textAlign,
                    color: _ctx.textColor
                  })
                },
                [
                  vue.createElementVNode(
                    "div",
                    {
                      class: vue.normalizeClass(_ctx.n("label"))
                    },
                    [
                      !_ctx.isEmptyModelValue ? vue.renderSlot(_ctx.$slots, "selected", { key: 0 }, () => [
                        _ctx.multiple ? (vue.openBlock(), vue.createElementBlock(
                          vue.Fragment,
                          { key: 0 },
                          [
                            _ctx.chip ? (vue.openBlock(), vue.createElementBlock(
                              "div",
                              {
                                key: 0,
                                class: vue.normalizeClass(_ctx.n("chips"))
                              },
                              [
                                (vue.openBlock(true), vue.createElementBlock(
                                  vue.Fragment,
                                  null,
                                  vue.renderList(_ctx.labels, (l) => {
                                    return vue.openBlock(), vue.createBlock(_component_var_chip, {
                                      key: l,
                                      class: vue.normalizeClass(_ctx.n("chip")),
                                      "var-select-cover": "",
                                      closeable: "",
                                      size: "small",
                                      type: _ctx.errorMessage ? "danger" : void 0,
                                      onClick: _cache[0] || (_cache[0] = vue.withModifiers(() => {
                                      }, ["stop"])),
                                      onClose: () => _ctx.handleClose(l)
                                    }, {
                                      default: vue.withCtx(() => [
                                        vue.createVNode(_component_maybe_v_node, { is: l }, null, 8, ["is"])
                                      ]),
                                      _: 2
                                      /* DYNAMIC */
                                    }, 1032, ["class", "type", "onClose"]);
                                  }),
                                  128
                                  /* KEYED_FRAGMENT */
                                ))
                              ],
                              2
                              /* CLASS */
                            )) : (vue.openBlock(), vue.createElementBlock(
                              "div",
                              {
                                key: 1,
                                class: vue.normalizeClass(_ctx.n("values"))
                              },
                              [
                                (vue.openBlock(true), vue.createElementBlock(
                                  vue.Fragment,
                                  null,
                                  vue.renderList(_ctx.labels, (l, labelIndex) => {
                                    return vue.openBlock(), vue.createElementBlock(
                                      vue.Fragment,
                                      { key: l },
                                      [
                                        vue.createVNode(_component_maybe_v_node, { is: l }, null, 8, ["is"]),
                                        vue.createTextVNode(
                                          vue.toDisplayString(labelIndex !== _ctx.labels.length - 1 ? _ctx.separator : ""),
                                          1
                                          /* TEXT */
                                        )
                                      ],
                                      64
                                      /* STABLE_FRAGMENT */
                                    );
                                  }),
                                  128
                                  /* KEYED_FRAGMENT */
                                ))
                              ],
                              2
                              /* CLASS */
                            ))
                          ],
                          64
                          /* STABLE_FRAGMENT */
                        )) : (vue.openBlock(), vue.createBlock(_component_maybe_v_node, {
                          key: 1,
                          is: _ctx.label
                        }, null, 8, ["is"]))
                      ]) : vue.createCommentVNode("v-if", true)
                    ],
                    2
                    /* CLASS */
                  ),
                  _ctx.enableCustomPlaceholder ? (vue.openBlock(), vue.createElementBlock(
                    "span",
                    {
                      key: 0,
                      class: vue.normalizeClass(_ctx.classes(_ctx.n("placeholder"), _ctx.n("$--ellipsis"))),
                      style: vue.normalizeStyle({
                        color: _ctx.placeholderColor
                      })
                    },
                    vue.toDisplayString(_ctx.placeholder),
                    7
                    /* TEXT, CLASS, STYLE */
                  )) : vue.createCommentVNode("v-if", true),
                  vue.renderSlot(_ctx.$slots, "arrow-icon", {
                    focus: _ctx.isFocusing,
                    menuOpen: _ctx.showMenu
                  }, () => [
                    vue.createVNode(_component_var_icon, {
                      class: vue.normalizeClass(_ctx.classes(_ctx.n("arrow"), [_ctx.showMenu, _ctx.n("--arrow-rotate")])),
                      "var-select-cover": "",
                      name: "menu-down",
                      transition: 300
                    }, null, 8, ["class"])
                  ])
                ],
                6
                /* CLASS, STYLE */
              )
            ]),
            _: 2
            /* DYNAMIC */
          }, [
            _ctx.$slots["prepend-icon"] ? {
              name: "prepend-icon",
              fn: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "prepend-icon")
              ]),
              key: "0"
            } : void 0
          ]),
          1040
          /* FULL_PROPS, DYNAMIC_SLOTS */
        )
      ]),
      _: 3
      /* FORWARDED */
    }, 8, ["show", "class", "popover-class", "offset-y", "disabled", "placement", "onClickOutside"]),
    vue.createVNode(_component_var_form_details, {
      "error-message": _ctx.errorMessage,
      onClick: _cache[2] || (_cache[2] = vue.withModifiers(() => {
      }, ["stop"]))
    }, null, 8, ["error-message"])
  ], 42, _hoisted_1$5);
}
const __sfc__$h = vue.defineComponent({
  name: name$g,
  components: {
    VarIcon: stdin_default$5_,
    VarMenu: stdin_default$5H,
    VarChip: stdin_default$57,
    VarOption: stdin_default$47,
    VarFieldDecorator: stdin_default$5P,
    VarFormDetails: stdin_default$5R,
    MaybeVNode
  },
  props: props$g,
  setup(props2) {
    const isFocusing = vue.ref(false);
    const showMenu = vue.ref(false);
    const root = vue.ref(null);
    const multiple = vue.computed(() => props2.multiple);
    const focusColor = vue.computed(() => props2.focusColor);
    const isEmptyModelValue = vue.computed(() => isEmpty(props2.modelValue));
    const cursor = vue.computed(() => props2.disabled || props2.readonly ? "" : "pointer");
    const offsetY = vue.ref(0);
    const { bindForm, form } = useForm();
    const { length, options, bindOptions } = useOptions();
    const { label, labels, computeLabel, getSelectedValue } = useSelectController({
      modelValue: () => props2.modelValue,
      multiple: () => props2.multiple,
      optionProviders: () => options,
      optionProvidersLength: () => length.value
    });
    const {
      errorMessage,
      validateWithTrigger: vt,
      validate: v,
      // expose
      resetValidation
    } = useValidation();
    const menuEl = vue.ref(null);
    const placement = vue.computed(() => props2.variant === "outlined" ? "bottom" : "cover-top");
    const placeholderColor = vue.computed(() => {
      const { hint, blurColor, focusColor: focusColor2 } = props2;
      if (hint) {
        return void 0;
      }
      if (errorMessage.value) {
        return "var(--field-decorator-error-color)";
      }
      if (isFocusing.value) {
        return focusColor2 || "var(--field-decorator-focus-color)";
      }
      return blurColor || "var(--field-decorator-placeholder-color, var(--field-decorator-blur-color))";
    });
    const enableCustomPlaceholder = vue.computed(() => !props2.hint && isEmpty(props2.modelValue));
    const selectProvider = {
      multiple,
      focusColor,
      computeLabel,
      onSelect,
      reset,
      validate,
      resetValidation
    };
    vue.watch(
      () => props2.multiple,
      () => {
        assert(
          props2.multiple && isArray(props2.modelValue),
          "Select",
          "The modelValue must be an array when multiple is true"
        );
      }
    );
    bindOptions(selectProvider);
    useEventListener(() => window, "keydown", handleKeydown);
    useEventListener(() => window, "keyup", handleKeyup);
    call(bindForm, selectProvider);
    function handleKeydown(event) {
      const { disabled, readonly } = props2;
      if ((form == null ? void 0 : form.disabled.value) || (form == null ? void 0 : form.readonly.value) || disabled || readonly || !isFocusing.value) {
        return;
      }
      const { key: key3 } = event;
      if (key3 === " " && !showMenu.value) {
        preventDefault(event);
        return;
      }
      if (key3 === "Escape" && showMenu.value) {
        root.value.focus();
        preventDefault(event);
        showMenu.value = false;
        return;
      }
      if (key3 === "Tab" && showMenu.value) {
        root.value.focus();
        preventDefault(event);
        handleBlur();
        return;
      }
      if (key3 === "Enter" && !showMenu.value) {
        preventDefault(event);
        showMenu.value = true;
        return;
      }
      if ((key3 === "ArrowDown" || key3 === "ArrowUp") && showMenu.value) {
        preventDefault(event);
        focusChildElementByKey(root.value, menuEl.value, key3);
      }
    }
    function handleKeyup(event) {
      const { disabled, readonly } = props2;
      if ((form == null ? void 0 : form.disabled.value) || (form == null ? void 0 : form.readonly.value) || disabled || readonly || showMenu.value || !isFocusing.value) {
        return;
      }
      const { key: key3 } = event;
      if (key3 === " " && !showMenu.value) {
        preventDefault(event);
        showMenu.value = true;
      }
    }
    function validateWithTrigger(trigger) {
      vue.nextTick(() => {
        const { validateTrigger, rules, modelValue } = props2;
        vt(validateTrigger, trigger, rules, modelValue);
      });
    }
    function handleFocus() {
      const { disabled, readonly, onFocus } = props2;
      if ((form == null ? void 0 : form.disabled.value) || (form == null ? void 0 : form.readonly.value) || disabled || readonly) {
        return;
      }
      offsetY.value = toPxNum(props2.offsetY);
      focus();
      call(onFocus);
      validateWithTrigger("onFocus");
    }
    function handleBlur() {
      const { disabled, readonly, onBlur } = props2;
      if ((form == null ? void 0 : form.disabled.value) || (form == null ? void 0 : form.readonly.value) || disabled || readonly) {
        return;
      }
      blur();
      call(onBlur);
      validateWithTrigger("onBlur");
    }
    function handleRootBlur() {
      if (showMenu.value) {
        return;
      }
      handleBlur();
    }
    function handleClickOutside() {
      if (!isFocusing.value) {
        return;
      }
      handleBlur();
    }
    function onSelect(option) {
      const { disabled, readonly, multiple: multiple2, onChange } = props2;
      if ((form == null ? void 0 : form.disabled.value) || (form == null ? void 0 : form.readonly.value) || disabled || readonly) {
        return;
      }
      const selectedValue = getSelectedValue(option);
      call(props2["onUpdate:modelValue"], selectedValue);
      call(onChange, selectedValue);
      validateWithTrigger("onChange");
      if (!multiple2) {
        root.value.focus();
        doubleRaf().then(() => {
          showMenu.value = false;
        });
      }
    }
    function handleClear() {
      const { disabled, readonly, multiple: multiple2, clearable, onClear } = props2;
      if ((form == null ? void 0 : form.disabled.value) || (form == null ? void 0 : form.readonly.value) || disabled || readonly || !clearable) {
        return;
      }
      const changedModelValue = multiple2 ? [] : void 0;
      call(props2["onUpdate:modelValue"], changedModelValue);
      call(onClear, changedModelValue);
      validateWithTrigger("onClear");
    }
    function handleClick(e) {
      const { disabled, onClick } = props2;
      if ((form == null ? void 0 : form.disabled.value) || disabled) {
        return;
      }
      call(onClick, e);
      validateWithTrigger("onClick");
    }
    function handleClose(text) {
      const { disabled, readonly, modelValue, onClose } = props2;
      if ((form == null ? void 0 : form.disabled.value) || (form == null ? void 0 : form.readonly.value) || disabled || readonly) {
        return;
      }
      const option = options.find(({ label: label2 }) => label2.value === text);
      const currentModelValue = modelValue.filter(
        (value) => {
          var _a;
          return value !== ((_a = option.value.value) != null ? _a : option.label.value);
        }
      );
      call(props2["onUpdate:modelValue"], currentModelValue);
      call(onClose, currentModelValue);
      validateWithTrigger("onClose");
    }
    function focus() {
      offsetY.value = toPxNum(props2.offsetY);
      isFocusing.value = true;
    }
    function blur() {
      isFocusing.value = false;
      showMenu.value = false;
    }
    function validate() {
      return v(props2.rules, props2.modelValue);
    }
    function reset() {
      call(props2["onUpdate:modelValue"], props2.multiple ? [] : void 0);
      resetValidation();
    }
    return {
      root,
      offsetY,
      isFocusing,
      showMenu,
      errorMessage,
      formDisabled: form == null ? void 0 : form.disabled,
      formReadonly: form == null ? void 0 : form.readonly,
      label,
      labels,
      isEmptyModelValue,
      menuEl,
      placement,
      cursor,
      placeholderColor,
      enableCustomPlaceholder,
      isFunction,
      n: n$i,
      classes: classes$e,
      handleFocus,
      handleBlur,
      handleClickOutside,
      handleClear,
      handleClick,
      handleClose,
      handleRootBlur,
      reset,
      validate,
      resetValidation,
      focus,
      blur
    };
  }
});
__sfc__$h.render = __render__$g;
var stdin_default$3G = __sfc__$h;
withInstall(stdin_default$3G);
withPropsDefaultsSetter(stdin_default$3G, props$g);
const _SelectComponent = stdin_default$3G;
var stdin_default$3F = stdin_default$3G;
const props$f = {
  loading: {
    type: Boolean,
    default: true
  },
  title: Boolean,
  card: Boolean,
  avatar: Boolean,
  fullscreen: Boolean,
  fullscreenZIndex: {
    type: [Number, String],
    default: 100
  },
  titleWidth: [Number, String],
  cardHeight: [Number, String],
  avatarSize: [Number, String],
  rows: {
    type: [Number, String],
    default: 3
  },
  rowsWidth: {
    type: Array,
    default: () => []
  }
};
const { name: name$f, n: n$h, classes: classes$d } = createNamespace("skeleton");
function __render__$f(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.classes(_ctx.n("$--box"), _ctx.n()))
    },
    [
      !_ctx.loading ? (vue.openBlock(), vue.createElementBlock(
        "div",
        {
          key: 0,
          class: vue.normalizeClass(_ctx.n("data"))
        },
        [
          vue.renderSlot(_ctx.$slots, "default")
        ],
        2
        /* CLASS */
      )) : vue.createCommentVNode("v-if", true),
      _ctx.loading && !_ctx.fullscreen ? (vue.openBlock(), vue.createElementBlock(
        "div",
        {
          key: 1,
          class: vue.normalizeClass(_ctx.n("content"))
        },
        [
          _ctx.card ? (vue.openBlock(), vue.createElementBlock(
            "div",
            {
              key: 0,
              class: vue.normalizeClass(_ctx.n("card")),
              style: vue.normalizeStyle({ height: _ctx.toSizeUnit(_ctx.cardHeight) })
            },
            [
              vue.createElementVNode(
                "div",
                {
                  class: vue.normalizeClass(_ctx.n("--animation"))
                },
                null,
                2
                /* CLASS */
              )
            ],
            6
            /* CLASS, STYLE */
          )) : vue.createCommentVNode("v-if", true),
          _ctx.avatar || _ctx.title || _ctx.toNumber(_ctx.rows) > 0 ? (vue.openBlock(), vue.createElementBlock(
            "div",
            {
              key: 1,
              class: vue.normalizeClass(_ctx.n("article"))
            },
            [
              _ctx.avatar ? (vue.openBlock(), vue.createElementBlock(
                "div",
                {
                  key: 0,
                  class: vue.normalizeClass(_ctx.n("avatar")),
                  style: vue.normalizeStyle({
                    width: _ctx.toSizeUnit(_ctx.avatarSize),
                    height: _ctx.toSizeUnit(_ctx.avatarSize)
                  })
                },
                [
                  vue.createElementVNode(
                    "div",
                    {
                      class: vue.normalizeClass(_ctx.n("--animation"))
                    },
                    null,
                    2
                    /* CLASS */
                  )
                ],
                6
                /* CLASS, STYLE */
              )) : vue.createCommentVNode("v-if", true),
              _ctx.title || _ctx.toNumber(_ctx.rows) > 0 ? (vue.openBlock(), vue.createElementBlock(
                "div",
                {
                  key: 1,
                  class: vue.normalizeClass(_ctx.n("section"))
                },
                [
                  _ctx.title ? (vue.openBlock(), vue.createElementBlock(
                    "div",
                    {
                      key: 0,
                      class: vue.normalizeClass(_ctx.n("title")),
                      style: vue.normalizeStyle({ width: _ctx.toSizeUnit(_ctx.titleWidth) })
                    },
                    [
                      vue.createElementVNode(
                        "div",
                        {
                          class: vue.normalizeClass(_ctx.n("--animation"))
                        },
                        null,
                        2
                        /* CLASS */
                      )
                    ],
                    6
                    /* CLASS, STYLE */
                  )) : vue.createCommentVNode("v-if", true),
                  (vue.openBlock(true), vue.createElementBlock(
                    vue.Fragment,
                    null,
                    vue.renderList(_ctx.toNumber(_ctx.rows), (r, index) => {
                      return vue.openBlock(), vue.createElementBlock(
                        "div",
                        {
                          key: r,
                          class: vue.normalizeClass(_ctx.n("row")),
                          style: vue.normalizeStyle({ width: _ctx.toSizeUnit(_ctx.rowsWidth[index]) })
                        },
                        [
                          vue.createElementVNode(
                            "div",
                            {
                              class: vue.normalizeClass(_ctx.n("--animation"))
                            },
                            null,
                            2
                            /* CLASS */
                          )
                        ],
                        6
                        /* CLASS, STYLE */
                      );
                    }),
                    128
                    /* KEYED_FRAGMENT */
                  ))
                ],
                2
                /* CLASS */
              )) : vue.createCommentVNode("v-if", true)
            ],
            2
            /* CLASS */
          )) : vue.createCommentVNode("v-if", true)
        ],
        2
        /* CLASS */
      )) : vue.createCommentVNode("v-if", true),
      _ctx.loading && _ctx.fullscreen ? (vue.openBlock(), vue.createElementBlock(
        "div",
        {
          key: 2,
          class: vue.normalizeClass(_ctx.n("fullscreen")),
          style: vue.normalizeStyle({ zIndex: _ctx.toNumber(_ctx.fullscreenZIndex) })
        },
        [
          vue.createElementVNode(
            "div",
            {
              class: vue.normalizeClass(_ctx.n("--animation"))
            },
            null,
            2
            /* CLASS */
          )
        ],
        6
        /* CLASS, STYLE */
      )) : vue.createCommentVNode("v-if", true)
    ],
    2
    /* CLASS */
  );
}
const __sfc__$g = vue.defineComponent({
  name: name$f,
  props: props$f,
  setup: () => ({
    n: n$h,
    classes: classes$d,
    toSizeUnit,
    toNumber
  })
});
__sfc__$g.render = __render__$f;
var stdin_default$3E = __sfc__$g;
withInstall(stdin_default$3E);
withPropsDefaultsSetter(stdin_default$3E, props$f);
const _SkeletonComponent = stdin_default$3E;
var stdin_default$3D = stdin_default$3E;
var Thumbs = /* @__PURE__ */ ((Thumbs2) => {
  Thumbs2["First"] = "1";
  Thumbs2["Second"] = "2";
  return Thumbs2;
})(Thumbs || {});
const props$e = {
  modelValue: {
    type: [Number, Array],
    default: 0
  },
  step: {
    type: [Number, String],
    default: 1
  },
  range: Boolean,
  labelVisible: {
    type: String,
    default: "normal"
  },
  activeColor: String,
  trackColor: String,
  thumbColor: String,
  labelColor: String,
  labelTextColor: String,
  trackHeight: [String, Number],
  max: {
    type: [String, Number],
    default: 100
  },
  min: {
    type: [String, Number],
    default: 0
  },
  thumbSize: [String, Number],
  disabled: Boolean,
  readonly: Boolean,
  direction: {
    type: String,
    default: "horizontal"
  },
  rules: [Array, Function, Object],
  onChange: defineListenerProp(),
  onStart: defineListenerProp(),
  onEnd: defineListenerProp(),
  "onUpdate:modelValue": defineListenerProp()
};
const { name: name$e, n: n$g, classes: classes$c } = createNamespace("slider");
const _hoisted_1$4 = ["tabindex", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-disabled", "aria-valuetext", "onTouchstart", "onFocusin", "onFocusout"];
function __render__$e(_ctx, _cache) {
  const _component_var_hover_overlay = vue.resolveComponent("var-hover-overlay");
  const _component_var_form_details = vue.resolveComponent("var-form-details");
  const _directive_hover = vue.resolveDirective("hover");
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.classes(_ctx.n(_ctx.direction), _ctx.n("$--box")))
    },
    [
      vue.createElementVNode(
        "div",
        {
          ref: "sliderEl",
          class: vue.normalizeClass(_ctx.classes(_ctx.n(`${_ctx.direction}-block`), [_ctx.isDisabled, _ctx.n("--disabled")], [_ctx.errorMessage, _ctx.n(`${_ctx.direction}--error`)])),
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
        },
        [
          vue.createElementVNode(
            "div",
            {
              class: vue.normalizeClass(_ctx.n(`${_ctx.direction}-track`))
            },
            [
              vue.createElementVNode(
                "div",
                {
                  class: vue.normalizeClass(_ctx.n(`${_ctx.direction}-track-background`)),
                  style: vue.normalizeStyle({
                    background: _ctx.trackColor,
                    height: _ctx.isVertical ? "100%" : _ctx.toSizeUnit(_ctx.trackHeight),
                    width: _ctx.isVertical ? _ctx.toSizeUnit(_ctx.trackHeight) : "100%"
                  })
                },
                null,
                6
                /* CLASS, STYLE */
              ),
              vue.createElementVNode(
                "div",
                {
                  class: vue.normalizeClass(_ctx.n(`${_ctx.direction}-track-fill`)),
                  style: vue.normalizeStyle(_ctx.getFillStyle)
                },
                null,
                6
                /* CLASS, STYLE */
              )
            ],
            2
            /* CLASS */
          ),
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList(_ctx.thumbList, (item) => {
              return vue.openBlock(), vue.createElementBlock("div", {
                key: item.enumValue,
                class: vue.normalizeClass(_ctx.n(`${_ctx.direction}-thumb`)),
                style: vue.normalizeStyle(_ctx.thumbStyle(item)),
                tabindex: _ctx.isDisabled ? void 0 : "0",
                role: "slider",
                "aria-valuemin": _ctx.min,
                "aria-valuemax": _ctx.max,
                "aria-valuenow": item.value,
                "aria-disabled": _ctx.isDisabled,
                "aria-valuetext": `${item.text}`,
                onTouchstart: vue.withModifiers(($event) => _ctx.start($event, item.enumValue), ["stop"]),
                onFocusin: ($event) => _ctx.handleFocus(item),
                onFocusout: ($event) => _ctx.handleBlur(item)
              }, [
                vue.renderSlot(_ctx.$slots, "button", {
                  currentValue: item.text
                }, () => [
                  vue.withDirectives(vue.createElementVNode(
                    "div",
                    {
                      class: vue.normalizeClass(_ctx.n(`${_ctx.direction}-thumb-block`)),
                      style: vue.normalizeStyle({
                        background: _ctx.thumbColor
                      })
                    },
                    null,
                    6
                    /* CLASS, STYLE */
                  ), [
                    [_directive_hover, (value) => _ctx.hover(value, item), "desktop"]
                  ]),
                  vue.createElementVNode(
                    "div",
                    {
                      class: vue.normalizeClass(
                        _ctx.classes(_ctx.n(`${_ctx.direction}-thumb-ripple`), [
                          _ctx.thumbsProps[item.enumValue].active,
                          _ctx.n(`${_ctx.direction}-thumb-ripple--active`)
                        ])
                      ),
                      style: vue.normalizeStyle({
                        background: _ctx.thumbsProps[item.enumValue].active ? _ctx.thumbColor : void 0
                      })
                    },
                    [
                      vue.createVNode(_component_var_hover_overlay, {
                        hovering: !_ctx.isDisabled && item.hovering,
                        focusing: !_ctx.isDisabled && item.focusing
                      }, null, 8, ["hovering", "focusing"])
                    ],
                    6
                    /* CLASS, STYLE */
                  ),
                  vue.createElementVNode(
                    "div",
                    {
                      class: vue.normalizeClass(
                        _ctx.classes(_ctx.n(`${_ctx.direction}-thumb-label`), [_ctx.showLabel(item.enumValue), _ctx.n(`${_ctx.direction}-thumb-label--active`)])
                      ),
                      style: vue.normalizeStyle({
                        background: _ctx.labelColor,
                        color: _ctx.labelTextColor,
                        height: _ctx.toSizeUnit(_ctx.thumbSize),
                        width: _ctx.toSizeUnit(_ctx.thumbSize)
                      })
                    },
                    [
                      vue.createElementVNode(
                        "span",
                        null,
                        vue.toDisplayString(item.text),
                        1
                        /* TEXT */
                      )
                    ],
                    6
                    /* CLASS, STYLE */
                  )
                ])
              ], 46, _hoisted_1$4);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ],
        2
        /* CLASS */
      ),
      vue.createVNode(_component_var_form_details, {
        "error-message": _ctx.errorMessage,
        class: vue.normalizeClass(_ctx.n("form")),
        "var-slider-cover": ""
      }, null, 8, ["error-message", "class"])
    ],
    2
    /* CLASS */
  );
}
const __sfc__$f = vue.defineComponent({
  name: name$e,
  components: {
    VarFormDetails: stdin_default$5R,
    VarHoverOverlay: stdin_default$60
  },
  directives: { Hover: stdin_default$62 },
  props: props$e,
  setup(props2) {
    const maxDistance = vue.ref(0);
    const sliderEl = vue.ref(null);
    const isScroll = vue.ref(false);
    const scope = vue.computed(() => toNumber(props2.max) - toNumber(props2.min));
    const unitWidth = vue.computed(() => maxDistance.value / scope.value * toNumber(props2.step));
    const isDisabled = vue.computed(() => props2.disabled || (form == null ? void 0 : form.disabled.value));
    const isReadonly = vue.computed(() => props2.readonly || (form == null ? void 0 : form.readonly.value));
    const isVertical = vue.computed(() => props2.direction === "vertical");
    const focusingFirst = vue.ref(false);
    const focusingSecond = vue.ref(false);
    const { bindForm, form } = useForm();
    const { errorMessage, validateWithTrigger: vt, validate: v, resetValidation } = useValidation();
    const { hovering: hoveringFirst, handleHovering: handleHoveringFirst } = useHoverOverlay();
    const { hovering: hoveringSecond, handleHovering: handleHoveringSecond } = useHoverOverlay();
    const thumbList = vue.computed(() => {
      const { modelValue, range } = props2;
      let list = [];
      if (range && isArray(modelValue)) {
        list = [
          {
            value: getValue(modelValue[0]),
            enumValue: Thumbs.First,
            text: toPrecision(modelValue[0]),
            hovering: hoveringFirst.value,
            focusing: focusingFirst.value,
            handleHovering: handleHoveringFirst,
            handleFocusing(value) {
              focusingFirst.value = value;
            }
          },
          {
            value: getValue(modelValue[1]),
            enumValue: Thumbs.Second,
            text: toPrecision(modelValue[1]),
            hovering: hoveringSecond.value,
            focusing: focusingSecond.value,
            handleHovering: handleHoveringSecond,
            handleFocusing(value) {
              focusingSecond.value = value;
            }
          }
        ];
      } else if (isNumber(modelValue)) {
        list = [
          {
            value: getValue(modelValue),
            enumValue: Thumbs.First,
            text: toPrecision(modelValue),
            hovering: hoveringFirst.value,
            focusing: focusingFirst.value,
            handleHovering: handleHoveringFirst,
            handleFocusing(value) {
              focusingFirst.value = value;
            }
          }
        ];
      }
      return list;
    });
    const getFillStyle = vue.computed(() => {
      const { activeColor, range, modelValue } = props2;
      const gap = range && isArray(modelValue) ? getValue(Math.min(modelValue[0], modelValue[1])) : 0;
      const fillLength = range && isArray(modelValue) ? getValue(Math.max(modelValue[0], modelValue[1])) - gap : getValue(modelValue);
      return isVertical.value ? {
        left: "0px",
        height: `${fillLength}%`,
        bottom: `${gap}%`,
        background: activeColor
      } : {
        top: "0px",
        width: `${fillLength}%`,
        left: `${gap}%`,
        background: activeColor
      };
    });
    const thumbsProps = vue.reactive({
      [Thumbs.First]: getThumbProps(),
      [Thumbs.Second]: getThumbProps()
    });
    let activeThumb;
    const sliderProvider = {
      reset,
      validate,
      resetValidation
    };
    call(bindForm, sliderProvider);
    vue.watch([() => props2.modelValue, () => props2.step], ([modelValue, step]) => {
      if (!stepValidator() || !valueValidator() || isScroll.value) {
        return;
      }
      setProps(modelValue, toNumber(step));
    });
    vue.watch(maxDistance, () => setProps());
    onSmartMounted(() => {
      if (!stepValidator() || !valueValidator()) {
        return;
      }
      resizeMaxDistance();
    });
    vue.onBeforeUnmount(removeDocumentEvents);
    useEventListener(() => window, "keydown", handleKeydown);
    onWindowResize(resizeMaxDistance);
    function resizeMaxDistance() {
      maxDistance.value = sliderEl.value[isVertical.value ? "offsetHeight" : "offsetWidth"];
    }
    function validate() {
      return v(props2.rules, props2.modelValue);
    }
    function getThumbProps() {
      return {
        startPosition: 0,
        currentOffset: 0,
        active: false,
        percentValue: 0
      };
    }
    function validateWithTrigger() {
      vue.nextTick(() => vt(["onChange"], "onChange", props2.rules, props2.modelValue));
    }
    function getOffset(e) {
      const currentTarget = e.currentTarget;
      if (!currentTarget) {
        return 0;
      }
      if (!isVertical.value) {
        return e.clientX - getLeft(currentTarget);
      }
      return maxDistance.value - (e.clientY - getRect(currentTarget).top);
    }
    function thumbStyle(thumb) {
      const key3 = isVertical.value ? "bottom" : "left";
      return {
        [key3]: `${thumb.value}%`,
        zIndex: thumbsProps[thumb.enumValue].active ? 1 : void 0
      };
    }
    function showLabel(type) {
      if (props2.labelVisible === "always") {
        return true;
      }
      if (props2.labelVisible === "never") {
        return false;
      }
      return thumbsProps[type].active;
    }
    function getValue(value) {
      const { min: min2, max: max2 } = props2;
      if (value < toNumber(min2)) {
        return 0;
      }
      if (value > toNumber(max2)) {
        return 100;
      }
      return (value - toNumber(min2)) / scope.value * 100;
    }
    function toPrecision(value) {
      if (!isNumber(value)) {
        return 0;
      }
      const num = clamp$1(value, toNumber(props2.min), toNumber(props2.max));
      const isInteger = parseInt(`${num}`, 10) === num;
      return isInteger ? num : toNumber(num.toPrecision(5));
    }
    function hover(value, item) {
      if (isDisabled.value) {
        return;
      }
      item.handleHovering(value);
    }
    function emitChange(value) {
      call(props2.onChange, value);
      call(props2["onUpdate:modelValue"], value);
      validateWithTrigger();
    }
    function setPercent(moveDistance, type) {
      let rangeValue = [];
      const { step, range, modelValue, min: min2 } = props2;
      const stepNumber = toNumber(step);
      const roundDistance = Math.round(moveDistance / unitWidth.value);
      const curValue = roundDistance * stepNumber + toNumber(min2);
      const prevValue = thumbsProps[type].percentValue * stepNumber + toNumber(min2);
      thumbsProps[type].percentValue = roundDistance;
      if (range && isArray(modelValue)) {
        rangeValue = type === Thumbs.First ? [curValue, modelValue[1]] : [modelValue[0], curValue];
      }
      if (prevValue !== curValue) {
        const value = range ? rangeValue.map((value2) => toPrecision(value2)) : toPrecision(curValue);
        emitChange(value);
      }
    }
    function getType(offset2) {
      if (!props2.range) {
        return Thumbs.First;
      }
      const thumb1Distance = thumbsProps[Thumbs.First].percentValue * unitWidth.value;
      const thumb2Distance = thumbsProps[Thumbs.Second].percentValue * unitWidth.value;
      const offsetToThumb1 = Math.abs(offset2 - thumb1Distance);
      const offsetToThumb2 = Math.abs(offset2 - thumb2Distance);
      return offsetToThumb1 <= offsetToThumb2 ? Thumbs.First : Thumbs.Second;
    }
    function addDocumentEvents() {
      document.addEventListener("touchmove", move, { passive: false });
      document.addEventListener("touchend", end2);
      document.addEventListener("touchcancel", end2);
    }
    function removeDocumentEvents() {
      document.removeEventListener("touchmove", move);
      document.removeEventListener("touchend", end2);
      document.removeEventListener("touchcancel", end2);
    }
    function start2(event, type) {
      resizeMaxDistance();
      if (!isDisabled.value) {
        thumbsProps[type].active = true;
      }
      activeThumb = type;
      addDocumentEvents();
      if (isDisabled.value || isReadonly.value) {
        return;
      }
      call(props2.onStart);
      isScroll.value = true;
      const { clientX, clientY } = event.touches[0];
      thumbsProps[type].startPosition = isVertical.value ? clientY : clientX;
    }
    function move(event) {
      preventDefault(event);
      if (isDisabled.value || isReadonly.value || !isScroll.value) {
        return;
      }
      const { startPosition, currentOffset } = thumbsProps[activeThumb];
      const { clientX, clientY } = event.touches[0];
      let moveDistance = (isVertical.value ? startPosition - clientY : clientX - startPosition) + currentOffset;
      if (moveDistance <= 0) {
        moveDistance = 0;
      } else if (moveDistance >= maxDistance.value) {
        moveDistance = maxDistance.value;
      }
      setPercent(moveDistance, activeThumb);
    }
    function end2() {
      removeDocumentEvents();
      const { range, modelValue, onEnd, step, min: min2 } = props2;
      if (!isDisabled.value) {
        thumbsProps[activeThumb].active = false;
      }
      if (isDisabled.value || isReadonly.value) {
        return;
      }
      let rangeValue = [];
      thumbsProps[activeThumb].currentOffset = thumbsProps[activeThumb].percentValue * unitWidth.value;
      const curValue = thumbsProps[activeThumb].percentValue * toNumber(step) + toNumber(min2);
      if (range && isArray(modelValue)) {
        rangeValue = activeThumb === Thumbs.First ? [curValue, modelValue[1]] : [modelValue[0], curValue];
      }
      call(onEnd, range ? rangeValue : curValue);
      isScroll.value = false;
    }
    function handleClick(event) {
      if (isDisabled.value || isReadonly.value) {
        return;
      }
      if (event.target.closest(`.${n$g("thumb")}`)) {
        return;
      }
      const offset2 = getOffset(event);
      const type = getType(offset2);
      activeThumb = type;
      setPercent(offset2, type);
      end2();
    }
    function stepValidator() {
      if (toNumber(props2.step) <= 0) {
        warn("Slider", '"step" should be > 0');
        return false;
      }
      return true;
    }
    function valueValidator() {
      const { range, modelValue } = props2;
      if (range && !isArray(modelValue)) {
        error$1("Slider", '"modelValue" should be an Array');
        return false;
      }
      if (!range && isArray(modelValue)) {
        error$1("Slider", '"modelValue" should be a Number');
        return false;
      }
      if (range && isArray(modelValue) && modelValue.length < 2) {
        error$1("Slider", '"modelValue" should have two value');
        return false;
      }
      return true;
    }
    function setProps(modelValue = props2.modelValue, step = toNumber(props2.step)) {
      const getPercent = (value) => {
        const { min: min2, max: max2 } = props2;
        if (value < toNumber(min2)) {
          return 0;
        }
        if (value > toNumber(max2)) {
          return scope.value / step;
        }
        return (value - toNumber(min2)) / step;
      };
      if (props2.range && isArray(modelValue)) {
        thumbsProps[Thumbs.First].percentValue = getPercent(modelValue[0]);
        thumbsProps[Thumbs.First].currentOffset = thumbsProps[Thumbs.First].percentValue * unitWidth.value;
        thumbsProps[Thumbs.Second].percentValue = getPercent(modelValue[1]);
        thumbsProps[Thumbs.Second].currentOffset = thumbsProps[Thumbs.Second].percentValue * unitWidth.value;
      } else if (isNumber(modelValue)) {
        thumbsProps[Thumbs.First].currentOffset = getPercent(modelValue) * unitWidth.value;
      }
    }
    function reset() {
      const resetValue = props2.range ? [0, 0] : 0;
      call(props2["onUpdate:modelValue"], resetValue);
      resetValidation();
    }
    function moveFocusingThumb(offset2, value) {
      const stepValue = toNumber(props2.step);
      if (isArray(value)) {
        const updatedFirstValue = value[0] + (focusingFirst.value ? offset2 * stepValue : 0);
        const updatedSecondValue = value[1] + (focusingSecond.value ? offset2 * stepValue : 0);
        return [updatedFirstValue, updatedSecondValue].map(toPrecision);
      }
      return toPrecision(value + offset2 * stepValue);
    }
    function handleKeydown(event) {
      const keyToOffset = {
        ArrowRight: 1,
        ArrowUp: 1,
        ArrowLeft: -1,
        ArrowDown: -1
      };
      const { key: key3 } = event;
      if (!hasOwn(keyToOffset, key3) || isReadonly.value || isDisabled.value) {
        return;
      }
      if (props2.range && !focusingFirst.value && !focusingSecond.value) {
        return;
      }
      if (!props2.range && !focusingFirst.value) {
        return;
      }
      preventDefault(event);
      const offset2 = keyToOffset[key3];
      const value = moveFocusingThumb(offset2, props2.modelValue);
      emitChange(value);
    }
    function handleFocus(item) {
      if (isDisabled.value) {
        return;
      }
      item.handleFocusing(true);
    }
    function handleBlur(item) {
      item.handleFocusing(false);
    }
    return {
      sliderEl,
      getFillStyle,
      isDisabled,
      isVertical,
      errorMessage,
      thumbsProps,
      thumbList,
      handleFocus,
      handleBlur,
      n: n$g,
      classes: classes$c,
      thumbStyle,
      hover,
      toSizeUnit,
      toNumber,
      showLabel,
      start: start2,
      move,
      end: end2,
      handleClick
    };
  }
});
__sfc__$f.render = __render__$e;
var stdin_default$3C = __sfc__$f;
withInstall(stdin_default$3C);
withPropsDefaultsSetter(stdin_default$3C, props$e);
const _SliderComponent = stdin_default$3C;
var stdin_default$3B = stdin_default$3C;
var __defProp$5 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$5 = (obj, key3, value) => key3 in obj ? __defProp$5(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$5 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$5.call(b, prop))
      __defNormalProp$5(a, prop, b[prop]);
  if (__getOwnPropSymbols$5)
    for (var prop of __getOwnPropSymbols$5(b)) {
      if (__propIsEnum$5.call(b, prop))
        __defNormalProp$5(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
const props$d = {
  type: String,
  position: {
    type: String,
    default: "top"
  },
  content: [String, Function, Object],
  contentClass: String,
  duration: {
    type: Number,
    default: 3e3
  },
  elevation: {
    type: [Boolean, String, Number],
    default: true
  },
  vertical: Boolean,
  loadingType: pickProps(props$15, "type"),
  loadingSize: pickProps(props$15, "size"),
  loadingRadius: pickProps(props$15, "radius"),
  loadingColor: __spreadProps$1(__spreadValues$5({}, pickProps(props$15, "color")), {
    default: "currentColor"
  }),
  lockScroll: Boolean,
  show: Boolean,
  teleport: {
    type: [String, Object, Boolean],
    default: "body"
  },
  forbidClick: Boolean,
  onOpen: defineListenerProp(),
  onOpened: defineListenerProp(),
  onClose: defineListenerProp(),
  onClosed: defineListenerProp(),
  "onUpdate:show": defineListenerProp(),
  _update: String
};
const { n: n$f, classes: classes$b } = createNamespace("snackbar");
const ICON_TYPE_DICT = {
  success: "checkbox-marked-circle",
  warning: "warning",
  info: "information",
  error: "error",
  loading: ""
};
function __render__$d(_ctx, _cache) {
  const _component_var_icon = vue.resolveComponent("var-icon");
  const _component_var_loading = vue.resolveComponent("var-loading");
  return vue.withDirectives((vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.n()),
      style: vue.normalizeStyle({ pointerEvents: _ctx.isForbidClick ? "auto" : "none", zIndex: _ctx.zIndex })
    },
    [
      vue.createElementVNode(
        "div",
        {
          class: vue.normalizeClass(
            _ctx.classes(
              _ctx.n("wrapper"),
              _ctx.n(`wrapper-${_ctx.position}`),
              _ctx.formatElevation(_ctx.elevation, 4),
              [_ctx.vertical, _ctx.n("vertical")],
              [_ctx.type && _ctx.SNACKBAR_TYPE.includes(_ctx.type), _ctx.n(`wrapper-${_ctx.type}`)]
            )
          ),
          style: vue.normalizeStyle({ zIndex: _ctx.zIndex })
        },
        [
          vue.createElementVNode(
            "div",
            {
              class: vue.normalizeClass([_ctx.n("content"), _ctx.contentClass])
            },
            [
              vue.renderSlot(_ctx.$slots, "default", {}, () => [
                vue.createTextVNode(
                  vue.toDisplayString(_ctx.content),
                  1
                  /* TEXT */
                )
              ])
            ],
            2
            /* CLASS */
          ),
          _ctx.iconName || _ctx.type === "loading" || _ctx.$slots.icon ? (vue.openBlock(), vue.createElementBlock(
            "div",
            {
              key: 0,
              class: vue.normalizeClass(_ctx.n("icon"))
            },
            [
              _ctx.iconName ? (vue.openBlock(), vue.createBlock(_component_var_icon, {
                key: 0,
                name: _ctx.iconName
              }, null, 8, ["name"])) : vue.createCommentVNode("v-if", true),
              _ctx.type === "loading" ? (vue.openBlock(), vue.createBlock(_component_var_loading, {
                key: 1,
                type: _ctx.loadingType,
                size: _ctx.loadingSize,
                color: _ctx.loadingColor,
                radius: _ctx.loadingRadius
              }, null, 8, ["type", "size", "color", "radius"])) : vue.createCommentVNode("v-if", true),
              vue.renderSlot(_ctx.$slots, "icon")
            ],
            2
            /* CLASS */
          )) : vue.createCommentVNode("v-if", true),
          _ctx.$slots.action ? (vue.openBlock(), vue.createElementBlock(
            "div",
            {
              key: 1,
              class: vue.normalizeClass(_ctx.n("action"))
            },
            [
              vue.renderSlot(_ctx.$slots, "action")
            ],
            2
            /* CLASS */
          )) : vue.createCommentVNode("v-if", true)
        ],
        6
        /* CLASS, STYLE */
      )
    ],
    6
    /* CLASS, STYLE */
  )), [
    [vue.vShow, _ctx.show]
  ]);
}
const __sfc__$e = vue.defineComponent({
  name: "VarSnackbarCore",
  components: {
    VarLoading: stdin_default$5v,
    VarIcon: stdin_default$5_
  },
  props: props$d,
  setup(props2) {
    const timer = vue.ref(null);
    const { zIndex } = useZIndex(() => props2.show, 1);
    useLock(
      () => props2.show,
      () => props2.lockScroll
    );
    const isForbidClick = vue.computed(() => {
      const { type, forbidClick } = props2;
      return type === "loading" || forbidClick;
    });
    const iconName = vue.computed(() => !props2.type ? "" : ICON_TYPE_DICT[props2.type]);
    function updateAfterDuration() {
      timer.value = setTimeout(() => {
        if (props2.type !== "loading") {
          call(props2["onUpdate:show"], false);
        }
      }, props2.duration);
    }
    vue.watch(
      () => props2.show,
      (show) => {
        if (show) {
          call(props2.onOpen);
          updateAfterDuration();
        } else {
          clearTimeout(timer.value);
          call(props2.onClose);
        }
      }
    );
    vue.watch(
      () => props2._update,
      () => {
        clearTimeout(timer.value);
        updateAfterDuration();
      }
    );
    onSmartMounted(() => {
      if (props2.show) {
        call(props2.onOpen);
        updateAfterDuration();
      }
    });
    return {
      SNACKBAR_TYPE,
      zIndex,
      iconName,
      isForbidClick,
      n: n$f,
      classes: classes$b,
      formatElevation
    };
  }
});
__sfc__$e.render = __render__$d;
var stdin_default$3A = __sfc__$e;
const { name: name$d, n: n$e } = createNamespace("snackbar");
function __render__$c(_ctx, _cache) {
  const _component_var_snackbar_core = vue.resolveComponent("var-snackbar-core");
  return vue.openBlock(), vue.createBlock(vue.Teleport, {
    to: _ctx.teleport === false ? void 0 : _ctx.teleport,
    disabled: _ctx.disabled || _ctx.teleport === false
  }, [
    vue.createVNode(vue.Transition, {
      name: `${_ctx.n()}-fade`,
      onAfterEnter: _ctx.onOpened,
      onAfterLeave: _ctx.onClosed
    }, {
      default: vue.withCtx(() => [
        vue.createVNode(_component_var_snackbar_core, vue.mergeProps(_ctx.$props, {
          class: _ctx.n("transition")
        }), vue.createSlots({
          default: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "default")
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          _ctx.$slots.icon ? {
            name: "icon",
            fn: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "icon")
            ]),
            key: "0"
          } : void 0,
          _ctx.$slots.action ? {
            name: "action",
            fn: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "action")
            ]),
            key: "1"
          } : void 0
        ]), 1040, ["class"])
      ]),
      _: 3
      /* FORWARDED */
    }, 8, ["name", "onAfterEnter", "onAfterLeave"])
  ], 8, ["to", "disabled"]);
}
const __sfc__$d = vue.defineComponent({
  name: name$d,
  components: { VarSnackbarCore: stdin_default$3A },
  props: props$d,
  setup() {
    const { disabled } = useTeleport();
    return {
      disabled,
      n: n$e
    };
  }
});
__sfc__$d.render = __render__$c;
var stdin_default$3z = __sfc__$d;
var __defProp$4 = Object.defineProperty;
var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$4 = (obj, key3, value) => key3 in obj ? __defProp$4(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$4 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$4.call(b, prop))
      __defNormalProp$4(a, prop, b[prop]);
  if (__getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(b)) {
      if (__propIsEnum$4.call(b, prop))
        __defNormalProp$4(a, prop, b[prop]);
    }
  return a;
};
const SNACKBAR_TYPE = ["loading", "success", "warning", "info", "error"];
let sid = 0;
let isMount = false;
let unmount;
let isAllowMultiple = false;
const defaultOptionsValue = {
  type: void 0,
  content: "",
  icon: "",
  action: "",
  position: "top",
  duration: 3e3,
  elevation: true,
  vertical: false,
  contentClass: void 0,
  loadingType: "circle",
  loadingSize: "normal",
  lockScroll: false,
  teleport: "body",
  forbidClick: false,
  onOpen: () => {
  },
  onOpened: () => {
  },
  onClose: () => {
  },
  onClosed: () => {
  }
};
let uniqSnackbarOptions = vue.reactive([]);
let defaultOptions = defaultOptionsValue;
const transitionGroupProps = {
  name: "var-snackbar-fade",
  tag: "div",
  class: "var-transition-group"
};
const getSlotValue = (value) => () => isFunction(value) ? value() : value;
const TransitionGroupHost = {
  setup() {
    return () => {
      const snackbarList = uniqSnackbarOptions.map(({
        id,
        reactiveSnackOptions,
        _update
      }) => {
        const transitionGroupEl = document.querySelector(".var-transition-group");
        if (reactiveSnackOptions.forbidClick || reactiveSnackOptions.type === "loading") {
          transitionGroupEl.classList.add("var-pointer-auto");
        } else {
          transitionGroupEl.classList.remove("var-pointer-auto");
        }
        const style = __spreadValues$4({
          position: isAllowMultiple ? "relative" : "absolute"
        }, getTop(reactiveSnackOptions.position));
        const {
          content,
          icon,
          action
        } = reactiveSnackOptions;
        const slots = {
          default: getSlotValue(content),
          icon: getSlotValue(icon),
          action: getSlotValue(action)
        };
        return vue.createVNode(stdin_default$3A, vue.mergeProps(reactiveSnackOptions, {
          "key": id,
          "style": style,
          "data-id": id,
          "_update": _update,
          "show": reactiveSnackOptions.show,
          "onUpdate:show": ($event) => reactiveSnackOptions.show = $event
        }), slots);
      });
      return vue.createVNode(vue.TransitionGroup, vue.mergeProps(transitionGroupProps, {
        "style": {
          zIndex: stdin_default$66.zIndex
        },
        "onAfterEnter": opened,
        "onAfterLeave": removeUniqOption
      }), {
        default: () => [snackbarList]
      });
    };
  }
};
const Snackbar = function(options) {
  const snackOptions = normalizeOptions(options);
  const reactiveSnackOptions = vue.reactive(__spreadValues$4(__spreadValues$4({}, defaultOptions), snackOptions));
  reactiveSnackOptions.show = true;
  if (!isMount) {
    isMount = true;
    unmount = mountInstance(TransitionGroupHost).unmountInstance;
  }
  const {
    length
  } = uniqSnackbarOptions;
  const uniqSnackbarOptionItem = {
    id: sid++,
    reactiveSnackOptions
  };
  if (length === 0 || isAllowMultiple) {
    addUniqOption(uniqSnackbarOptionItem);
  } else {
    const _update = `update-${sid}`;
    updateUniqOption(reactiveSnackOptions, _update);
  }
  return {
    clear() {
      if (!isAllowMultiple && uniqSnackbarOptions.length) {
        uniqSnackbarOptions[0].reactiveSnackOptions.show = false;
      } else {
        reactiveSnackOptions.show = false;
      }
    }
  };
};
SNACKBAR_TYPE.forEach((type) => {
  Snackbar[type] = (options) => {
    if (isPlainObject(options)) {
      options.type = type;
    } else {
      options = {
        content: options,
        type
      };
    }
    return Snackbar(options);
  };
});
Snackbar.allowMultiple = function(bool = false) {
  if (bool !== isAllowMultiple) {
    uniqSnackbarOptions.forEach((option) => {
      option.reactiveSnackOptions.show = false;
    });
    isAllowMultiple = bool;
  }
};
Snackbar.clear = function() {
  uniqSnackbarOptions.forEach((option) => {
    option.reactiveSnackOptions.show = false;
  });
};
Snackbar.setDefaultOptions = function(options) {
  defaultOptions = options;
};
Snackbar.resetDefaultOptions = function() {
  defaultOptions = defaultOptionsValue;
};
function opened(element) {
  const id = element.getAttribute("data-id");
  const option = uniqSnackbarOptions.find((option2) => option2.id === toNumber(id));
  if (option) {
    call(option.reactiveSnackOptions.onOpened);
  }
}
function removeUniqOption(element) {
  element.parentElement && element.parentElement.classList.remove("var-pointer-auto");
  const id = element.getAttribute("data-id");
  const option = uniqSnackbarOptions.find((option2) => option2.id === toNumber(id));
  if (option) {
    option.animationEnd = true;
    call(option.reactiveSnackOptions.onClosed);
  }
  const isAllAnimationEnd = uniqSnackbarOptions.every((option2) => option2.animationEnd);
  if (isAllAnimationEnd) {
    call(unmount);
    uniqSnackbarOptions = vue.reactive([]);
    isMount = false;
  }
}
function addUniqOption(uniqSnackbarOptionItem) {
  uniqSnackbarOptions.push(uniqSnackbarOptionItem);
}
function normalizeOptions(options = {}) {
  return isString(options) ? {
    content: options
  } : options;
}
function updateUniqOption(reactiveSnackOptions, _update) {
  const [firstOption] = uniqSnackbarOptions;
  firstOption.reactiveSnackOptions = __spreadValues$4(__spreadValues$4({}, firstOption.reactiveSnackOptions), reactiveSnackOptions);
  firstOption._update = _update;
}
function getTop(position = "top") {
  if (position === "bottom") {
    return {
      top: "85%"
    };
  }
  return {
    top: position === "top" ? "5%" : "45%"
  };
}
Snackbar.Component = stdin_default$3z;
withInstall(stdin_default$3z);
withInstall(stdin_default$3z, Snackbar);
withPropsDefaultsSetter(Snackbar, props$d);
const _SnackbarComponent = stdin_default$3z;
var stdin_default$3y = Snackbar;
const props$c = {
  size: {
    type: [String, Number, Array],
    default: "normal"
  },
  wrap: {
    type: Boolean,
    default: true
  },
  direction: {
    type: String,
    default: "row"
  },
  justify: {
    type: String,
    default: "flex-start"
  },
  align: String,
  inline: Boolean
};
function half(value) {
  return `calc(${value} / 2)`;
}
function computeMargin(y, x, options) {
  const { direction, justify, index, lastIndex } = options;
  let margin = "0";
  if (direction === "row") {
    if (["flex-start", "center", "flex-end", "start", "end"].includes(justify)) {
      if (index !== lastIndex) {
        margin = `${half(y)} ${x} ${half(y)} 0`;
      } else {
        margin = `${half(y)} 0`;
      }
    } else if (justify === "space-around") {
      margin = `${half(y)} ${half(x)}`;
    } else if (justify === "space-between") {
      if (index === 0) {
        margin = `${half(y)} ${half(x)} ${half(y)} 0`;
      } else if (index === lastIndex) {
        margin = `${half(y)} 0 ${half(y)} ${half(x)}`;
      } else {
        margin = `${half(y)} ${half(x)}`;
      }
    }
  }
  if (direction === "column" && index !== lastIndex) {
    margin = `0 0 ${y} 0`;
  }
  return margin;
}
const isInternalSize = (size) => ["mini", "small", "normal", "large"].includes(size);
const {
  name: name$c,
  n: n$d,
  classes: classes$a
} = createNamespace("space");
function getSize(size, isInternalSize2) {
  return isInternalSize2 ? [`var(--space-size-${size}-y)`, `var(--space-size-${size}-x)`] : isArray(size) ? size.map(toSizeUnit) : [toSizeUnit(size), toSizeUnit(size)];
}
var stdin_default$3x = vue.defineComponent({
  name: name$c,
  props: props$c,
  setup(props2, {
    slots
  }) {
    return () => {
      var _a;
      const {
        inline,
        justify,
        align,
        wrap,
        direction,
        size
      } = props2;
      const _children = (_a = call(slots.default)) != null ? _a : [];
      const [y, x] = getSize(size, isInternalSize(size));
      const children = flatFragment(_children);
      const lastIndex = children.length - 1;
      const spacers = children.map((child, index) => {
        var _a2;
        const margin = computeMargin(y, x, {
          direction,
          justify,
          index,
          lastIndex
        });
        return vue.createVNode("div", {
          "class": classes$a([direction === "column", n$d("--auto")]),
          "key": (_a2 = child.key) != null ? _a2 : void 0,
          "style": {
            margin
          }
        }, [child]);
      });
      return vue.createVNode("div", {
        "class": classes$a(n$d(), n$d("$--box"), [inline, n$d("--inline")]),
        "style": {
          flexDirection: direction,
          justifyContent: padStartFlex(justify),
          alignItems: padStartFlex(align),
          flexWrap: wrap ? "wrap" : "nowrap",
          margin: direction === "row" ? `calc(-1 * ${y} / 2) 0` : void 0
        }
      }, [spacers]);
    };
  }
});
withInstall(stdin_default$3x);
withPropsDefaultsSetter(stdin_default$3x, props$c);
const _SpaceComponent = stdin_default$3x;
var stdin_default$3w = stdin_default$3x;
const props$b = {
  activeIcon: {
    type: String,
    default: "check"
  },
  currentIcon: pickProps(props$1j, "name"),
  inactiveIcon: pickProps(props$1j, "name"),
  activeIconNamespace: pickProps(props$1j, "namespace"),
  currentIconNamespace: pickProps(props$1j, "namespace"),
  inactiveIconNamespace: pickProps(props$1j, "namespace")
};
const STEPS_BIND_STEP_KEY = Symbol("STEPS_BIND_STEP_KEY");
function useStep() {
  const { bindChildren, childProviders } = useChildren(STEPS_BIND_STEP_KEY);
  return {
    step: childProviders,
    bindStep: bindChildren
  };
}
function useSteps() {
  const { parentProvider, index, bindParent } = useParent(STEPS_BIND_STEP_KEY);
  assert(!!bindParent, "Steps", "<step/> must in <steps>");
  return {
    index,
    steps: parentProvider,
    bindSteps: bindParent
  };
}
const { name: name$b, n: n$c, classes: classes$9 } = createNamespace("step");
const _hoisted_1$3 = { key: 3 };
function __render__$b(_ctx, _cache) {
  const _component_var_icon = vue.resolveComponent("var-icon");
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.n())
    },
    [
      vue.createElementVNode(
        "div",
        {
          class: vue.normalizeClass(_ctx.n(_ctx.direction))
        },
        [
          vue.createElementVNode(
            "div",
            {
              class: vue.normalizeClass(_ctx.classes(_ctx.n(`${_ctx.direction}-tag`), [_ctx.isActive || _ctx.isCurrent, _ctx.n(`${_ctx.direction}-tag--active`)])),
              style: vue.normalizeStyle({ backgroundColor: _ctx.isActive || _ctx.isCurrent ? _ctx.activeColor : _ctx.inactiveColor }),
              onClick: _cache[0] || (_cache[0] = (...args) => _ctx.click && _ctx.click(...args))
            },
            [
              _ctx.isActive ? (vue.openBlock(), vue.createBlock(_component_var_icon, {
                key: 0,
                class: vue.normalizeClass(_ctx.n("icon")),
                "var-step-cover": "",
                name: _ctx.activeIcon,
                namespace: _ctx.activeIconNamespace
              }, null, 8, ["class", "name", "namespace"])) : _ctx.isCurrent && _ctx.currentIcon ? (vue.openBlock(), vue.createBlock(_component_var_icon, {
                key: 1,
                class: vue.normalizeClass(_ctx.n("icon")),
                "var-step-cover": "",
                name: _ctx.currentIcon,
                namespace: _ctx.currentIconNamespace
              }, null, 8, ["class", "name", "namespace"])) : _ctx.inactiveIcon ? (vue.openBlock(), vue.createBlock(_component_var_icon, {
                key: 2,
                class: vue.normalizeClass(_ctx.n("icon")),
                "var-step-cover": "",
                name: _ctx.inactiveIcon,
                namespace: _ctx.inactiveIconNamespace
              }, null, 8, ["class", "name", "namespace"])) : (vue.openBlock(), vue.createElementBlock(
                "span",
                _hoisted_1$3,
                vue.toDisplayString(_ctx.index + 1),
                1
                /* TEXT */
              ))
            ],
            6
            /* CLASS, STYLE */
          ),
          _ctx.$slots.default ? (vue.openBlock(), vue.createElementBlock(
            "div",
            {
              key: 0,
              class: vue.normalizeClass(_ctx.classes(_ctx.n(`${_ctx.direction}-content`), [_ctx.isActive || _ctx.isCurrent, _ctx.n(`${_ctx.direction}-content--active`)])),
              onClick: _cache[1] || (_cache[1] = (...args) => _ctx.click && _ctx.click(...args))
            },
            [
              vue.renderSlot(_ctx.$slots, "default")
            ],
            2
            /* CLASS */
          )) : vue.createCommentVNode("v-if", true),
          vue.createElementVNode(
            "div",
            {
              class: vue.normalizeClass(_ctx.n(`${_ctx.direction}-line`))
            },
            null,
            2
            /* CLASS */
          )
        ],
        2
        /* CLASS */
      )
    ],
    2
    /* CLASS */
  );
}
const __sfc__$c = vue.defineComponent({
  name: name$b,
  components: { VarIcon: stdin_default$5_ },
  props: props$b,
  setup() {
    const { index, steps, bindSteps } = useSteps();
    const { active, activeColor, inactiveColor, direction, clickStep } = steps;
    const isCurrent = vue.computed(() => active.value === index.value);
    const isActive = vue.computed(() => index.value !== -1 && toNumber(active.value) > index.value);
    const stepProvider = { index };
    bindSteps(stepProvider);
    function click() {
      return clickStep(index.value);
    }
    return {
      index,
      isActive,
      isCurrent,
      direction,
      activeColor,
      inactiveColor,
      n: n$c,
      classes: classes$9,
      click
    };
  }
});
__sfc__$c.render = __render__$b;
var stdin_default$3v = __sfc__$c;
withInstall(stdin_default$3v);
withPropsDefaultsSetter(stdin_default$3v, props$b);
const _StepComponent = stdin_default$3v;
var stdin_default$3u = stdin_default$3v;
const props$a = {
  active: {
    type: [String, Number],
    default: 0
  },
  direction: {
    type: String,
    default: "horizontal"
  },
  activeColor: String,
  inactiveColor: String,
  onClickStep: defineListenerProp()
};
const { name: name$a, n: n$b } = createNamespace("steps");
function __render__$a(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.n()),
      style: vue.normalizeStyle({ flexDirection: _ctx.direction === "horizontal" ? "row" : "column" })
    },
    [
      vue.renderSlot(_ctx.$slots, "default")
    ],
    6
    /* CLASS, STYLE */
  );
}
const __sfc__$b = vue.defineComponent({
  name: name$a,
  props: props$a,
  setup(props2) {
    const active = vue.computed(() => props2.active);
    const activeColor = vue.computed(() => props2.activeColor);
    const inactiveColor = vue.computed(() => props2.inactiveColor);
    const direction = vue.computed(() => props2.direction);
    const { bindStep } = useStep();
    const stepsProvider = {
      active,
      direction,
      activeColor,
      inactiveColor,
      clickStep
    };
    bindStep(stepsProvider);
    function clickStep(index) {
      call(props2.onClickStep, index);
    }
    return { n: n$b };
  }
});
__sfc__$b.render = __render__$a;
var stdin_default$3t = __sfc__$b;
withInstall(stdin_default$3t);
withPropsDefaultsSetter(stdin_default$3t, props$a);
const _StepsComponent = stdin_default$3t;
var stdin_default$3s = stdin_default$3t;
const props$9 = {
  styleVars: {
    type: Object,
    default: () => ({})
  },
  tag: {
    type: String,
    default: "div"
  }
};
const { name: name$9, n: n$a } = createNamespace("style-provider");
const __sfc__$a = vue.defineComponent({
  name: name$9,
  props: props$9,
  setup(props2, { slots }) {
    return () => vue.h(
      props2.tag,
      {
        class: n$a(),
        style: formatStyleVars(props2.styleVars)
      },
      call(slots.default)
    );
  }
});
var stdin_default$3r = __sfc__$a;
const styleId = "varlet-style-vars";
function removeStyle() {
  const style = document.head.querySelector(`#${styleId}`);
  if (style) {
    document.head.removeChild(style);
  }
}
function insertStyle(content) {
  const style = document.createElement("style");
  style.id = styleId;
  style.innerHTML = content;
  document.head.appendChild(style);
}
function StyleProvider(styleVars) {
  if (styleVars == null) {
    removeStyle();
    return;
  }
  const styles = formatStyleVars(styleVars != null ? styleVars : {});
  const content = Object.entries(styles).reduce((content2, [key3, value]) => {
    content2 += `${key3}:${value};`;
    return content2;
  }, `:root:root {
`);
  removeStyle();
  insertStyle(`${content}
}`);
}
StyleProvider.Component = stdin_default$3r;
withInstall(stdin_default$3r);
withInstall(stdin_default$3r, StyleProvider);
withPropsDefaultsSetter(StyleProvider, props$9);
const _StyleProviderComponent = stdin_default$3r;
var stdin_default$3q = StyleProvider;
const props$8 = {
  modelValue: {
    default: false
  },
  activeValue: {
    default: true
  },
  inactiveValue: {
    default: false
  },
  lazyChange: Boolean,
  disabled: Boolean,
  readonly: Boolean,
  loading: Boolean,
  color: String,
  loadingColor: String,
  closeColor: String,
  size: [String, Number],
  variant: Boolean,
  rules: [Array, Function, Object],
  ripple: {
    type: Boolean,
    default: true
  },
  buttonElevation: {
    type: [Boolean, String, Number],
    default: true
  },
  validateTrigger: {
    type: Array,
    default: () => ["onChange", "onLazyChange"]
  },
  onClick: defineListenerProp(),
  onBeforeChange: defineListenerProp(),
  onChange: defineListenerProp(),
  "onUpdate:modelValue": defineListenerProp()
};
const { name: name$8, n: n$9, classes: classes$8 } = createNamespace("switch");
const _hoisted_1$2 = ["aria-checked"];
const _hoisted_2$2 = ["tabindex"];
function __render__$9(_ctx, _cache) {
  const _component_var_hover_overlay = vue.resolveComponent("var-hover-overlay");
  const _component_var_form_details = vue.resolveComponent("var-form-details");
  const _directive_ripple = vue.resolveDirective("ripple");
  const _directive_hover = vue.resolveDirective("hover");
  return vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", {
    class: vue.normalizeClass(_ctx.classes(_ctx.n(), [_ctx.variant, _ctx.n("--variant")])),
    role: "switch",
    "aria-checked": _ctx.modelValue
  }, [
    vue.createElementVNode(
      "div",
      {
        ref: "switchRef",
        class: vue.normalizeClass(_ctx.classes(_ctx.n("block"), [_ctx.disabled || _ctx.formDisabled, _ctx.n("--disabled")], [_ctx.isActive, _ctx.n("block--active")])),
        style: vue.normalizeStyle(_ctx.styleComputed.switch),
        onClick: _cache[2] || (_cache[2] = (...args) => _ctx.switchActive && _ctx.switchActive(...args))
      },
      [
        vue.createElementVNode(
          "div",
          {
            style: vue.normalizeStyle(_ctx.styleComputed.track),
            class: vue.normalizeClass(_ctx.classes(_ctx.n("track"), [_ctx.isActive, _ctx.n("track--active")], [_ctx.errorMessage && !_ctx.variant, _ctx.n("track--error")]))
          },
          null,
          6
          /* CLASS, STYLE */
        ),
        vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", {
          class: vue.normalizeClass(_ctx.classes(_ctx.n("ripple"), [_ctx.isActive, _ctx.n("ripple--active")])),
          style: vue.normalizeStyle(_ctx.styleComputed.ripple),
          tabindex: _ctx.disabled || _ctx.formDisabled ? void 0 : "0",
          onFocus: _cache[0] || (_cache[0] = ($event) => _ctx.isFocusing = true),
          onBlur: _cache[1] || (_cache[1] = ($event) => _ctx.isFocusing = false)
        }, [
          vue.createElementVNode(
            "div",
            {
              style: vue.normalizeStyle(_ctx.styleComputed.handle),
              class: vue.normalizeClass(
                _ctx.classes(
                  _ctx.n("handle"),
                  _ctx.formatElevation(_ctx.buttonElevation, 2),
                  [_ctx.isActive, _ctx.n("handle--active")],
                  [_ctx.errorMessage && !_ctx.variant, _ctx.n("handle--error")],
                  [_ctx.hovering, _ctx.n("handle--hover")]
                )
              )
            },
            [
              _ctx.loading ? (vue.openBlock(), vue.createElementBlock(
                "span",
                {
                  key: 0,
                  class: vue.normalizeClass(_ctx.n("loading")),
                  style: vue.normalizeStyle({
                    width: _ctx.radius,
                    height: _ctx.radius
                  })
                },
                _cache[3] || (_cache[3] = [
                  vue.createElementVNode(
                    "svg",
                    { viewBox: "25 25 50 50" },
                    [
                      vue.createElementVNode("circle", {
                        cx: "50",
                        cy: "50",
                        r: "20",
                        fill: "none"
                      })
                    ],
                    -1
                    /* HOISTED */
                  )
                ]),
                6
                /* CLASS, STYLE */
              )) : vue.createCommentVNode("v-if", true)
            ],
            6
            /* CLASS, STYLE */
          ),
          vue.createVNode(_component_var_hover_overlay, {
            hovering: _ctx.hovering && !_ctx.disabled && !_ctx.formDisabled,
            focusing: _ctx.isFocusing && !_ctx.disabled && !_ctx.formDisabled
          }, null, 8, ["hovering", "focusing"])
        ], 46, _hoisted_2$2)), [
          [_directive_ripple, {
            disabled: !_ctx.ripple || _ctx.disabled || _ctx.loading || _ctx.formDisabled || _ctx.readonly || _ctx.formReadonly
          }]
        ])
      ],
      6
      /* CLASS, STYLE */
    ),
    vue.createVNode(_component_var_form_details, { "error-message": _ctx.errorMessage }, null, 8, ["error-message"])
  ], 10, _hoisted_1$2)), [
    [_directive_hover, _ctx.hover, "desktop"]
  ]);
}
const __sfc__$9 = vue.defineComponent({
  name: name$8,
  components: {
    VarFormDetails: stdin_default$5R,
    VarHoverOverlay: stdin_default$60
  },
  directives: { Ripple: stdin_default$63, Hover: stdin_default$62 },
  props: props$8,
  setup(props2) {
    const switchRef = vue.ref(null);
    const isFocusing = vue.ref(false);
    const { bindForm, form } = useForm();
    const { errorMessage, validateWithTrigger: vt, validate: v, resetValidation } = useValidation();
    const { hovering, handleHovering } = useHoverOverlay();
    const isActive = vue.computed(() => props2.modelValue === props2.activeValue);
    const styleComputed = vue.computed(() => {
      const { size, color, closeColor, loadingColor, variant } = props2;
      return {
        handle: {
          width: multiplySizeUnit(size),
          height: multiplySizeUnit(size),
          backgroundColor: isActive.value ? color : closeColor,
          color: loadingColor
        },
        ripple: {
          left: isActive.value ? multiplySizeUnit(size, 0.5) : `-${multiplySizeUnit(size, variant ? 1 / 3 : 0.5)}`,
          color: isActive.value ? color : closeColor || "currentColor",
          width: multiplySizeUnit(size, 2),
          height: multiplySizeUnit(size, 2)
        },
        track: {
          width: multiplySizeUnit(size, variant ? 13 / 6 : 1.9),
          height: multiplySizeUnit(size, variant ? 4 / 3 : 0.72),
          borderRadius: multiplySizeUnit(size, 2 / 3),
          filter: isActive.value || (errorMessage == null ? void 0 : errorMessage.value) ? void 0 : `brightness(${variant ? 1 : 0.6})`,
          backgroundColor: isActive.value ? color : closeColor,
          borderWidth: variant && !isActive.value ? multiplySizeUnit(size, 1 / 12) : void 0
        },
        switch: {
          width: multiplySizeUnit(size, variant ? 13 / 6 : 2),
          height: multiplySizeUnit(size, variant ? 4 / 3 : 1.2)
        }
      };
    });
    const radius = vue.computed(() => multiplySizeUnit(props2.size, 0.8));
    const switchProvider = {
      reset,
      validate,
      resetValidation
    };
    call(bindForm, switchProvider);
    useEventListener(() => window, "keydown", handleKeydown);
    useEventListener(() => window, "keyup", handleKeyup);
    function handleKeydown(event) {
      if (!isFocusing.value) {
        return;
      }
      if (event.key === " " || event.key === "Enter") {
        preventDefault(event);
      }
      if (event.key === "Enter") {
        switchRef.value.click();
      }
    }
    function handleKeyup(event) {
      if (!isFocusing.value || event.key !== " ") {
        return;
      }
      preventDefault(event);
      switchRef.value.click();
    }
    function validate() {
      return v(props2.rules, props2.modelValue);
    }
    function validateWithTrigger(trigger) {
      vue.nextTick(() => {
        const { validateTrigger, rules, modelValue } = props2;
        vt(validateTrigger, trigger, rules, modelValue);
      });
    }
    function switchActive(event) {
      const {
        onClick,
        onChange,
        disabled,
        loading,
        readonly,
        activeValue,
        inactiveValue,
        lazyChange,
        "onUpdate:modelValue": updateModelValue,
        onBeforeChange
      } = props2;
      if (disabled || (form == null ? void 0 : form.disabled.value)) {
        return;
      }
      call(onClick, event);
      if (loading || readonly || (form == null ? void 0 : form.readonly.value)) {
        return;
      }
      const newValue = isActive.value ? inactiveValue : activeValue;
      if (lazyChange) {
        call(onBeforeChange, newValue, (value) => {
          call(updateModelValue, value);
          validateWithTrigger("onLazyChange");
        });
      } else {
        call(onChange, newValue);
        call(updateModelValue, newValue);
        validateWithTrigger("onChange");
      }
    }
    function hover(value) {
      if (props2.disabled || (form == null ? void 0 : form.disabled.value)) {
        return;
      }
      handleHovering(value);
    }
    function reset() {
      call(props2["onUpdate:modelValue"], props2.inactiveValue);
      resetValidation();
    }
    return {
      isActive,
      switchRef,
      hovering,
      isFocusing,
      radius,
      styleComputed,
      errorMessage,
      formDisabled: form == null ? void 0 : form.disabled,
      formReadonly: form == null ? void 0 : form.readonly,
      n: n$9,
      classes: classes$8,
      formatElevation,
      multiplySizeUnit,
      switchActive,
      hover
    };
  }
});
__sfc__$9.render = __render__$9;
var stdin_default$3p = __sfc__$9;
withInstall(stdin_default$3p);
withPropsDefaultsSetter(stdin_default$3p, props$8);
const _SwitchComponent = stdin_default$3p;
var stdin_default$3o = stdin_default$3p;
const props$7 = {
  name: [String, Number],
  disabled: Boolean,
  ripple: {
    type: Boolean,
    default: true
  },
  onClick: defineListenerProp()
};
const TABS_BIND_TAB_KEY = Symbol("TABS_BIND_TAB_KEY");
function useTabList() {
  const { childProviders, bindChildren, length } = useChildren(TABS_BIND_TAB_KEY);
  return {
    length,
    tabList: childProviders,
    bindTabList: bindChildren
  };
}
function useTabs() {
  const { parentProvider, bindParent, index } = useParent(TABS_BIND_TAB_KEY);
  assert(!!bindParent, "Tab", "<var-tab/> must in <var-tabs/>");
  return {
    index,
    tabs: parentProvider,
    bindTabs: bindParent
  };
}
const { name: name$7, n: n$8, classes: classes$7 } = createNamespace("tab");
function __render__$8(_ctx, _cache) {
  const _directive_ripple = vue.resolveDirective("ripple");
  return vue.withDirectives((vue.openBlock(), vue.createElementBlock(
    "div",
    {
      ref: "tabEl",
      class: vue.normalizeClass(_ctx.classes(_ctx.n(), _ctx.n("$--box"), _ctx.computeColorClass(), _ctx.n(`--${_ctx.itemDirection}`))),
      style: vue.normalizeStyle({
        color: _ctx.computeColorStyle()
      }),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    },
    [
      vue.renderSlot(_ctx.$slots, "default")
    ],
    6
    /* CLASS, STYLE */
  )), [
    [_directive_ripple, { disabled: _ctx.disabled || !_ctx.ripple }]
  ]);
}
const __sfc__$8 = vue.defineComponent({
  name: name$7,
  directives: { Ripple: stdin_default$63 },
  props: props$7,
  setup(props2) {
    const tabEl = vue.ref(null);
    const element = vue.computed(() => tabEl.value);
    const name2 = vue.computed(() => props2.name);
    const disabled = vue.computed(() => props2.disabled);
    const { index, tabs, bindTabs } = useTabs();
    const { onTabClick, active, activeColor, inactiveColor, disabledColor, itemDirection, resize } = tabs;
    const tabProvider = {
      name: name2,
      index,
      disabled,
      element
    };
    bindTabs(tabProvider);
    vue.watch(() => [props2.name, props2.disabled], resize);
    function shouldActive() {
      if (props2.name != null) {
        return active.value === props2.name;
      }
      return active.value === (index == null ? void 0 : index.value);
    }
    function computeColorStyle() {
      return props2.disabled ? disabledColor.value : shouldActive() ? activeColor.value : inactiveColor.value;
    }
    function computeColorClass() {
      return props2.disabled ? n$8("$-tab--disabled") : shouldActive() ? n$8("$-tab--active") : n$8("$-tab--inactive");
    }
    function handleClick(event) {
      const { disabled: disabled2, name: name3, onClick } = props2;
      if (disabled2) {
        return;
      }
      call(onClick, name3 != null ? name3 : index.value, event);
      onTabClick(tabProvider);
    }
    return {
      tabEl,
      active,
      activeColor,
      inactiveColor,
      itemDirection,
      n: n$8,
      classes: classes$7,
      computeColorStyle,
      computeColorClass,
      handleClick
    };
  }
});
__sfc__$8.render = __render__$8;
var stdin_default$3n = __sfc__$8;
withInstall(stdin_default$3n);
withPropsDefaultsSetter(stdin_default$3n, props$7);
const _TabComponent = stdin_default$3n;
var stdin_default$3m = stdin_default$3n;
const props$6 = {
  name: [String, Number]
};
const { name: name$6, n: n$7, classes: classes$6 } = createNamespace("tab-item");
function __render__$7(_ctx, _cache) {
  const _component_var_swipe_item = vue.resolveComponent("var-swipe-item");
  return vue.openBlock(), vue.createBlock(_component_var_swipe_item, {
    class: vue.normalizeClass(_ctx.classes(_ctx.n(), [!_ctx.current, _ctx.n("--inactive")])),
    "var-tab-item-cover": ""
  }, {
    default: vue.withCtx(() => [
      vue.renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
    /* FORWARDED */
  }, 8, ["class"]);
}
const __sfc__$7 = vue.defineComponent({
  name: name$6,
  components: { VarSwipeItem: stdin_default$4n },
  props: props$6,
  setup(props2) {
    const current = vue.ref(false);
    const name2 = vue.computed(() => props2.name);
    const { index, bindTabsItems } = useTabsItems();
    const { bindLists } = useLists();
    const tabItemProvider = {
      index,
      name: name2,
      current: vue.computed(() => current.value),
      setCurrent
    };
    bindTabsItems(tabItemProvider);
    bindLists(tabItemProvider);
    function setCurrent(value) {
      current.value = value;
    }
    return {
      current,
      n: n$7,
      classes: classes$6
    };
  }
});
__sfc__$7.render = __render__$7;
var stdin_default$3l = __sfc__$7;
withInstall(stdin_default$3l);
withPropsDefaultsSetter(stdin_default$3l, props$6);
const _TabItemComponent = stdin_default$3l;
var stdin_default$3k = stdin_default$3l;
const props$5 = {
  fullWidth: {
    type: [Number, String],
    default: "100%"
  },
  scrollerHeight: {
    type: [Number, String]
  },
  elevation: {
    type: [Boolean, Number, String],
    default: true
  }
};
const { name: name$5, n: n$6, classes: classes$5 } = createNamespace("table");
function __render__$6(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.classes(_ctx.n(), _ctx.formatElevation(_ctx.elevation, 1), _ctx.n("$--box")))
    },
    [
      vue.createElementVNode(
        "div",
        {
          class: vue.normalizeClass(_ctx.n("main")),
          style: vue.normalizeStyle({ height: _ctx.toSizeUnit(_ctx.scrollerHeight) })
        },
        [
          vue.createElementVNode(
            "table",
            {
              class: vue.normalizeClass(_ctx.n("table")),
              style: vue.normalizeStyle({ width: _ctx.toSizeUnit(_ctx.fullWidth) })
            },
            [
              vue.renderSlot(_ctx.$slots, "default")
            ],
            6
            /* CLASS, STYLE */
          )
        ],
        6
        /* CLASS, STYLE */
      ),
      _ctx.$slots.footer ? (vue.openBlock(), vue.createElementBlock(
        "div",
        {
          key: 0,
          class: vue.normalizeClass(_ctx.n("footer"))
        },
        [
          vue.renderSlot(_ctx.$slots, "footer")
        ],
        2
        /* CLASS */
      )) : vue.createCommentVNode("v-if", true)
    ],
    2
    /* CLASS */
  );
}
const __sfc__$6 = vue.defineComponent({
  name: name$5,
  props: props$5,
  setup: () => ({
    toSizeUnit,
    n: n$6,
    classes: classes$5,
    formatElevation
  })
});
__sfc__$6.render = __render__$6;
var stdin_default$3j = __sfc__$6;
withInstall(stdin_default$3j);
withPropsDefaultsSetter(stdin_default$3j, props$5);
const _TableComponent = stdin_default$3j;
var stdin_default$3i = stdin_default$3j;
const props$4 = {
  active: {
    type: [String, Number],
    default: 0
  },
  layoutDirection: {
    type: String,
    default: "horizontal"
  },
  itemDirection: {
    type: String,
    default: "horizontal"
  },
  fixedBottom: Boolean,
  activeColor: String,
  inactiveColor: String,
  disabledColor: String,
  color: String,
  indicatorColor: String,
  indicatorSize: [String, Number],
  elevation: {
    type: [Boolean, String, Number],
    default: false
  },
  scrollable: {
    type: String,
    default: "auto"
  },
  indicatorPosition: {
    type: String,
    default: "normal"
  },
  safeArea: Boolean,
  sticky: Boolean,
  stickyCssMode: pickProps(props$L, "cssMode"),
  stickyZIndex: pickProps(props$L, "zIndex"),
  offsetTop: pickProps(props$L, "offsetTop"),
  onClick: defineListenerProp(),
  onChange: defineListenerProp(),
  "onUpdate:active": defineListenerProp()
};
var __async$3 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const { name: name$4, n: n$5, classes: classes$4 } = createNamespace("tabs");
function __render__$5(_ctx, _cache) {
  return vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.sticky ? _ctx.n("$-sticky") : _ctx.Transition), {
    ref: _ctx.sticky ? "stickyComponent" : void 0,
    "css-mode": _ctx.sticky ? _ctx.stickyCssMode : void 0,
    "offset-top": _ctx.sticky ? _ctx.offsetTop : void 0,
    "z-index": _ctx.sticky ? _ctx.stickyZIndex : void 0
  }, {
    default: vue.withCtx(() => [
      vue.createElementVNode(
        "div",
        vue.mergeProps({
          class: _ctx.classes(
            _ctx.n(),
            _ctx.n("$--box"),
            _ctx.n(`--item-${_ctx.itemDirection}`),
            _ctx.n(`--layout-${_ctx.layoutDirection}-padding`),
            _ctx.formatElevation(_ctx.elevation, 4),
            [_ctx.fixedBottom, _ctx.n("--fixed-bottom")],
            [_ctx.safeArea, _ctx.n("--safe-area")]
          ),
          style: { background: _ctx.color }
        }, _ctx.$attrs),
        [
          vue.createElementVNode(
            "div",
            {
              ref: "scrollerEl",
              class: vue.normalizeClass(
                _ctx.classes(
                  _ctx.n("tab-wrap"),
                  [_ctx.localScrollable, _ctx.n(`--layout-${_ctx.layoutDirection}-scrollable`)],
                  _ctx.n(`--layout-${_ctx.layoutDirection}`)
                )
              )
            },
            [
              vue.renderSlot(_ctx.$slots, "default"),
              vue.createElementVNode(
                "div",
                {
                  class: vue.normalizeClass(_ctx.classes(_ctx.n("indicator"), _ctx.n(`--layout-${_ctx.layoutDirection}${_ctx.indicatorPosition}-indicator`))),
                  style: vue.normalizeStyle({
                    width: _ctx.layoutDirection === "horizontal" ? _ctx.indicatorWidth : _ctx.toSizeUnit(_ctx.indicatorSize),
                    height: _ctx.layoutDirection === "horizontal" ? _ctx.toSizeUnit(_ctx.indicatorSize) : _ctx.indicatorHeight,
                    transform: _ctx.layoutDirection === "horizontal" ? `translateX(${_ctx.indicatorX})` : `translateY(${_ctx.indicatorY})`
                  })
                },
                [
                  vue.createElementVNode(
                    "div",
                    {
                      class: vue.normalizeClass(_ctx.classes(_ctx.n("indicator-inner"), _ctx.n(`--layout-${_ctx.layoutDirection}-indicator-inner`))),
                      style: vue.normalizeStyle({ background: _ctx.indicatorColor || _ctx.activeColor })
                    },
                    null,
                    6
                    /* CLASS, STYLE */
                  )
                ],
                6
                /* CLASS, STYLE */
              )
            ],
            2
            /* CLASS */
          )
        ],
        16
        /* FULL_PROPS */
      )
    ]),
    _: 3
    /* FORWARDED */
  }, 8, ["css-mode", "offset-top", "z-index"]);
}
const __sfc__$5 = vue.defineComponent({
  name: name$4,
  components: { VarSticky: stdin_default$4O },
  inheritAttrs: false,
  props: props$4,
  setup(props2) {
    const indicatorWidth = vue.ref("0px");
    const indicatorHeight = vue.ref("0px");
    const indicatorX = vue.ref("0px");
    const indicatorY = vue.ref("0px");
    const localScrollable = vue.ref(false);
    const scrollerEl = vue.ref(null);
    const active = vue.computed(() => props2.active);
    const activeColor = vue.computed(() => props2.activeColor);
    const inactiveColor = vue.computed(() => props2.inactiveColor);
    const disabledColor = vue.computed(() => props2.disabledColor);
    const itemDirection = vue.computed(() => props2.itemDirection);
    const stickyComponent = vue.ref(null);
    const indicatorPosition = vue.computed(() => props2.indicatorPosition === "reverse" ? "-reverse" : "");
    const { tabList, bindTabList, length } = useTabList();
    const tabsProvider = {
      active,
      activeColor,
      inactiveColor,
      disabledColor,
      itemDirection,
      resize,
      onTabClick
    };
    bindTabList(tabsProvider);
    vue.watch(
      () => length.value,
      () => __async$3(this, null, function* () {
        yield doubleRaf();
        resize();
      })
    );
    vue.watch(() => [props2.active, props2.scrollable], resize);
    vue.onActivated(resize);
    onWindowResize(resize);
    function onTabClick(tab) {
      var _a;
      const currentActive = (_a = tab.name.value) != null ? _a : tab.index.value;
      const { active: active2, onChange, onClick } = props2;
      call(props2["onUpdate:active"], currentActive);
      call(onClick, currentActive);
      currentActive !== active2 && call(onChange, currentActive);
    }
    function matchName() {
      return tabList.find(({ name: name2 }) => props2.active === name2.value);
    }
    function matchIndex(activeIndex) {
      return tabList.find(({ index }) => (activeIndex != null ? activeIndex : props2.active) === index.value);
    }
    function matchBoundary() {
      if (length.value === 0) {
        return;
      }
      const { active: active2 } = props2;
      if (isNumber(active2)) {
        const activeIndex = clamp$1(active2, 0, length.value - 1);
        call(props2["onUpdate:active"], activeIndex);
        return matchIndex(activeIndex);
      }
    }
    function watchScrollable() {
      localScrollable.value = props2.scrollable === "always" || tabList.length >= 5;
    }
    function moveIndicator({ element }) {
      const el = element.value;
      if (!el) {
        return;
      }
      if (props2.layoutDirection === "horizontal") {
        indicatorWidth.value = `${el.offsetWidth}px`;
        indicatorX.value = `${el.offsetLeft}px`;
      } else {
        indicatorHeight.value = `${el.offsetHeight}px`;
        indicatorY.value = `${el.offsetTop}px`;
      }
    }
    function scrollToCenter({ element }) {
      if (!localScrollable.value) {
        return;
      }
      const scroller = scrollerEl.value;
      const el = element.value;
      if (props2.layoutDirection === "horizontal") {
        const left2 = el.offsetLeft + el.offsetWidth / 2 - scroller.offsetWidth / 2;
        scrollTo(scroller, {
          left: left2,
          animation: linear
        });
      } else {
        const top2 = el.offsetTop + el.offsetHeight / 2 - scroller.offsetHeight / 2;
        scrollTo(scroller, {
          top: top2,
          animation: linear
        });
      }
    }
    function resize() {
      const tab = matchName() || matchIndex() || matchBoundary();
      if (!tab || tab.disabled.value) {
        return;
      }
      watchScrollable();
      moveIndicator(tab);
      scrollToCenter(tab);
    }
    function resizeSticky() {
      return __async$3(this, null, function* () {
        if (props2.sticky && stickyComponent.value) {
          yield stickyComponent.value.resize();
        }
      });
    }
    return {
      stickyComponent,
      indicatorWidth,
      indicatorHeight,
      indicatorX,
      indicatorY,
      indicatorPosition,
      localScrollable,
      scrollerEl,
      Transition: vue.Transition,
      toSizeUnit,
      n: n$5,
      classes: classes$4,
      resize,
      resizeSticky,
      formatElevation
    };
  }
});
__sfc__$5.render = __render__$5;
var stdin_default$3h = __sfc__$5;
withInstall(stdin_default$3h);
withPropsDefaultsSetter(stdin_default$3h, props$4);
const _TabsComponent = stdin_default$3h;
var stdin_default$3g = stdin_default$3h;
const props$3 = {
  active: {
    type: [String, Number],
    default: 0
  },
  canSwipe: {
    type: Boolean,
    default: true
  },
  loop: Boolean,
  "onUpdate:active": defineListenerProp()
};
var __async$2 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const { name: name$3, n: n$4 } = createNamespace("tabs-items");
function __render__$4(_ctx, _cache) {
  const _component_var_swipe = vue.resolveComponent("var-swipe");
  return vue.openBlock(), vue.createBlock(_component_var_swipe, {
    ref: "swipe",
    class: vue.normalizeClass(_ctx.n()),
    loop: _ctx.loop,
    touchable: _ctx.canSwipe,
    indicator: false,
    onChange: _ctx.handleSwipeChange
  }, {
    default: vue.withCtx(() => [
      vue.renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
    /* FORWARDED */
  }, 8, ["class", "loop", "touchable", "onChange"]);
}
const __sfc__$4 = vue.defineComponent({
  name: name$3,
  components: { VarSwipe: stdin_default$4p },
  props: props$3,
  setup(props2) {
    const swipe = vue.ref(null);
    const { tabItemList, bindTabItem, length } = useTabItem$1();
    bindTabItem({});
    vue.watch(() => props2.active, handleActiveChange);
    vue.watch(
      () => length.value,
      () => __async$2(this, null, function* () {
        yield doubleRaf();
        handleActiveChange(props2.active);
      })
    );
    function matchName(active) {
      return tabItemList.find(({ name: name2 }) => active === name2.value);
    }
    function matchIndex(active) {
      return tabItemList.find(({ index }) => active === index.value);
    }
    function matchActive(active) {
      return matchName(active) || matchIndex(active);
    }
    function handleActiveChange(newValue) {
      var _a;
      const newActiveTabItemProvider = matchActive(newValue);
      if (!newActiveTabItemProvider) {
        return;
      }
      tabItemList.forEach(({ setCurrent }) => setCurrent(false));
      newActiveTabItemProvider.setCurrent(true);
      (_a = swipe.value) == null ? void 0 : _a.to(newActiveTabItemProvider.index.value);
    }
    function handleSwipeChange(currentIndex) {
      var _a;
      const tabItem = tabItemList.find(({ index }) => index.value === currentIndex);
      const active = (_a = tabItem.name.value) != null ? _a : tabItem.index.value;
      call(props2["onUpdate:active"], active);
    }
    function getSwipe() {
      return swipe.value;
    }
    return {
      swipe,
      n: n$4,
      handleSwipeChange,
      getSwipe
    };
  }
});
__sfc__$4.render = __render__$4;
var stdin_default$3f = __sfc__$4;
withInstall(stdin_default$3f);
withPropsDefaultsSetter(stdin_default$3f, props$3);
const _TabsItemsComponent = stdin_default$3f;
var stdin_default$3e = stdin_default$3f;
var stdin_default$3d = {
  "--action-sheet-background": "var(--color-surface-container-low)",
  "--action-sheet-title-color": "#aaa",
  "--action-sheet-action-item-color": "#fff",
  "--action-sheet-border-radius": "2px",
  "--action-sheet-border-top": "none",
  "--action-sheet-title-padding": "10px 16px",
  "--action-sheet-title-font-size": "14px",
  "--action-sheet-action-item-height": "48px",
  "--action-sheet-action-item-padding": "0 18px",
  "--action-sheet-action-item-disabled-color": "var(--color-text-disabled)",
  "--action-sheet-icon-margin": "0 20px 0 0",
  "--action-sheet-icon-size": "24px"
};
var stdin_default$3c = {
  "--alert-padding": "16px",
  "--alert-border-radius": "4px",
  "--alert-icon-size": "22px",
  "--alert-icon-margin": "0 12px 0 0",
  "--alert-close-icon-size": "22px",
  "--alert-close-icon-margin": "2px 0 0 12px",
  "--alert-standard-info-text-color": "var(--color-on-info)",
  "--alert-standard-danger-text-color": "var(--color-on-danger)",
  "--alert-standard-success-text-color": "var(--color-on-success)",
  "--alert-standard-warning-text-color": "var(--color-on-warning)",
  "--alert-danger-background": "var(--color-danger)",
  "--alert-success-background": "var(--color-success)",
  "--alert-warning-background": "var(--color-warning)",
  "--alert-info-background": "var(--color-info)",
  "--alert-tonal-danger-background": "hsla(var(--hsl-danger), 0.12)",
  "--alert-tonal-success-background": "hsla(var(--hsl-success), 0.12)",
  "--alert-tonal-warning-background": "hsla(var(--hsl-warning), 0.12)",
  "--alert-tonal-info-background": "hsla(var(--hsl-info), 0.12)",
  "--alert-tonal-danger-text-color": "var(--color-danger)",
  "--alert-tonal-success-text-color": "var(--color-success)",
  "--alert-tonal-warning-text-color": "var(--color-warning)",
  "--alert-tonal-info-text-color": "var(--color-info)",
  "--alert-message-font-size": "14px",
  "--alert-title-font-size": "16px",
  "--alert-title-font-weight": "500",
  "--alert-message-margin-top": "4px",
  "--alert-message-line-height": "1.5",
  "--alert-title-line-height": "1.5"
};
var stdin_default$3b = {
  "--app-bar-color": "#272727",
  "--app-bar-title-padding": "0 12px",
  "--app-bar-title-font-size": "var(--font-size-lg)",
  "--app-bar-text-color": "#fff",
  "--app-bar-height": "54px",
  "--app-bar-left-gap": "6px",
  "--app-bar-right-gap": "6px",
  "--app-bar-border-radius": "4px",
  "--app-bar-font-size": "var(--font-size-lg)",
  "--app-bar-border-bottom": "thin solid var(--color-outline)"
};
var stdin_default$3a = {
  "--avatar-background-color": "#303030",
  "--avatar-border": "2px solid #1e1e1e",
  "--avatar-text-color": "#f5f5f5",
  "--avatar-border-radius": "4px",
  "--avatar-mini-size": "28px",
  "--avatar-small-size": "36px",
  "--avatar-normal-size": "48px",
  "--avatar-large-size": "64px",
  "--avatar-hover-transform": "scale(1.1)"
};
var stdin_default$39 = {
  "--avatar-group-offset": "-10px"
};
var stdin_default$38 = {
  "--back-top-right": "40px",
  "--back-top-bottom": "40px",
  "--back-top-button-size": "40px",
  "--back-top-button-border-radius": "50%"
};
var stdin_default$37 = {
  "--badge-default-color": "#555",
  "--badge-default-text-color": "#fff",
  "--badge-content-padding": "2px 6px",
  "--badge-content-border": "none",
  "--badge-content-border-radius": "100px",
  "--badge-content-font-size": "12px",
  "--badge-icon-size": "12px",
  "--badge-primary-color": "var(--color-primary)",
  "--badge-danger-color": "var(--color-danger)",
  "--badge-success-color": "var(--color-success)",
  "--badge-warning-color": "var(--color-warning)",
  "--badge-info-color": "var(--color-info)",
  "--badge-primary-text-color": "var(--color-on-primary)",
  "--badge-danger-text-color": "var(--color-on-danger)",
  "--badge-success-text-color": "var(--color-on-success)",
  "--badge-warning-text-color": "var(--color-on-warning)",
  "--badge-info-text-color": "var(--color-on-info)",
  "--badge-dot-width": "8px",
  "--badge-dot-height": "8px"
};
var stdin_default$36 = {
  "--bottom-navigation-height": "50px",
  "--bottom-navigation-variant-height": "66px",
  "--bottom-navigation-z-index": "1",
  "--bottom-navigation-background-color": "var(--color-surface-container-high)",
  "--bottom-navigation-border-color": "var(--color-outline)",
  "--bottom-navigation-fab-offset": "4px",
  "--bottom-navigation-fab-border-radius": "50%"
};
var stdin_default$35 = {
  "--bottom-navigation-item-inactive-color": "#BFBFBF",
  "--bottom-navigation-item-font-size": "var(--font-size-sm)",
  "--bottom-navigation-item-active-color": "var(--color-primary)",
  "--bottom-navigation-item-active-background-color": "var(--color-surface-container-high)",
  "--bottom-navigation-item-variant-active-background-color": "var(--color-primary-container)",
  "--bottom-navigation-item-variant-active-color": "var(--color-on-primary-container)",
  "--bottom-navigation-fab-border-radius": "50%",
  "--bottom-navigation-item-line-height": "1",
  "--bottom-navigation-item-icon-size": "22px",
  "--bottom-navigation-item-icon-margin-bottom": "5px",
  "--bottom-navigation-item-variant-icon-container-height": "30px",
  "--bottom-navigation-item-variant-icon-container-border-radius": "100px",
  "--bottom-navigation-item-variant-icon-container-max-width": "58px"
};
var stdin_default$34 = {
  "--breadcrumb-inactive-color": "#aaa",
  "--breadcrumb-active-color": "var(--color-primary)",
  "--breadcrumb-separator-margin": "0 10px",
  "--breadcrumb-separator-font-size": "14px"
};
var stdin_default$33 = {
  "--button-default-color": "#303030",
  "--button-default-text-color": "#fff",
  "--button-default-icon-container-color": "#303030",
  "--button-default-icon-color": "#fff",
  "--button-primary-text-color": "var(--color-on-primary)",
  "--button-danger-text-color": "var(--color-on-danger)",
  "--button-success-text-color": "var(--color-on-success)",
  "--button-warning-text-color": "var(--color-on-warning)",
  "--button-info-text-color": "var(--color-on-info)",
  "--button-primary-color": "var(--color-primary)",
  "--button-danger-color": "var(--color-danger)",
  "--button-success-color": "var(--color-success)",
  "--button-warning-color": "var(--color-warning)",
  "--button-info-color": "var(--color-info)",
  "--button-primary-icon-color": "var(--color-on-primary-container)",
  "--button-danger-icon-color": "var(--color-on-danger-container)",
  "--button-success-icon-color": "var(--color-on-success-container)",
  "--button-warning-icon-color": "var(--color-on-warning-container)",
  "--button-info-icon-color": "var(--color-on-info-container)",
  "--button-primary-icon-container-color": "var(--color-primary-container)",
  "--button-danger-icon-container-color": "var(--color-danger-container)",
  "--button-success-icon-container-color": "var(--color-success-container)",
  "--button-warning-icon-container-color": "var(--color-warning-container)",
  "--button-info-icon-container-color": "var(--color-info-container)",
  "--button-disabled-color": "var(--color-disabled)",
  "--button-disabled-text-color": "var(--color-text-disabled)",
  "--button-border-radius": "4px",
  "--button-mini-padding": "0 8px",
  "--button-small-padding": "0 12px",
  "--button-normal-padding": "0 16px",
  "--button-large-padding": "0 22px",
  "--button-round-padding": "6px",
  "--button-mini-height": "20px",
  "--button-small-height": "28px",
  "--button-normal-height": "36px",
  "--button-large-height": "44px",
  "--button-mini-font-size": "var(--font-size-xs)",
  "--button-small-font-size": "var(--font-size-sm)",
  "--button-normal-font-size": "var(--font-size-md)",
  "--button-large-font-size": "var(--font-size-lg)"
};
var stdin_default$32 = {
  "--card-title-color": "#ffffff",
  "--card-subtitle-color": "#aaaaaa",
  "--card-description-color": "#aaaaaa",
  "--card-padding": "0 0 15px 0",
  "--card-background": "var(--color-surface-container-highest)",
  "--card-filled-background": "var(--color-surface-container-highest)",
  "--card-outline-color": "var(--color-outline)",
  "--card-border-radius": "4px",
  "--card-image-width": "100%",
  "--card-row-image-width": "140px",
  "--card-image-height": "200px",
  "--card-row-height": "140px",
  "--card-title-font-size": "20px",
  "--card-title-padding": "0 12px",
  "--card-title-margin": "15px 0 0 0",
  "--card-title-row-margin": "12px 0",
  "--card-content-padding": "0 16px",
  "--card-content-margin": "16px 0 0 0",
  "--card-content-color": "var(--color-on-surface-variant)",
  "--card-content-font-size": "14px",
  "--card-content-row-margin": "16px 0 0 0",
  "--card-subtitle-font-size": "14px",
  "--card-subtitle-padding": "0 12px",
  "--card-subtitle-margin": "10px 0 0 0",
  "--card-subtitle-row-margin": "-8px 0 0 0",
  "--card-description-font-size": "14px",
  "--card-description-margin": "20px 0 0 0",
  "--card-description-padding": "0 13px",
  "--card-footer-padding": "0 12px",
  "--card-footer-right": "13px",
  "--card-footer-bottom": "9px",
  "--card-footer-margin": "30px 0 0 0",
  "--card-line-height": "22px",
  "--card-row-line-height": "1.5",
  "--card-floating-buttons-bottom": "16px",
  "--card-floating-buttons-right": "16px",
  "--card-floating-buttons-color": "#fff",
  "--card-close-button-icon-size": "24px",
  "--card-close-button-size": "56px",
  "--card-close-button-primary-color": "#212121",
  "--card-close-button-text-color": "#fff",
  "--card-close-button-border-radius": "50%"
};
var stdin_default$31 = {
  "--cell-description-color": "#aaa",
  "--cell-color": "var(--color-text)",
  "--cell-font-size": "var(--font-size-md)",
  "--cell-description-font-size": "var(--font-size-sm)",
  "--cell-description-margin-top": "4px",
  "--cell-padding": "10px 12px",
  "--cell-min-height": "40px",
  "--cell-border-color": "var(--color-outline)",
  "--cell-border-left": "12px",
  "--cell-border-right": "12px",
  "--cell-icon-right": "8px",
  "--cell-extra-left": "8px"
};
var stdin_default$30 = {
  "--checkbox-unchecked-color": "#fff",
  "--checkbox-text-color": "#fff",
  "--checkbox-checked-color": "var(--color-primary)",
  "--checkbox-disabled-color": "var(--color-text-disabled)",
  "--checkbox-error-color": "var(--color-danger)",
  "--checkbox-action-padding": "6px",
  "--checkbox-icon-size": "24px"
};
var stdin_default$2$ = {
  "--chip-default-color": "#555",
  "--chip-default-text-color": "#fff",
  "--chip-primary-text-color": "var(--color-on-primary-container)",
  "--chip-danger-text-color": "var(--color-on-danger-container)",
  "--chip-success-text-color": "var(--color-on-success-container)",
  "--chip-warning-text-color": "var(--color-on-warning-container)",
  "--chip-info-text-color": "var(--color-on-info-container)",
  "--chip-primary-color": "var(--color-primary-container)",
  "--chip-danger-color": "var(--color-danger-container)",
  "--chip-success-color": "var(--color-success-container)",
  "--chip-warning-color": "var(--color-warning-container)",
  "--chip-info-color": "var(--color-info-container)",
  "--chip-primary-plain-color": "var(--color-primary)",
  "--chip-danger-plain-color": "var(--color-danger)",
  "--chip-success-plain-color": "var(--color-success)",
  "--chip-warning-plain-color": "var(--color-warning)",
  "--chip-info-plain-color": "var(--color-info)",
  "--chip-border-radius": "2px",
  "--chip-normal-height": "32px",
  "--chip-large-height": "40px",
  "--chip-small-height": "24px",
  "--chip-mini-height": "16px",
  "--chip-round-radius": "100px",
  "--chip-normal-padding": "0 10px",
  "--chip-large-padding": "0 17px",
  "--chip-small-padding": "0 6px",
  "--chip-mini-padding": "0 4px",
  "--chip-text-normal-margin": "0 5px",
  "--chip-text-large-margin": "0 5px",
  "--chip-text-small-margin": "0 3px",
  "--chip-text-mini-margin": "0 2px",
  "--chip-mini-font-size": "var(--font-size-xs)",
  "--chip-small-font-size": "var(--font-size-sm)",
  "--chip-normal-font-size": "var(--font-size-md)",
  "--chip-large-font-size": "var(--font-size-lg)"
};
var stdin_default$2_ = {
  "--code-font-size": "14px",
  "--code-line-height": "1.7"
};
var stdin_default$2Z = {
  "--collapse-text-color": "#fff",
  "--collapse-background": "var(--color-surface-container-highest)",
  "--collapse-header-font-size": "var(--font-size-lg)",
  "--collapse-header-padding": "10px 12px",
  "--collapse-content-font-size": "var(--font-size-md)",
  "--collapse-content-padding": "0 12px 10px",
  "--collapse-item-margin-top": "16px",
  "--collapse-disable-color": "#bdbdbd",
  "--collapse-border-top": "thin solid var(--color-outline)"
};
var stdin_default$2Y = {
  "--countdown-text-color": "var(--color-text)",
  "--countdown-text-font-size": "var(--font-size-lg)"
};
var stdin_default$2X = {
  "--counter-padding": "0 4px",
  "--counter-font-color": "#fff",
  "--counter-background": "var(--color-primary)",
  "--counter-input-width": "28px",
  "--counter-input-margin": "0 4px",
  "--counter-input-font-size": "14px",
  "--counter-button-size": "28px",
  "--counter-button-text-color": "#fff",
  "--counter-button-icon-size": "100%",
  "--counter-disabled-color": "var(--color-disabled)",
  "--counter-disabled-opacity": "var(--opacity-disabled)",
  "--counter-error-color": "var(--color-danger)"
};
var stdin_default$2W = {
  "--date-picker-main-color": "#fff",
  "--date-picker-body-background-color": "#303030",
  "--day-picker-head-item-color": "#aaaaaa",
  "--year-picker-item-color": "#fff",
  "--date-picker-header-color": "#fff",
  "--date-picker-border-radius": "4px",
  "--date-picker-font-size": "var(--font-size-md)",
  "--date-picker-min-width": "290px",
  "--date-picker-title-hint-color": "#fff",
  "--date-picker-title-hint-font-size": "var(--font-size-md)",
  "--date-picker-title-height": "105px",
  "--date-picker-title-padding": "16px",
  "--date-picker-title-background": "var(--color-primary)",
  "--date-picker-title-color": "#fff",
  "--date-picker-title-year-font-size": "var(--font-size-md)",
  "--date-picker-title-year-font-weight": "500",
  "--date-picker-title-year-margin-bottom": "8px",
  "--date-picker-title-date-height": "48px",
  "--date-picker-title-date-font-size": "34px",
  "--date-picker-title-date-font-weight": "500",
  "--date-picker-title-date-range-font-size": "20px",
  "--date-picker-title-date-justify-content": "normal",
  "--date-picker-body-height": "280px",
  "--date-picker-body-padding": "0",
  "--date-picker-header-padding": "4px 16px",
  "--date-picker-actions-padding": "0 8px 12px 8px",
  "--date-picker-header-arrow-filter": "opacity(0.54)",
  "--month-picker-padding": "0 12px",
  "--month-picker-item-width": "33%",
  "--month-picker-item-height": "56px",
  "--month-picker-item-button-max-width": "140px",
  "--year-picker-padding": "0 12px",
  "--year-picker-item-width": "33%",
  "--year-picker-item-height": "56px",
  "--year-picker-item-button-max-width": "140px",
  "--day-picker-content-item-width": "14.28%",
  "--day-picker-content-item-font-size": "var(--font-size-sm)",
  "--day-picker-content-item-padding": "2px 0",
  "--day-picker-content-item-button-width": "32px",
  "--day-picker-content-item-button-height": "32px",
  "--day-picker-content-item-button-font-size": "var(--font-size-sm)",
  "--day-picker-head-item-padding": "8px 0",
  "--day-picker-head-item-font-weight": "600"
};
var stdin_default$2V = {
  "--dialog-title-color": "#fff",
  "--dialog-message-color": "#bbb",
  "--dialog-width": "280px",
  "--dialog-border-radius": "3px",
  "--dialog-title-padding": "20px 20px 0",
  "--dialog-message-padding": "12px 20px",
  "--dialog-message-line-height": "24px",
  "--dialog-message-font-size": "var(--font-size-md)",
  "--dialog-title-font-size": "var(--font-size-lg)",
  "--dialog-actions-padding": "0 12px 12px",
  "--dialog-button-margin-left": "6px",
  "--dialog-confirm-button-color": "var(--color-primary)",
  "--dialog-cancel-button-color": "var(--color-primary)",
  "--dialog-background": "var(--color-surface-container-low)"
};
var stdin_default$2U = {
  "--divider-text-color": "#aaa",
  "--divider-color": "var(--color-outline)",
  "--divider-text-margin": "8px 0",
  "--divider-text-padding": "0 8px",
  "--divider-inset": "72px"
};
var stdin_default$2T = {
  "--fab-top": "70px",
  "--fab-bottom": "16px",
  "--fab-left": "16px",
  "--fab-right": "16px",
  "--fab-trigger-size": "56px",
  "--fab-trigger-border-radius": "50%",
  "--fab-trigger-inactive-icon-size": "26px",
  "--fab-trigger-active-icon-size": "22px",
  "--fab-actions-padding": "10px 0",
  "--fab-action-margin": "6px",
  "--fab-action-size": "40px",
  "--fab-action-border-radius": "50%",
  "--fab-transition-standard-easing": "cubic-bezier(0.4, 0, 0.2, 1)"
};
var stdin_default$2S = {
  "--field-decorator-text-color": "#fff",
  "--field-decorator-blur-color": "rgb(255, 255, 255, .7)",
  "--field-decorator-error-color": "var(--color-danger)",
  "--field-decorator-focus-color": "var(--color-primary)",
  "--field-decorator-placeholder-size": "16px",
  "--field-decorator-icon-size": "20px",
  "--field-decorator-line-size": "1px",
  "--field-decorator-line-focus-size": "2px",
  "--field-decorator-line-border-radius": "4px",
  "--field-decorator-disabled-color": "var(--color-text-disabled)",
  "--field-decorator-standard-normal-margin-top": "22px",
  "--field-decorator-standard-normal-margin-bottom": "4px",
  "--field-decorator-standard-normal-icon-margin-top": "22px",
  "--field-decorator-standard-normal-icon-margin-bottom": "4px",
  "--field-decorator-standard-normal-non-hint-margin-top": "4px",
  "--field-decorator-standard-small-margin-top": "18px",
  "--field-decorator-standard-small-margin-bottom": "4px",
  "--field-decorator-standard-small-icon-margin-top": "18px",
  "--field-decorator-standard-small-icon-margin-bottom": "4px",
  "--field-decorator-standard-small-non-hint-margin-top": "2px",
  "--field-decorator-outlined-normal-margin-top": "16px",
  "--field-decorator-outlined-normal-margin-bottom": "16px",
  "--field-decorator-outlined-normal-padding-left": "16px",
  "--field-decorator-outlined-normal-padding-right": "16px",
  "--field-decorator-outlined-normal-placeholder-space": "4px",
  "--field-decorator-outlined-normal-icon-margin-top": "16px",
  "--field-decorator-outlined-normal-icon-margin-bottom": "16px",
  "--field-decorator-outlined-small-margin-top": "8px",
  "--field-decorator-outlined-small-margin-bottom": "8px",
  "--field-decorator-outlined-small-padding-left": "12px",
  "--field-decorator-outlined-small-padding-right": "12px",
  "--field-decorator-outlined-small-placeholder-space": "2px",
  "--field-decorator-outlined-small-icon-margin-top": "8px",
  "--field-decorator-outlined-small-icon-margin-bottom": "8px"
};
var stdin_default$2R = {
  "--floating-panel-z-index": "999",
  "--floating-panel-border-top": "none",
  "--floating-panel-border-radius": "0",
  "--floating-panel-background": "var(--color-surface-container-high)",
  "--floating-panel-header-height": "30px",
  "--floating-panel-toolbar-width": "20px",
  "--floating-panel-toolbar-height": "3px",
  "--floating-panel-toolbar-border-radius": "10px",
  "--floating-panel-toolbar-background": "#ddd",
  "--floating-panel-transition-timing-function": "cubic-bezier(0.18, 0.89, 0.32, 1.28)"
};
var stdin_default$2Q = {
  "--form-details-error-message-color": "var(--color-danger)",
  "--form-details-extra-message-color": "#888",
  "--form-details-margin-top": "6px",
  "--form-details-font-size": "12px",
  "--form-details-message-margin-right": "4px"
};
var stdin_default$2P = {
  "--hover-overlay-opacity": "var(--opacity-hover)",
  "--hover-overlay-focusing-opacity": "var(--opacity-focus)"
};
var stdin_default$2O = {
  "--icon-size": "20px"
};
var stdin_default$2N = {
  "--image-preview-swipe-indicators-text-color": "#ddd",
  "--image-preview-swipe-indicators-padding": "16px 0",
  "--image-preview-zoom-container-background": "#000",
  "--image-preview-close-icon-top": "14px",
  "--image-preview-close-icon-right": "14px",
  "--image-preview-extra-top": "14px",
  "--image-preview-extra-left": "14px",
  "--image-preview-close-icon-size": "22px",
  "--image-preview-close-icon-color": "#fff"
};
var stdin_default$2M = {
  "--index-bar-list-right": "0",
  "--index-bar-list-top": "50%",
  "--index-bar-list-left": "auto",
  "--index-bar-list-bottom": "auto",
  "--index-bar-list-transform": "translate(0, -50%)",
  "--index-bar-list-item-font-size": "var(--font-size-xs)",
  "--index-bar-list-item-color": "var(--color-primary)",
  "--index-bar-list-item-active-color": "var(--color-danger)",
  "--index-bar-list-item-height": "14px",
  "--index-bar-list-item-padding": "0 10px"
};
var stdin_default$2L = {
  "--input-input-height": "24px",
  "--input-input-font-size": "16px",
  "--input-textarea-height": "auto"
};
var stdin_default$2K = {
  "--link-default-color": "#fff",
  "--link-primary-color": "var(--color-primary)",
  "--link-danger-color": "var(--color-danger)",
  "--link-success-color": "var(--color-success)",
  "--link-warning-color": "var(--color-warning)",
  "--link-info-color": "var(--color-info)",
  "--link-disabled-color": "var(--color-text-disabled)",
  "--link-font-size": "var(--font-size-md)",
  "--link-focus-opacity": "0.8"
};
var stdin_default$2J = {
  "--list-loading-height": "50px",
  "--list-finished-height": "50px",
  "--list-error-height": "50px",
  "--list-loading-color": "#888",
  "--list-finished-color": "#888",
  "--list-error-color": "#888",
  "--list-loading-font-size": "var(--font-size-md)",
  "--list-finished-font-size": "var(--font-size-md)",
  "--list-error-font-size": "var(--font-size-md)"
};
var stdin_default$2I = {
  "--loading-color": "var(--color-primary)",
  "--loading-opacity": "0.38",
  "--loading-desc-margin": "8px 0 0",
  "--loading-desc-color": "var(--color-primary)"
};
var stdin_default$2H = {
  "--loading-bar-color": "var(--color-primary)",
  "--loading-bar-error-color": "var(--color-danger)",
  "--loading-bar-height": "3px"
};
var stdin_default$2G = {
  "--menu-background-color": "#272727",
  "--menu-border-radius": "2px"
};
var stdin_default$2F = {
  "--menu-option-text-color": "#fff",
  "--menu-option-normal-height": "38px",
  "--menu-option-small-height": "30px",
  "--menu-option-mini-height": "24px",
  "--menu-option-large-height": "46px",
  "--menu-option-padding": "0 12px",
  "--menu-option-normal-font-size": "var(--font-size-md)",
  "--menu-option-small-font-size": "var(--font-size-sm)",
  "--menu-option-mini-font-size": "var(--font-size-xs)",
  "--menu-option-large-font-size": "var(--font-size-lg)",
  "--menu-option-selected-background": "var(--color-primary)",
  "--menu-option-disabled-color": "var(--color-text-disabled)"
};
var stdin_default$2E = {
  "--menu-select-menu-background-color": "#272727",
  "--menu-select-menu-max-height": "278px",
  "--menu-select-menu-padding": "0",
  "--menu-select-menu-border-radius": "2px"
};
var stdin_default$2D = {
  "--option-text-color": "#fff",
  "--option-height": "38px",
  "--option-padding": "0 12px",
  "--option-font-size": "16px",
  "--option-selected-background": "var(--field-decorator-focus-color)",
  "--option-disabled-color": "var(--color-text-disabled)"
};
var stdin_default$2C = {
  "--overlay-background-color": "rgba(0, 0, 0, 0.6)"
};
var stdin_default$2B = {
  "--pagination-text-color": "#fff",
  "--pagination-hover-bg-color": "rgba(255, 255, 255, .15)",
  "--pagination-item-background": "#303030",
  "--pagination-font-size": "var(--font-size-md)",
  "--pagination-active-color": "var(--color-on-primary)",
  "--pagination-active-bg-color": "var(--color-primary)",
  "--pagination-total-margin": "0 12px",
  "--pagination-total-line-height": "24px",
  "--pagination-item-width": "32px",
  "--pagination-item-height": "32px",
  "--pagination-item-margin": "0 6px",
  "--pagination-item-border-radius": "4px",
  "--pagination-item-simple-border-radius": "50%",
  "--pagination-input-width": "32px",
  "--pagination-disabled-color": "var(--color-text-disabled)",
  "--pagination-bg-disabled-color": "var(--color-disabled)",
  "--pagination-size-line-height": "24px",
  "--pagination-size-padding": "0 6px"
};
var stdin_default$2A = {
  "--paper-background": "var(--color-surface-container-highest)",
  "--paper-border-radius": "4px"
};
var stdin_default$2z = {
  "--picker-background": "#1e1e1e",
  "--picker-cancel-button-text-color": "#aaa",
  "--picker-title-text-color": "#fff",
  "--picker-option-text-color": "#fff",
  "--picker-mask-background-image": "linear-gradient(180deg, hsla(0, 0%, 12%, 0.9), hsla(0, 0%, 12%, 0.4)), linear-gradient(0deg, hsla(0, 0%, 12%, 0.9), hsla(0, 0%, 12%, 0.4))",
  "--picker-toolbar-height": "44px",
  "--picker-confirm-button-text-color": "var(--color-primary)",
  "--picker-picked-border": "1px solid var(--color-outline)",
  "--picker-title-font-size": "var(--font-size-lg)",
  "--picker-option-font-size": "var(--font-size-lg)",
  "--picker-toolbar-padding": "0 4px"
};
var stdin_default$2y = {
  "--popup-content-background-color": "var(--color-surface-container-low)",
  "--popup-overlay-background-color": "rgba(0, 0, 0, 0.6)"
};
var stdin_default$2x = {
  "--progress-label-color": "#fff",
  "--progress-font-size": "var(--font-size-sm)",
  "--progress-track-color": "#d8d8d8",
  "--progress-background": "var(--color-primary)",
  "--progress-default-color": "#f5f5f5",
  "--progress-primary-color": "var(--color-primary)",
  "--progress-danger-color": "var(--color-danger)",
  "--progress-success-color": "var(--color-success)",
  "--progress-warning-color": "var(--color-warning)",
  "--progress-info-color": "var(--color-info)",
  "--progress-linear-border-radius": "0px"
};
var stdin_default$2w = {
  "--pull-refresh-background": "#303030",
  "--pull-refresh-size": "40px",
  "--pull-refresh-color": "var(--color-primary)",
  "--pull-refresh-success-color": "var(--color-success)",
  "--pull-refresh-icon-size": "25px"
};
var stdin_default$2v = {
  "--radio-unchecked-color": "#fff",
  "--radio-text-color": "#fff",
  "--radio-checked-color": "var(--color-primary)",
  "--radio-disabled-color": "var(--color-text-disabled)",
  "--radio-error-color": "var(--color-danger)",
  "--radio-icon-size": "24px",
  "--radio-action-padding": "6px"
};
var stdin_default$2u = {
  "--rate-color": "var(--color-text)",
  "--rate-size": "24px",
  "--rate-disabled-color": "var(--color-text-disabled)",
  "--rate-error-color": "var(--color-danger)",
  "--rate-action-padding": "4px",
  "--rate-primary-color": "var(--color-primary)"
};
var stdin_default$2t = {
  "--result-background": "#303030",
  "--result-title-color": "#ffffff",
  "--result-description-color": "#aaaaaa",
  "--result-question-color": "#7f8e96",
  "--result-question-border-color": "rgba(151,194,216,0.3)",
  "--result-empty-color": "#adadad",
  "--result-empty-border-color": "rgba(232,229,229,0.3)",
  "--result-padding": "24px",
  "--result-border-radius": "3px",
  "--result-title-font-size": "32px",
  "--result-title-margin": "15px 0 0 0",
  "--result-image-size": "80px",
  "--result-title-font-weight": "500",
  "--result-description-margin": "10px 0 0 0",
  "--result-description-font-size": "14px",
  "--result-description-line-height": "1.6",
  "--result-info-color": "var(--color-info)",
  "--result-info-border-color": "rgba(0, 175, 239, 0.3)",
  "--result-success-color": "var(--color-success)",
  "--result-success-border-color": "rgba(0, 196, 143, 0.3)",
  "--result-error-color": "var(--color-danger)",
  "--result-error-border-color": "rgba(244, 67, 54, 0.3)",
  "--result-warning-color": "var(--color-warning)",
  "--result-warning-border-color": "rgba(255, 159, 0, 0.3)"
};
var stdin_default$2s = {
  "--ripple-cubic-bezier": "cubic-bezier(0.68, 0.01, 0.62, 0.6)",
  "--ripple-color": "currentColor"
};
var stdin_default$2r = {
  "--select-scroller-background": "#272727",
  "--select-scroller-padding": "6px 0",
  "--select-scroller-max-height": "278px",
  "--select-scroller-border-radius": "2px",
  "--select-chip-margin": "5px 5px 0",
  "--select-arrow-size": "20px",
  "--select-standard-menu-margin": `calc(var(--field-decorator-placeholder-size) * 0.75 + 12px) 0 0 0`,
  "--select-label-font-size": "16px"
};
var stdin_default$2q = {
  "--skeleton-card-background-color": "hsla(0,0%,100%,.12)",
  "--skeleton-animation-background": `linear-gradient(
        90deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.05),hsla(0,0%,100%,0))
      `,
  "--skeleton-avatar-background-color": "hsla(0,0%,100%,.12)",
  "--skeleton-title-background-color": "hsla(0,0%,100%,.12)",
  "--skeleton-content-padding": "16px",
  "--skeleton-card-height": "160px",
  "--skeleton-card-border-radius": "4px",
  "--skeleton-card-margin-bottom": "16px",
  "--skeleton-avatar-size": "34px",
  "--skeleton-avatar-border-radius": "50%",
  "--skeleton-avatar-margin-right": "16px",
  "--skeleton-title-width": "50%",
  "--skeleton-title-border-radius": "10px",
  "--skeleton-row-height": "12px",
  "--skeleton-row-border-radius": "10px",
  "--skeleton-row-margin-top": "10px"
};
var stdin_default$2p = {
  "--slider-error-color": "var(--color-danger)",
  "--slider-track-background": "#bdbdbd",
  "--slider-track-height": "2px",
  "--slider-track-border-radius": "0",
  "--slider-track-fill-border-radius": "0",
  "--slider-track-fill-background": "var(--color-primary)",
  "--slider-thumb-block-background": "var(--color-primary)",
  "--slider-thumb-ripple-background": "var(--color-primary)",
  "--slider-thumb-label-background": "var(--color-primary)",
  "--slider-thumb-label-font-size": "var(--font-size-sm)",
  "--slider-thumb-label-text-color": "var(--color-on-primary)",
  "--slider-thumb-size": "12px",
  "--slider-disabled-opacity": "var(--opacity-disabled)"
};
var stdin_default$2o = {
  "--snackbar-width": "256px",
  "--snackbar-color": "rgba(255, 255, 255, 0.87)",
  "--snackbar-border-radius": "4px",
  "--snackbar-background": "#333",
  "--snackbar-font-size": "var(--font-size-md)",
  "--snackbar-margin": "6px 24px",
  "--snackbar-border-color": "currentColor",
  "--snackbar-success-background": "var(--color-success)",
  "--snackbar-info-background": "var(--color-info)",
  "--snackbar-error-background": "var(--color-danger)",
  "--snackbar-warning-background": "var(--color-warning)",
  "--snackbar-content-padding": "14px 16px",
  "--snackbar-action-margin": "0 8px",
  "--snackbar-vertical-action-margin": "0 8px 8px 0",
  "--snackbar-icon-margin": "0 8px"
};
var stdin_default$2n = {
  "--space-size-mini-y": "4px",
  "--space-size-mini-x": "4px",
  "--space-size-small-y": "6px",
  "--space-size-small-x": "6px",
  "--space-size-normal-y": "8px",
  "--space-size-normal-x": "12px",
  "--space-size-large-y": "12px",
  "--space-size-large-x": "20px"
};
var stdin_default$2m = {
  "--step-content-color": "rgba(255, 255, 255, .38)",
  "--step-content-active-color": "#fff",
  "--step-line-background": "#fff",
  "--step-tag-size": "20px",
  "--step-tag-background": "#9e9e9e",
  "--step-tag-font-size": "var(--font-size-md)",
  "--step-tag-color": "var(--color-on-primary)",
  "--step-tag-active-color": "var(--color-primary)",
  "--step-tag-margin": "4px 0",
  "--step-tag-icon-size": "var(--font-size-lg)",
  "--step-content-font-size": "var(--font-size-md)",
  "--step-line-gap": "8px",
  "--step-vertical-tag-margin": "0 4px",
  "--step-vertical-min-height": "50px"
};
var stdin_default$2l = {
  "--swipe-indicator-color": "#fff",
  "--swipe-indicators-offset": "10px",
  "--swipe-indicator-offset": "4px",
  "--swipe-navigation-z-index": "9",
  "--swipe-navigation-button-width": "36px",
  "--swipe-navigation-button-height": "36px",
  "--swipe-navigation-button-border-radius": "50%",
  "--swipe-navigation-icon-size": "20px",
  "--swipe-navigation-prev-left": "8px",
  "--swipe-navigation-next-right": "8px",
  "--swipe-navigation-prev-top": "8px",
  "--swipe-navigation-next-bottom": "8px"
};
var stdin_default$2k = {
  "--switch-track-background": "#727272",
  "--switch-handle-background": "#727272",
  "--switch-track-active-background": "var(--color-primary)",
  "--switch-track-error-background": "var(--color-danger)",
  "--switch-ripple-color": "var(--color-primary)",
  "--switch-handle-color": "var(--color-on-primary)",
  "--switch-handle-active-color": "var(--color-on-primary)",
  "--switch-handle-active-background": "var(--color-primary)",
  "--switch-handle-error-background": "var(--color-danger)",
  "--switch-disabled-opacity": "var(--opacity-disabled)",
  "--switch-variant-width": "52px",
  "--switch-variant-height": "32px",
  "--switch-variant-track-background": "var(--color-surface-container-highest)",
  "--switch-variant-handle-width": "24px",
  "--switch-variant-handle-height": "24px",
  "--switch-variant-track-border-color": "rgb(255, 255, 255, .7)",
  "--switch-variant-handle-background": "rgb(255, 255, 255, .7)",
  "--switch-variant-handle-color": "var(--color-primary)",
  "--switch-variant-handle-active-color": "var(--color-primary)",
  "--switch-variant-handle-active-background": "var(--color-on-primary)",
  "--switch-width": "40px",
  "--switch-height": "24px",
  "--switch-track-width": "38px",
  "--switch-track-height": "14.4px",
  "--switch-track-border-radius": "calc(20px * 2 / 3)",
  "--switch-handle-width": "20px",
  "--switch-handle-height": "20px",
  "--switch-ripple-size": "40px",
  "--switch-ripple-left": "-10px",
  "--switch-ripple-active-left": "10px",
  "--switch-loading-size": "16px",
  "--switch-variant-ripple-left": "-4px",
  "--switch-variant-ripple-active-left": "16px"
};
var stdin_default$2j = {
  "--tab-inactive-color": "rgba(255, 255, 255, .65)",
  "--tab-padding": "12px",
  "--tab-active-color": "var(--color-primary)",
  "--tab-disabled-color": "var(--color-text-disabled)",
  "--tab-font-size": "var(--font-size-md)",
  "--tab-font-weight": "400",
  "--tab-active-font-size": "var(--font-size-md)",
  "--tab-active-font-weight": "400"
};
var stdin_default$2i = {
  "--table-background": "#303030",
  "--table-thead-th-text-color": "rgba(255, 255, 255, 0.6)",
  "--table-thead-th-text-align": "left",
  "--table-tbody-td-text-color": "#fff",
  "--table-tbody-tr-hover-background": "#4c4b4b",
  "--table-border-radius": "2px",
  "--table-thead-border-bottom": "thin solid var(--color-outline)",
  "--table-thead-th-font-size": "14px",
  "--table-thead-tr-border-bottom": "thin solid var(--color-outline)",
  "--table-tbody-tr-border-bottom": "thin solid var(--color-outline)",
  "--table-tbody-td-font-size": "16px",
  "--table-tbody-td-text-align": "left",
  "--table-row-height": "46px",
  "--table-row-padding": "0 16px",
  "--table-footer-border-top": "thin solid var(--color-outline)"
};
var stdin_default$2h = {
  "--tabs-background": "#1e1e1e",
  "--tabs-item-horizontal-height": "44px",
  "--tabs-item-vertical-height": "66px",
  "--tabs-radius": "2px",
  "--tabs-padding": "12px",
  "--tabs-indicator-size": "2px",
  "--tabs-indicator-border-radius": "0",
  "--tabs-indicator-background": "var(--color-primary)",
  "--tabs-indicator-inner-size": "100%"
};
var stdin_default$2g = {
  "--time-picker-clock-container-background": "#545454",
  "--time-picker-body-background": "#303030",
  "--time-picker-clock-item-disable-color": "#fff",
  "--time-picker-clock-item-disable-background": "#aaaaaa",
  "--time-picker-clock-item-text-color": "#fff",
  "--time-picker-border-radius": "4px",
  "--time-picker-font-size": "var(--font-size-md)",
  "--time-picker-min-width": "290px",
  "--time-picker-title-height": "105px",
  "--time-picker-title-padding": "16px",
  "--time-picker-title-margin-bottom": "8px",
  "--time-picker-title-color": "#fff",
  "--time-picker-title-background": "var(--color-primary)",
  "--time-picker-title-hint-color": "#fff",
  "--time-picker-title-hint-font-size": "14px",
  "--time-picker-title-inactive-opacity": "0.6",
  "--time-picker-title-time-font-size": "50px",
  "--time-picker-title-time-margin": "0 5px",
  "--time-picker-title-time-border-radius": "0",
  "--time-picker-title-time-padding": "0",
  "--time-picker-title-time-background": "transparent",
  "--time-picker-title-time-active-background": "transparent",
  "--time-picker-title-ampm-button-active-background": "transparent",
  "--time-picker-title-ampm-margin-left": "10px",
  "--time-picker-title-ampm-border-radius": "0",
  "--time-picker-title-ampm-border": "none",
  "--time-picker-title-ampm-button-padding": "2px",
  "--time-picker-clock-left": "27px",
  "--time-picker-clock-right": "27px",
  "--time-picker-clock-top": "27px",
  "--time-picker-clock-bottom": "27px",
  "--time-picker-clock-container-width": "256px",
  "--time-picker-clock-container-height": "256px",
  "--time-picker-clock-hand-height": "calc(50% - 4px)",
  "--time-picker-clock-hand-width": "2px",
  "--time-picker-clock-hand-bottom": "50%",
  "--time-picker-clock-hand-left": "calc(50% - 1px)",
  "--time-picker-clock-hand-background": "var(--color-primary)",
  "--time-picker-clock-hand-border-color": "var(--color-primary)",
  "--time-picker-clock-hand-before-width": "10px",
  "--time-picker-clock-hand-before-height": "10px",
  "--time-picker-clock-hand-before-border-width": "2px",
  "--time-picker-clock-hand-after-width": "4px",
  "--time-picker-clock-hand-after-height": "4px",
  "--time-picker-clock-item-height": "32px",
  "--time-picker-clock-item-width": "32px",
  "--time-picker-clock-item-active-background": "var(--color-primary)",
  "--time-picker-clock-item-active-color": "var(--color-on-primary)",
  "--time-picker-inner-left": "36px",
  "--time-picker-inner-right": "36px",
  "--time-picker-inner-top": "36px",
  "--time-picker-inner-bottom": "36px",
  "--time-picker-body-height": "288px",
  "--time-picker-actions-padding": "0 8px 12px 8px",
  "--time-picker-title-time-container-justify-content": "flex-end"
};
var stdin_default$2f = {
  "--tooltip-opacity": "0.9",
  "--tooltip-border-radius": "4px",
  "--tooltip-font-size": "14px",
  "--tooltip-padding": "8px 16px",
  "--tooltip-offset": "10px",
  "--tooltip-default-color": "#616161",
  "--tooltip-primary-color": "var(--color-primary)",
  "--tooltip-info-color": "var(--color-info)",
  "--tooltip-success-color": "var(--color-success)",
  "--tooltip-warning-color": "var(--color-warning)",
  "--tooltip-danger-color": "var(--color-danger)",
  "--tooltip-default-text-color": "#fff",
  "--tooltip-primary-text-color": "var(--color-on-primary)",
  "--tooltip-info-text-color": "var(--color-on-info)",
  "--tooltip-success-text-color": "var(--color-on-success)",
  "--tooltip-warning-text-color": "var(--color-on-warning)",
  "--tooltip-danger-text-color": "var(--color-on-danger)"
};
var stdin_default$2e = {
  "--uploader-action-background": "#303030",
  "--uploader-action-icon-color": "#fff",
  "--uploader-file-name-background": "#303030",
  "--uploader-file-name-color": "#aaa",
  "--uploader-file-cover-background": "#303030",
  "--uploader-action-icon-size": "24px",
  "--uploader-action-margin": "0 10px 10px 0",
  "--uploader-file-size": "80px",
  "--uploader-file-margin": "0 10px 10px 0",
  "--uploader-file-name-font-size": "12px",
  "--uploader-file-name-padding": "10px",
  "--uploader-file-text-align": "center",
  "--uploader-file-border-radius": "0",
  "--uploader-file-close-background": "rgba(0, 0, 0, 0.3)",
  "--uploader-file-close-size": "24px",
  "--uploader-file-close-icon-font-size": "14px",
  "--uploader-file-close-icon-color": "#fff",
  "--uploader-file-cover-fit": "cover",
  "--uploader-preview-video-width": "100vw",
  "--uploader-preview-video-height": "100vw",
  "--uploader-file-indicator-height": "4px",
  "--uploader-file-indicator-normal-color": "var(--color-disabled)",
  "--uploader-file-indicator-success-color": "var(--color-success)",
  "--uploader-file-indicator-error-color": "var(--color-danger)",
  "--uploader-file-progress-color": "var(--color-primary)",
  "--uploader-disabled-color": "var(--color-disabled)",
  "--uploader-disabled-text-color": "var(--color-text-disabled)",
  "--uploader-loading-background": "linear-gradient(90deg, hsla(0, 0%, 100%, 0), hsla(0, 0%, 100%, 0.3), hsla(0, 0%, 100%, 0))"
};
var stdin_default$2d = {
  "--watermark-content-color": "#ffffff"
};
var __defProp$3 = Object.defineProperty;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key3, value) => key3 in obj ? __defProp$3(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$3.call(b, prop))
      __defNormalProp$3(a, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b)) {
      if (__propIsEnum$3.call(b, prop))
        __defNormalProp$3(a, prop, b[prop]);
    }
  return a;
};
var stdin_default$2c = __spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3({
  "--color-scheme": "dark",
  "--font-size-xs": "10px",
  "--font-size-sm": "12px",
  "--font-size-md": "14px",
  "--font-size-lg": "16px",
  "--icon-size-xs": "16px",
  "--icon-size-sm": "18px",
  "--icon-size-md": "20px",
  "--icon-size-lg": "22px",
  "--hsl-body": "0, 0%, 12%",
  "--color-body": "hsla(var(--hsl-body), 1)",
  "--hsl-text": "0, 0%, 100%",
  "--color-text": "hsla(var(--hsl-text), 1)",
  "--hsl-primary": "224, 99%, 64%",
  "--color-primary": "hsla(var(--hsl-primary), 1)",
  "--hsl-info": "197, 87%, 50%",
  "--color-info": "hsla(var(--hsl-info), 1)",
  "--hsl-success": "162, 85%, 42%",
  "--color-success": "hsla(var(--hsl-success), 1)",
  "--hsl-warning": "32, 100%, 50%",
  "--color-warning": "hsla(var(--hsl-warning), 1)",
  "--hsl-danger": "1, 83%, 63%",
  "--color-danger": "hsla(var(--hsl-danger), 1)",
  "--hsl-on-primary": "0, 0%, 100%",
  "--color-on-primary": "hsla(var(--hsl-on-primary), 1)",
  "--hsl-on-info": "0, 0%, 100%",
  "--color-on-info": "hsla(var(--hsl-on-info), 1)",
  "--hsl-on-success": "0, 0%, 100%",
  "--color-on-success": "hsla(var(--hsl-on-success), 1)",
  "--hsl-on-warning": "0, 0%, 100%",
  "--color-on-warning": "hsla(var(--hsl-on-warning), 1)",
  "--hsl-on-danger": "0, 0%, 100%",
  "--color-on-danger": "hsla(var(--hsl-on-danger), 1)",
  "--hsl-primary-container": "224, 99%, 64%",
  "--color-primary-container": "hsla(var(--hsl-primary-container), 1)",
  "--hsl-info-container": "197, 87%, 50%",
  "--color-info-container": "hsla(var(--hsl-info-container), 1)",
  "--hsl-success-container": "162, 85%, 42%",
  "--color-success-container": "hsla(var(--hsl-success-container), 1)",
  "--hsl-warning-container": "32, 100%, 50%",
  "--color-warning-container": "hsla(var(--hsl-warning-container), 1)",
  "--hsl-danger-container": "1, 83%, 63%",
  "--color-danger-container": "hsla(var(--hsl-danger-container), 1)",
  "--hsl-on-primary-container": "0, 0%, 100%",
  "--color-on-primary-container": "hsla(var(--hsl-on-primary-container), 1)",
  "--hsl-on-info-container": "0, 0%, 100%",
  "--color-on-info-container": "hsla(var(--hsl-on-info-container), 1)",
  "--hsl-on-success-container": "0, 0%, 100%",
  "--color-on-success-container": "hsla(var(--hsl-on-success-container), 1)",
  "--hsl-on-warning-container": "0, 0%, 100%",
  "--color-on-warning-container": "hsla(var(--hsl-on-warning-container), 1)",
  "--hsl-on-danger-container": "0, 0%, 100%",
  "--color-on-danger-container": "hsla(var(--hsl-on-danger-container), 1)",
  "--hsl-disabled": "0, 0%, 25%",
  "--color-disabled": "hsla(var(--hsl-disabled), 1)",
  "--hsl-text-disabled": "0, 0%, 46%",
  "--color-text-disabled": "hsla(var(--hsl-text-disabled), 1)",
  "--hsl-surface-container": "0, 0%, 12%",
  "--color-surface-container": "hsla(var(--hsl-surface-container), 1)",
  "--hsl-surface-container-low": "0, 0%, 12%",
  "--color-surface-container-low": "hsla(var(--hsl-surface-container-low), 1)",
  "--hsl-surface-container-high": "0, 0%, 15%",
  "--color-surface-container-high": "hsla(var(--hsl-surface-container-high), 1)",
  "--hsl-surface-container-highest": "0, 0%, 19%",
  "--color-surface-container-highest": "hsla(var(--hsl-surface-container-highest), 1)",
  "--hsl-inverse-surface": "0, 0%, 100%",
  "--color-inverse-surface": "hsla(var(--hsl-inverse-surface), 1)",
  "--hsl-outline": "0, 0%, 100%",
  "--color-outline": "hsla(var(--hsl-outline), 0.2)",
  "--hsl-on-surface-variant": "0, 0%, 100%",
  "--color-on-surface-variant": "hsla(var(--hsl-on-surface-variant), 1)",
  "--opacity-disabled": "0.6",
  "--opacity-hover": "0.15",
  "--opacity-focus": "0.2",
  "--cubic-bezier": "cubic-bezier(0.25, 0.8, 0.5, 1)",
  "--shadow-key-umbra-opacity": "rgba(0, 0, 0, 0.2)",
  "--shadow-key-penumbra-opacity": "rgba(0, 0, 0, 0.14)",
  "--shadow-key-ambient-opacity": "rgba(0, 0, 0, 0.12)"
}, stdin_default$33), stdin_default$3c), stdin_default$31), stdin_default$32), stdin_default$2g), stdin_default$2W), stdin_default$2q), stdin_default$2h), stdin_default$2j), stdin_default$2y), stdin_default$2V), stdin_default$3d), stdin_default$2$), stdin_default$37), stdin_default$2e), stdin_default$2Z), stdin_default$2w), stdin_default$2k), stdin_default$2m), stdin_default$2B), stdin_default$2i), stdin_default$2S), stdin_default$2v), stdin_default$30), stdin_default$2U), stdin_default$2z), stdin_default$3b), stdin_default$35), stdin_default$2G), stdin_default$2t), stdin_default$34), stdin_default$3a), stdin_default$2K), stdin_default$2x), stdin_default$2D), stdin_default$2d), stdin_default$2E), stdin_default$2F), stdin_default$39), stdin_default$38), stdin_default$36), stdin_default$2Y), stdin_default$2X), stdin_default$2T), stdin_default$2R), stdin_default$2Q), stdin_default$2P), stdin_default$2O), stdin_default$2N), stdin_default$2M), stdin_default$2L), stdin_default$2J), stdin_default$2I), stdin_default$2H), stdin_default$2C), stdin_default$2A), stdin_default$2u), stdin_default$2s), stdin_default$2p), stdin_default$2o), stdin_default$2n), stdin_default$2l), stdin_default$2f), stdin_default$2r), stdin_default$2_);
var stdin_default$2b = {
  "--action-sheet-background": "var(--color-surface-container-high)",
  "--action-sheet-title-color": "var(--color-on-surface-variant)",
  "--action-sheet-action-item-color": "var(--color-inverse-surface)",
  "--action-sheet-border-radius": "0px",
  "--action-sheet-border-top": "none",
  "--action-sheet-title-padding": "10px 16px",
  "--action-sheet-title-font-size": "14px",
  "--action-sheet-action-item-height": "48px",
  "--action-sheet-action-item-padding": "0 18px",
  "--action-sheet-action-item-disabled-color": "var(--color-text-disabled)",
  "--action-sheet-icon-margin": "0 20px 0 0",
  "--action-sheet-icon-size": "24px"
};
var stdin_default$2a = {
  "--alert-padding": "16px",
  "--alert-border-radius": "4px",
  "--alert-icon-size": "22px",
  "--alert-icon-margin": "0 12px 0 0",
  "--alert-close-icon-size": "22px",
  "--alert-close-icon-margin": "2px 0 0 12px",
  "--alert-standard-info-text-color": "var(--color-on-info)",
  "--alert-standard-danger-text-color": "var(--color-on-danger)",
  "--alert-standard-success-text-color": "var(--color-on-success)",
  "--alert-standard-warning-text-color": "var(--color-on-warning)",
  "--alert-danger-background": "var(--color-danger)",
  "--alert-success-background": "var(--color-success)",
  "--alert-warning-background": "var(--color-warning)",
  "--alert-info-background": "var(--color-info)",
  "--alert-tonal-danger-background": "hsla(var(--hsl-danger), 0.12)",
  "--alert-tonal-success-background": "hsla(var(--hsl-success), 0.12)",
  "--alert-tonal-warning-background": "hsla(var(--hsl-warning), 0.12)",
  "--alert-tonal-info-background": "hsla(var(--hsl-info), 0.12)",
  "--alert-tonal-danger-text-color": "var(--color-danger)",
  "--alert-tonal-success-text-color": "var(--color-success)",
  "--alert-tonal-warning-text-color": "var(--color-warning)",
  "--alert-tonal-info-text-color": "var(--color-info)",
  "--alert-message-font-size": "14px",
  "--alert-title-font-size": "16px",
  "--alert-title-font-weight": "500",
  "--alert-message-margin-top": "4px",
  "--alert-message-line-height": "1.5",
  "--alert-title-line-height": "1.5"
};
var stdin_default$29 = {
  "--app-bar-color": "#211F26",
  "--app-bar-text-color": "var(--color-inverse-surface)",
  "--app-bar-title-padding": "0 12px",
  "--app-bar-title-font-size": "var(--font-size-lg)",
  "--app-bar-height": "54px",
  "--app-bar-left-gap": "6px",
  "--app-bar-right-gap": "6px",
  "--app-bar-border-radius": "4px",
  "--app-bar-font-size": "var(--font-size-lg)",
  "--app-bar-border-bottom": "thin solid var(--color-outline)"
};
var stdin_default$28 = {
  "--avatar-text-color": "#000",
  "--avatar-background-color": "var(--color-primary)",
  "--avatar-border-radius": "4px",
  "--avatar-mini-size": "28px",
  "--avatar-small-size": "36px",
  "--avatar-normal-size": "48px",
  "--avatar-large-size": "64px",
  "--avatar-border": "2px solid #fff",
  "--avatar-hover-transform": "scale(1.1)"
};
var stdin_default$27 = {
  "--avatar-group-offset": "-10px"
};
var stdin_default$26 = {
  "--back-top-button-border-radius": "12px",
  "--back-top-right": "40px",
  "--back-top-bottom": "40px",
  "--back-top-button-size": "40px"
};
var stdin_default$25 = {
  "--badge-default-color": "#3B383E",
  "--badge-default-text-color": "#fff",
  "--badge-content-padding": "2px 6px",
  "--badge-content-border": "none",
  "--badge-content-border-radius": "100px",
  "--badge-content-font-size": "12px",
  "--badge-icon-size": "12px",
  "--badge-primary-color": "var(--color-primary)",
  "--badge-danger-color": "var(--color-danger)",
  "--badge-success-color": "var(--color-success)",
  "--badge-warning-color": "var(--color-warning)",
  "--badge-info-color": "var(--color-info)",
  "--badge-primary-text-color": "var(--color-on-primary)",
  "--badge-danger-text-color": "var(--color-on-danger)",
  "--badge-success-text-color": "var(--color-on-success)",
  "--badge-warning-text-color": "var(--color-on-warning)",
  "--badge-info-text-color": "var(--color-on-info)",
  "--badge-dot-width": "8px",
  "--badge-dot-height": "8px"
};
var stdin_default$24 = {
  "--bottom-navigation-background-color": "var(--color-surface-container)",
  "--bottom-navigation-height": "50px",
  "--bottom-navigation-variant-height": "66px",
  "--bottom-navigation-z-index": "1",
  "--bottom-navigation-border-color": "var(--color-outline)",
  "--bottom-navigation-fab-offset": "4px",
  "--bottom-navigation-fab-border-radius": "50%"
};
var stdin_default$23 = {
  "--bottom-navigation-item-active-background-color": "#4A4458",
  "--bottom-navigation-item-inactive-color": "var(--color-on-surface-variant)",
  "--bottom-navigation-item-variant-active-background-color": "var(--color-info-container)",
  "--bottom-navigation-item-variant-active-color": "var(--color-on-info-container)",
  "--bottom-navigation-fab-border-radius": "12px",
  "--bottom-navigation-item-font-size": "var(--font-size-sm)",
  "--bottom-navigation-item-active-color": "var(--color-primary)",
  "--bottom-navigation-item-line-height": "1",
  "--bottom-navigation-item-icon-size": "22px",
  "--bottom-navigation-item-icon-margin-bottom": "5px",
  "--bottom-navigation-item-variant-icon-container-height": "30px",
  "--bottom-navigation-item-variant-icon-container-border-radius": "100px",
  "--bottom-navigation-item-variant-icon-container-max-width": "58px"
};
var stdin_default$22 = {
  "--breadcrumb-inactive-color": "var(--color-on-surface-variant)",
  "--breadcrumb-active-color": "var(--color-primary)",
  "--breadcrumb-separator-margin": "0 10px",
  "--breadcrumb-separator-font-size": "14px"
};
var stdin_default$21 = {
  "--button-default-color": "#3B383E",
  "--button-default-text-color": "var(--color-primary)",
  "--button-default-icon-color": "var(--color-on-surface-variant)",
  "--button-default-icon-container-color": "var(--color-surface-container-highest)",
  "--button-border-radius": "100px",
  "--button-primary-text-color": "var(--color-on-primary)",
  "--button-danger-text-color": "var(--color-on-danger)",
  "--button-success-text-color": "var(--color-on-success)",
  "--button-warning-text-color": "var(--color-on-warning)",
  "--button-info-text-color": "var(--color-on-info)",
  "--button-primary-color": "var(--color-primary)",
  "--button-danger-color": "var(--color-danger)",
  "--button-success-color": "var(--color-success)",
  "--button-warning-color": "var(--color-warning)",
  "--button-info-color": "var(--color-info)",
  "--button-primary-icon-color": "var(--color-on-primary-container)",
  "--button-danger-icon-color": "var(--color-on-danger-container)",
  "--button-success-icon-color": "var(--color-on-success-container)",
  "--button-warning-icon-color": "var(--color-on-warning-container)",
  "--button-info-icon-color": "var(--color-on-info-container)",
  "--button-primary-icon-container-color": "var(--color-primary-container)",
  "--button-danger-icon-container-color": "var(--color-danger-container)",
  "--button-success-icon-container-color": "var(--color-success-container)",
  "--button-warning-icon-container-color": "var(--color-warning-container)",
  "--button-info-icon-container-color": "var(--color-info-container)",
  "--button-disabled-color": "var(--color-disabled)",
  "--button-disabled-text-color": "var(--color-text-disabled)",
  "--button-mini-padding": "0 8px",
  "--button-small-padding": "0 12px",
  "--button-normal-padding": "0 16px",
  "--button-large-padding": "0 22px",
  "--button-round-padding": "6px",
  "--button-mini-height": "20px",
  "--button-small-height": "28px",
  "--button-normal-height": "36px",
  "--button-large-height": "44px",
  "--button-mini-font-size": "var(--font-size-xs)",
  "--button-small-font-size": "var(--font-size-sm)",
  "--button-normal-font-size": "var(--font-size-md)",
  "--button-large-font-size": "var(--font-size-lg)"
};
var stdin_default$20 = {
  "--card-border-radius": "12px",
  "--card-background": "var(--color-surface-container-highest)",
  "--card-filled-background": "var(--color-surface-container-highest)",
  "--card-image-height": "188px",
  "--card-title-color": "var(--color-inverse-surface)",
  "--card-title-font-size": "16px",
  "--card-title-padding": "0 16px",
  "--card-title-margin": "16px 0 0 0",
  "--card-content-padding": "0 16px",
  "--card-content-margin": "16px 0 0 0",
  "--card-content-color": "var(--color-on-surface-variant)",
  "--card-content-font-size": "14px",
  "--card-content-row-margin": "16px 0 0 0",
  "--card-subtitle-color": "var(--color-on-surface-variant)",
  "--card-subtitle-padding": "0 16px",
  "--card-subtitle-margin": "4px 0 0 0",
  "--card-description-margin": "32px 0 0 0",
  "--card-description-padding": "0 16px",
  "--card-description-color": "var(--color-on-surface-variant)",
  "--card-padding": "0 0 16px 0",
  "--card-footer-margin": "32px 0 0 0",
  "--card-title-row-margin": "16px 0 0 0",
  "--card-subtitle-row-margin": "4px 0 0 0",
  "--card-footer-padding": "0 16px",
  "--card-close-button-size": "56px",
  "--card-close-button-primary-color": "var(--color-primary-container)",
  "--card-close-button-text-color": "var(--color-on-primary-container)",
  "--card-close-button-border-radius": "12px",
  "--card-outline-color": "var(--color-outline)",
  "--card-image-width": "100%",
  "--card-row-image-width": "140px",
  "--card-row-height": "140px",
  "--card-subtitle-font-size": "14px",
  "--card-description-font-size": "14px",
  "--card-footer-right": "13px",
  "--card-footer-bottom": "9px",
  "--card-line-height": "22px",
  "--card-row-line-height": "1.5",
  "--card-floating-buttons-bottom": "16px",
  "--card-floating-buttons-right": "16px",
  "--card-floating-buttons-color": "#fff",
  "--card-close-button-icon-size": "24px"
};
var stdin_default$1$ = {
  "--cell-description-color": "var(--color-on-surface-variant)",
  "--cell-color": "var(--color-text)",
  "--cell-font-size": "var(--font-size-md)",
  "--cell-description-font-size": "var(--font-size-sm)",
  "--cell-description-margin-top": "4px",
  "--cell-padding": "10px 12px",
  "--cell-min-height": "40px",
  "--cell-border-color": "var(--color-outline)",
  "--cell-border-left": "12px",
  "--cell-border-right": "12px",
  "--cell-icon-right": "8px",
  "--cell-extra-left": "8px"
};
var stdin_default$1_ = {
  "--checkbox-unchecked-color": "var(--color-on-surface-variant)",
  "--checkbox-text-color": "var(--color-on-surface-variant)",
  "--checkbox-checked-color": "var(--color-primary)",
  "--checkbox-disabled-color": "var(--color-text-disabled)",
  "--checkbox-error-color": "var(--color-danger)",
  "--checkbox-action-padding": "6px",
  "--checkbox-icon-size": "24px"
};
var stdin_default$1Z = {
  "--chip-round-radius": "8px",
  "--chip-default-color": "var(--color-surface-container-highest)",
  "--chip-default-text-color": "var(--color-on-surface-variant)",
  "--chip-primary-text-color": "var(--color-on-primary-container)",
  "--chip-danger-text-color": "var(--color-on-danger-container)",
  "--chip-success-text-color": "var(--color-on-success-container)",
  "--chip-warning-text-color": "var(--color-on-warning-container)",
  "--chip-info-text-color": "var(--color-on-info-container)",
  "--chip-primary-color": "var(--color-primary-container)",
  "--chip-danger-color": "var(--color-danger-container)",
  "--chip-success-color": "var(--color-success-container)",
  "--chip-warning-color": "var(--color-warning-container)",
  "--chip-info-color": "var(--color-info-container)",
  "--chip-primary-plain-color": "var(--color-primary)",
  "--chip-danger-plain-color": "var(--color-danger)",
  "--chip-success-plain-color": "var(--color-success)",
  "--chip-warning-plain-color": "var(--color-warning)",
  "--chip-info-plain-color": "var(--color-info)",
  "--chip-border-radius": "2px",
  "--chip-normal-height": "32px",
  "--chip-large-height": "40px",
  "--chip-small-height": "24px",
  "--chip-mini-height": "16px",
  "--chip-normal-padding": "0 10px",
  "--chip-large-padding": "0 17px",
  "--chip-small-padding": "0 6px",
  "--chip-mini-padding": "0 4px",
  "--chip-text-normal-margin": "0 5px",
  "--chip-text-large-margin": "0 5px",
  "--chip-text-small-margin": "0 3px",
  "--chip-text-mini-margin": "0 2px",
  "--chip-mini-font-size": "var(--font-size-xs)",
  "--chip-small-font-size": "var(--font-size-sm)",
  "--chip-normal-font-size": "var(--font-size-md)",
  "--chip-large-font-size": "var(--font-size-lg)"
};
var stdin_default$1Y = {
  "--code-font-size": "14px",
  "--code-line-height": "1.7"
};
var stdin_default$1X = {
  "--collapse-background": "var(--color-surface-container-highest)",
  "--collapse-text-color": "var(--color-inverse-surface)",
  "--collapse-header-font-size": "var(--font-size-lg)",
  "--collapse-header-padding": "10px 12px",
  "--collapse-content-font-size": "var(--font-size-md)",
  "--collapse-content-padding": "0 12px 10px",
  "--collapse-item-margin-top": "16px",
  "--collapse-disable-color": "#bdbdbd",
  "--collapse-border-top": "thin solid var(--color-outline)"
};
var stdin_default$1W = {
  "--countdown-text-color": "var(--color-text)",
  "--countdown-text-font-size": "var(--font-size-lg)"
};
var stdin_default$1V = {
  "--counter-font-color": "#3B383E",
  "--counter-button-text-color": "#3B383E",
  "--counter-padding": "0 4px",
  "--counter-background": "var(--color-primary)",
  "--counter-input-width": "28px",
  "--counter-input-margin": "0 4px",
  "--counter-input-font-size": "14px",
  "--counter-button-size": "28px",
  "--counter-button-icon-size": "100%",
  "--counter-disabled-color": "var(--color-disabled)",
  "--counter-disabled-opacity": "var(--opacity-disabled)",
  "--counter-error-color": "var(--color-danger)"
};
var stdin_default$1U = {
  "--date-picker-title-background": "var(--color-surface-container-high)",
  "--date-picker-title-color": "var(--color-inverse-surface)",
  "--date-picker-title-hint-color": "var(--color-on-surface-variant)",
  "--date-picker-body-background-color": "var(--color-surface-container-high)",
  "--date-picker-main-color": "var(--color-inverse-surface)",
  "--date-picker-border-radius": "20px",
  "--date-picker-title-padding": "20px 20px 16px",
  "--date-picker-actions-padding": "20px",
  "--day-picker-head-item-color": "var(--color-inverse-surface)",
  "--date-picker-header-arrow-filter": "opacity(1)",
  "--date-picker-header-padding": "0 0 16px",
  "--date-picker-body-height": "300px",
  "--date-picker-body-padding": "0 14px 16px",
  "--date-picker-header-color": "var(--color-on-surface-variant)",
  "--date-picker-font-size": "var(--font-size-md)",
  "--date-picker-min-width": "290px",
  "--date-picker-title-hint-font-size": "var(--font-size-md)",
  "--date-picker-title-height": "105px",
  "--date-picker-title-year-font-size": "var(--font-size-md)",
  "--date-picker-title-year-font-weight": "500",
  "--date-picker-title-year-margin-bottom": "8px",
  "--date-picker-title-date-height": "48px",
  "--date-picker-title-date-font-size": "34px",
  "--date-picker-title-date-font-weight": "500",
  "--date-picker-title-date-range-font-size": "20px",
  "--date-picker-title-date-justify-content": "normal",
  "--month-picker-padding": "0 12px",
  "--month-picker-item-width": "33%",
  "--month-picker-item-height": "56px",
  "--month-picker-item-button-max-width": "140px",
  "--year-picker-padding": "0 12px",
  "--year-picker-item-width": "33%",
  "--year-picker-item-height": "56px",
  "--year-picker-item-button-max-width": "140px",
  "--day-picker-content-item-width": "14.28%",
  "--day-picker-content-item-font-size": "var(--font-size-sm)",
  "--day-picker-content-item-padding": "2px 0",
  "--day-picker-content-item-button-width": "32px",
  "--day-picker-content-item-button-height": "32px",
  "--day-picker-content-item-button-font-size": "var(--font-size-sm)",
  "--day-picker-head-item-padding": "8px 0",
  "--day-picker-head-item-font-weight": "600"
};
var stdin_default$1T = {
  "--dialog-width": "312px",
  "--dialog-background": "var(--color-surface-container-high)",
  "--dialog-title-color": "var(--color-inverse-surface)",
  "--dialog-message-color": "var(--color-on-surface-variant)",
  "--dialog-border-radius": "28px",
  "--dialog-title-padding": "24px 24px 0",
  "--dialog-message-padding": "16px 24px 24px",
  "--dialog-actions-padding": "0 24px 24px",
  "--dialog-title-font-size": "20px",
  "--dialog-button-margin-left": "8px",
  "--dialog-message-line-height": "24px",
  "--dialog-message-font-size": "var(--font-size-md)",
  "--dialog-confirm-button-color": "var(--color-primary)",
  "--dialog-cancel-button-color": "var(--color-primary)"
};
var stdin_default$1S = {
  "--divider-text-color": "#aaa",
  "--divider-color": "var(--color-outline)",
  "--divider-text-margin": "8px 0",
  "--divider-text-padding": "0 8px",
  "--divider-inset": "72px"
};
var stdin_default$1R = {
  "--fab-trigger-border-radius": "16px",
  "--fab-action-size": "40px",
  "--fab-action-border-radius": "12px",
  "--fab-top": "70px",
  "--fab-bottom": "16px",
  "--fab-left": "16px",
  "--fab-right": "16px",
  "--fab-trigger-size": "56px",
  "--fab-trigger-inactive-icon-size": "26px",
  "--fab-trigger-active-icon-size": "22px",
  "--fab-actions-padding": "10px 0",
  "--fab-action-margin": "6px",
  "--fab-transition-standard-easing": "cubic-bezier(0.4, 0, 0.2, 1)"
};
var stdin_default$1Q = {
  "--field-decorator-text-color": "var(--color-inverse-surface)",
  "--field-decorator-blur-color": "var(--color-on-surface-variant)",
  "--field-decorator-error-color": "var(--color-danger)",
  "--field-decorator-focus-color": "var(--color-primary)",
  "--field-decorator-placeholder-size": "16px",
  "--field-decorator-icon-size": "20px",
  "--field-decorator-line-size": "1px",
  "--field-decorator-line-focus-size": "2px",
  "--field-decorator-line-border-radius": "4px",
  "--field-decorator-disabled-color": "var(--color-text-disabled)",
  "--field-decorator-standard-normal-margin-top": "22px",
  "--field-decorator-standard-normal-margin-bottom": "4px",
  "--field-decorator-standard-normal-icon-margin-top": "22px",
  "--field-decorator-standard-normal-icon-margin-bottom": "4px",
  "--field-decorator-standard-normal-non-hint-margin-top": "4px",
  "--field-decorator-standard-small-margin-top": "18px",
  "--field-decorator-standard-small-margin-bottom": "4px",
  "--field-decorator-standard-small-icon-margin-top": "18px",
  "--field-decorator-standard-small-icon-margin-bottom": "4px",
  "--field-decorator-standard-small-non-hint-margin-top": "2px",
  "--field-decorator-outlined-normal-margin-top": "16px",
  "--field-decorator-outlined-normal-margin-bottom": "16px",
  "--field-decorator-outlined-normal-padding-left": "16px",
  "--field-decorator-outlined-normal-padding-right": "16px",
  "--field-decorator-outlined-normal-placeholder-space": "4px",
  "--field-decorator-outlined-normal-icon-margin-top": "16px",
  "--field-decorator-outlined-normal-icon-margin-bottom": "16px",
  "--field-decorator-outlined-small-margin-top": "8px",
  "--field-decorator-outlined-small-margin-bottom": "8px",
  "--field-decorator-outlined-small-padding-left": "12px",
  "--field-decorator-outlined-small-padding-right": "12px",
  "--field-decorator-outlined-small-placeholder-space": "2px",
  "--field-decorator-outlined-small-icon-margin-top": "8px",
  "--field-decorator-outlined-small-icon-margin-bottom": "8px"
};
var stdin_default$1P = {
  "--floating-panel-background": "var(--color-surface-container-low)",
  "--floating-panel-toolbar-background": "#938F99",
  "--floating-panel-toolbar-width": "32px",
  "--floating-panel-toolbar-height": "4px",
  "--floating-panel-header-height": "36px",
  "--floating-panel-z-index": "999",
  "--floating-panel-border-top": "none",
  "--floating-panel-border-radius": "0",
  "--floating-panel-toolbar-border-radius": "10px",
  "--floating-panel-transition-timing-function": "cubic-bezier(0.18, 0.89, 0.32, 1.28)"
};
var stdin_default$1O = {
  "--form-details-error-message-color": "var(--color-danger)",
  "--form-details-extra-message-color": "#888",
  "--form-details-margin-top": "6px",
  "--form-details-font-size": "12px",
  "--form-details-message-margin-right": "4px"
};
var stdin_default$1N = {
  "--hover-overlay-opacity": "var(--opacity-hover)",
  "--hover-overlay-focusing-opacity": "var(--opacity-focus)"
};
var stdin_default$1M = {
  "--icon-size": "20px"
};
var stdin_default$1L = {
  "--image-preview-swipe-indicators-text-color": "#ddd",
  "--image-preview-swipe-indicators-padding": "16px 0",
  "--image-preview-zoom-container-background": "#000",
  "--image-preview-close-icon-top": "14px",
  "--image-preview-close-icon-right": "14px",
  "--image-preview-extra-top": "14px",
  "--image-preview-extra-left": "14px",
  "--image-preview-close-icon-size": "22px",
  "--image-preview-close-icon-color": "#fff"
};
var stdin_default$1K = {
  "--index-bar-list-right": "0",
  "--index-bar-list-top": "50%",
  "--index-bar-list-left": "auto",
  "--index-bar-list-bottom": "auto",
  "--index-bar-list-transform": "translate(0, -50%)",
  "--index-bar-list-item-font-size": "var(--font-size-xs)",
  "--index-bar-list-item-color": "var(--color-primary)",
  "--index-bar-list-item-active-color": "var(--color-danger)",
  "--index-bar-list-item-height": "14px",
  "--index-bar-list-item-padding": "0 10px"
};
var stdin_default$1J = {
  "--input-input-height": "24px",
  "--input-input-font-size": "16px",
  "--input-textarea-height": "auto"
};
var stdin_default$1I = {
  "--link-default-color": "#fff",
  "--link-primary-color": "var(--color-primary)",
  "--link-danger-color": "var(--color-danger)",
  "--link-success-color": "var(--color-success)",
  "--link-warning-color": "var(--color-warning)",
  "--link-info-color": "var(--color-info)",
  "--link-disabled-color": "var(--color-text-disabled)",
  "--link-font-size": "var(--font-size-md)",
  "--link-focus-opacity": "0.8"
};
var stdin_default$1H = {
  "--list-loading-height": "50px",
  "--list-finished-height": "50px",
  "--list-error-height": "50px",
  "--list-loading-color": "#888",
  "--list-finished-color": "#888",
  "--list-error-color": "#888",
  "--list-loading-font-size": "var(--font-size-md)",
  "--list-finished-font-size": "var(--font-size-md)",
  "--list-error-font-size": "var(--font-size-md)"
};
var stdin_default$1G = {
  "--loading-color": "var(--color-primary)",
  "--loading-opacity": "0.38",
  "--loading-desc-margin": "8px 0 0",
  "--loading-desc-color": "var(--color-primary)"
};
var stdin_default$1F = {
  "--loading-bar-color": "var(--color-primary)",
  "--loading-bar-error-color": "var(--color-danger)",
  "--loading-bar-height": "3px"
};
var stdin_default$1E = {
  "--menu-background-color": "var(--color-surface-container)",
  "--menu-border-radius": "4px"
};
var stdin_default$1D = {
  "--menu-option-text-color": "var(--color-inverse-surface)",
  "--menu-option-normal-height": "38px",
  "--menu-option-small-height": "30px",
  "--menu-option-mini-height": "24px",
  "--menu-option-large-height": "46px",
  "--menu-option-padding": "0 12px",
  "--menu-option-normal-font-size": "var(--font-size-md)",
  "--menu-option-small-font-size": "var(--font-size-sm)",
  "--menu-option-mini-font-size": "var(--font-size-xs)",
  "--menu-option-large-font-size": "var(--font-size-lg)",
  "--menu-option-selected-background": "var(--color-primary)",
  "--menu-option-disabled-color": "var(--color-text-disabled)"
};
var stdin_default$1C = {
  "--menu-select-menu-background-color": "var(--color-surface-container)",
  "--menu-select-menu-border-radius": "4px",
  "--menu-select-menu-max-height": "278px",
  "--menu-select-menu-padding": "0"
};
var stdin_default$1B = {
  "--option-text-color": "var(--color-inverse-surface)",
  "--option-height": "38px",
  "--option-padding": "0 12px",
  "--option-font-size": "16px",
  "--option-selected-background": "var(--field-decorator-focus-color)",
  "--option-disabled-color": "var(--color-text-disabled)"
};
var stdin_default$1A = {
  "--overlay-background-color": "rgba(0, 0, 0, 0.6)"
};
var stdin_default$1z = {
  "--pagination-text-color": "#fff",
  "--pagination-item-background": "var(--color-surface-container)",
  "--pagination-font-size": "var(--font-size-md)",
  "--pagination-active-color": "var(--color-on-primary)",
  "--pagination-active-bg-color": "var(--color-primary)",
  "--pagination-hover-bg-color": "rgba(85, 85, 85, 0.15)",
  "--pagination-total-margin": "0 12px",
  "--pagination-total-line-height": "24px",
  "--pagination-item-width": "32px",
  "--pagination-item-height": "32px",
  "--pagination-item-margin": "0 6px",
  "--pagination-item-border-radius": "4px",
  "--pagination-item-simple-border-radius": "50%",
  "--pagination-input-width": "32px",
  "--pagination-disabled-color": "var(--color-text-disabled)",
  "--pagination-bg-disabled-color": "var(--color-disabled)",
  "--pagination-size-line-height": "24px",
  "--pagination-size-padding": "0 6px"
};
var stdin_default$1y = {
  "--paper-background": "var(--color-surface-container-highest)",
  "--paper-border-radius": "12px"
};
var stdin_default$1x = {
  "--picker-background": "var(--color-body)",
  "--picker-cancel-button-text-color": "var(--color-primary)",
  "--picker-title-text-color": "#fff",
  "--picker-option-text-color": "#fff",
  "--picker-mask-background-image": "linear-gradient(180deg, rgba(20, 18, 24, 0.9), rgba(20, 18, 24, 0.4)), linear-gradient(0deg, rgba(20, 18, 24, 0.9), rgba(20, 18, 24, 0.4))",
  "--picker-toolbar-height": "44px",
  "--picker-confirm-button-text-color": "var(--color-primary)",
  "--picker-picked-border": "1px solid var(--color-outline)",
  "--picker-title-font-size": "var(--font-size-lg)",
  "--picker-option-font-size": "var(--font-size-lg)",
  "--picker-toolbar-padding": "0 4px"
};
var stdin_default$1w = {
  "--popup-content-background-color": "var(--color-surface-container-high)",
  "--popup-overlay-background-color": "rgba(0, 0, 0, 0.6)"
};
var stdin_default$1v = {
  "--progress-label-color": "#fff",
  "--progress-font-size": "var(--font-size-sm)",
  "--progress-track-color": "#d8d8d8",
  "--progress-background": "var(--color-primary)",
  "--progress-default-color": "#f5f5f5",
  "--progress-primary-color": "var(--color-primary)",
  "--progress-danger-color": "var(--color-danger)",
  "--progress-success-color": "var(--color-success)",
  "--progress-warning-color": "var(--color-warning)",
  "--progress-info-color": "var(--color-info)",
  "--progress-linear-border-radius": "0px"
};
var stdin_default$1u = {
  "--pull-refresh-background": "var(--color-surface-container-highest)",
  "--pull-refresh-size": "40px",
  "--pull-refresh-color": "var(--color-primary)",
  "--pull-refresh-success-color": "var(--color-success)",
  "--pull-refresh-icon-size": "25px"
};
var stdin_default$1t = {
  "--radio-unchecked-color": "var(--color-on-surface-variant)",
  "--radio-text-color": "var(--color-on-surface-variant)",
  "--radio-checked-color": "var(--color-primary)",
  "--radio-disabled-color": "var(--color-text-disabled)",
  "--radio-error-color": "var(--color-danger)",
  "--radio-icon-size": "24px",
  "--radio-action-padding": "6px"
};
var stdin_default$1s = {
  "--rate-color": "var(--color-on-surface-variant)",
  "--rate-size": "24px",
  "--rate-disabled-color": "var(--color-text-disabled)",
  "--rate-error-color": "var(--color-danger)",
  "--rate-action-padding": "4px",
  "--rate-primary-color": "var(--color-primary)"
};
var stdin_default$1r = {
  "--result-background": "var(--color-surface-container-highest)",
  "--result-border-radius": "12px",
  "--result-title-color": "var(--color-inverse-surface)",
  "--result-description-color": "var(--color-on-surface-variant)",
  "--result-question-color": "#7f8e96",
  "--result-question-border-color": "rgba(151,194,216,0.3)",
  "--result-empty-color": "#adadad",
  "--result-empty-border-color": "rgba(232,229,229,0.3)",
  "--result-info-border-color": "rgba(204, 194, 220, 0.3)",
  "--result-success-border-color": "rgba(186, 207, 131, 0.3)",
  "--result-error-border-color": "rgba(242, 184, 181, 0.3)",
  "--result-warning-border-color": "rgba(239, 184, 200, 0.3)",
  "--result-padding": "24px",
  "--result-title-font-size": "32px",
  "--result-title-margin": "15px 0 0 0",
  "--result-image-size": "80px",
  "--result-title-font-weight": "500",
  "--result-description-margin": "10px 0 0 0",
  "--result-description-font-size": "14px",
  "--result-description-line-height": "1.6",
  "--result-info-color": "var(--color-info)",
  "--result-success-color": "var(--color-success)",
  "--result-error-color": "var(--color-danger)",
  "--result-warning-color": "var(--color-warning)"
};
var stdin_default$1q = {
  "--ripple-cubic-bezier": "cubic-bezier(0.68, 0.01, 0.62, 0.6)",
  "--ripple-color": "currentColor"
};
var stdin_default$1p = {
  "--select-scroller-background": "var(--color-surface-container)",
  "--select-scroller-border-radius": "4px",
  "--select-scroller-padding": "6px 0",
  "--select-scroller-max-height": "278px",
  "--select-chip-margin": "5px 5px 0",
  "--select-arrow-size": "20px",
  "--select-standard-menu-margin": `calc(var(--field-decorator-placeholder-size) * 0.75 + 12px) 0 0 0`,
  "--select-label-font-size": "16px"
};
var stdin_default$1o = {
  "--skeleton-card-background-color": "hsla(0,0%,100%,.12)",
  "--skeleton-animation-background": `linear-gradient(
        90deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.05),hsla(0,0%,100%,0))
      `,
  "--skeleton-avatar-background-color": "hsla(0,0%,100%,.12)",
  "--skeleton-title-background-color": "hsla(0,0%,100%,.12)",
  "--skeleton-content-padding": "16px",
  "--skeleton-card-height": "160px",
  "--skeleton-card-border-radius": "4px",
  "--skeleton-card-margin-bottom": "16px",
  "--skeleton-avatar-size": "34px",
  "--skeleton-avatar-border-radius": "50%",
  "--skeleton-avatar-margin-right": "16px",
  "--skeleton-title-width": "50%",
  "--skeleton-title-border-radius": "10px",
  "--skeleton-row-height": "12px",
  "--skeleton-row-border-radius": "10px",
  "--skeleton-row-margin-top": "10px"
};
var stdin_default$1n = {
  "--slider-thumb-size": "16px",
  "--slider-track-height": "4px",
  "--slider-track-background": "var(--color-surface-container-highest)",
  "--slider-track-fill-border-radius": "4px",
  "--slider-track-border-radius": "4px",
  "--slider-error-color": "var(--color-danger)",
  "--slider-track-fill-background": "var(--color-primary)",
  "--slider-thumb-block-background": "var(--color-primary)",
  "--slider-thumb-ripple-background": "var(--color-primary)",
  "--slider-thumb-label-background": "var(--color-primary)",
  "--slider-thumb-label-font-size": "var(--font-size-sm)",
  "--slider-thumb-label-text-color": "var(--color-on-primary)",
  "--slider-disabled-opacity": "var(--opacity-disabled)"
};
var stdin_default$1m = {
  "--snackbar-color": "#322F35",
  "--snackbar-background": "var(--color-inverse-surface)",
  "--snackbar-width": "256px",
  "--snackbar-border-radius": "4px",
  "--snackbar-font-size": "var(--font-size-md)",
  "--snackbar-margin": "6px 24px",
  "--snackbar-border-color": "currentColor",
  "--snackbar-success-background": "var(--color-success)",
  "--snackbar-info-background": "var(--color-info)",
  "--snackbar-error-background": "var(--color-danger)",
  "--snackbar-warning-background": "var(--color-warning)",
  "--snackbar-content-padding": "14px 16px",
  "--snackbar-action-margin": "0 8px",
  "--snackbar-vertical-action-margin": "0 8px 8px 0",
  "--snackbar-icon-margin": "0 8px"
};
var stdin_default$1l = {
  "--space-size-mini-y": "4px",
  "--space-size-mini-x": "4px",
  "--space-size-small-y": "6px",
  "--space-size-small-x": "6px",
  "--space-size-normal-y": "8px",
  "--space-size-normal-x": "12px",
  "--space-size-large-y": "12px",
  "--space-size-large-x": "20px"
};
var stdin_default$1k = {
  "--step-content-color": "rgba(255, 255, 255, .38)",
  "--step-content-active-color": "#fff",
  "--step-line-background": "#fff",
  "--step-tag-size": "20px",
  "--step-tag-background": "#9e9e9e",
  "--step-tag-font-size": "var(--font-size-md)",
  "--step-tag-color": "var(--color-on-primary)",
  "--step-tag-active-color": "var(--color-primary)",
  "--step-tag-margin": "4px 0",
  "--step-tag-icon-size": "var(--font-size-lg)",
  "--step-content-font-size": "var(--font-size-md)",
  "--step-line-gap": "8px",
  "--step-vertical-tag-margin": "0 4px",
  "--step-vertical-min-height": "50px"
};
var stdin_default$1j = {
  "--swipe-indicator-color": "#fff",
  "--swipe-indicators-offset": "10px",
  "--swipe-indicator-offset": "4px",
  "--swipe-navigation-z-index": "9",
  "--swipe-navigation-button-width": "36px",
  "--swipe-navigation-button-height": "36px",
  "--swipe-navigation-button-border-radius": "50%",
  "--swipe-navigation-icon-size": "20px",
  "--swipe-navigation-prev-left": "8px",
  "--swipe-navigation-next-right": "8px",
  "--swipe-navigation-prev-top": "8px",
  "--swipe-navigation-next-bottom": "8px"
};
var stdin_default$1i = {
  "--switch-track-background": "#727272",
  "--switch-handle-background": "#727272",
  "--switch-track-active-background": "var(--color-primary)",
  "--switch-track-error-background": "var(--color-danger)",
  "--switch-ripple-color": "var(--color-primary)",
  "--switch-handle-color": "var(--color-primary)",
  "--switch-handle-active-color": "var(--color-on-primary)",
  "--switch-handle-active-background": "var(--color-primary)",
  "--switch-handle-error-background": "var(--color-danger)",
  "--switch-disabled-opacity": "var(--opacity-disabled)",
  "--switch-variant-width": "52px",
  "--switch-variant-height": "32px",
  "--switch-variant-track-background": "var(--color-surface-container-highest)",
  "--switch-variant-handle-width": "24px",
  "--switch-variant-handle-height": "24px",
  "--switch-variant-track-border-color": "#938F99",
  "--switch-variant-handle-color": "var(--color-on-primary)",
  "--switch-variant-handle-active-color": "var(--color-primary)",
  "--switch-variant-handle-background": "#938F99",
  "--switch-variant-handle-active-background": "var(--color-on-primary)",
  "--switch-width": "40px",
  "--switch-height": "24px",
  "--switch-track-width": "38px",
  "--switch-track-height": "14.4px",
  "--switch-track-border-radius": "calc(20px * 2 / 3)",
  "--switch-handle-width": "20px",
  "--switch-handle-height": "20px",
  "--switch-ripple-size": "40px",
  "--switch-ripple-left": "-10px",
  "--switch-ripple-active-left": "10px",
  "--switch-loading-size": "16px",
  "--switch-variant-ripple-left": "-4px",
  "--switch-variant-ripple-active-left": "16px"
};
var stdin_default$1h = {
  "--tab-inactive-color": "var(--color-on-surface-variant)",
  "--tab-padding": "12px",
  "--tab-active-color": "var(--color-primary)",
  "--tab-disabled-color": "var(--color-text-disabled)",
  "--tab-font-size": "var(--font-size-md)",
  "--tab-font-weight": "400",
  "--tab-active-font-size": "var(--font-size-md)",
  "--tab-active-font-weight": "400"
};
var stdin_default$1g = {
  "--table-background": "var(--color-surface-container-highest)",
  "--table-thead-th-text-color": "rgba(255, 255, 255, 0.6)",
  "--table-thead-th-text-align": "left",
  "--table-tbody-td-text-color": "#fff",
  "--table-tbody-tr-hover-background": "var(--color-surface-container-highest)",
  "--table-border-radius": "2px",
  "--table-thead-border-bottom": "thin solid var(--color-outline)",
  "--table-thead-th-font-size": "14px",
  "--table-thead-tr-border-bottom": "thin solid var(--color-outline)",
  "--table-tbody-tr-border-bottom": "thin solid var(--color-outline)",
  "--table-tbody-td-font-size": "16px",
  "--table-tbody-td-text-align": "left",
  "--table-row-height": "46px",
  "--table-row-padding": "0 16px",
  "--table-footer-border-top": "thin solid var(--color-outline)"
};
var stdin_default$1f = {
  "--tabs-background": "var(--color-body)",
  "--tabs-item-horizontal-height": "44px",
  "--tabs-item-vertical-height": "66px",
  "--tabs-radius": "2px",
  "--tabs-padding": "12px",
  "--tabs-indicator-size": "2px",
  "--tabs-indicator-border-radius": "0",
  "--tabs-indicator-background": "var(--color-primary)",
  "--tabs-indicator-inner-size": "100%"
};
var stdin_default$1e = {
  "--time-picker-title-color": "var(--color-inverse-surface)",
  "--time-picker-clock-container-background": "var(--color-surface-container-highest)",
  "--time-picker-title-hint-color": "var(--color-on-surface-variant)",
  "--time-picker-title-background": "var(--color-surface-container-high)",
  "--time-picker-body-background": "var(--color-surface-container-high)",
  "--time-picker-clock-item-disable-color": "#888",
  "--time-picker-clock-item-disable-background": "#ccc",
  "--time-picker-clock-item-text-color": "var(--color-inverse-surface)",
  "--time-picker-border-radius": "20px",
  "--time-picker-title-padding": "20px 20px 16px",
  "--time-picker-actions-padding": "20px",
  "--time-picker-title-margin-bottom": "20px",
  "--time-picker-title-time-font-size": "40px",
  "--time-picker-title-ampm-border-radius": "8px",
  "--time-picker-title-time-padding": "8px 12px",
  "--time-picker-title-time-border-radius": "8px",
  "--time-picker-title-ampm-border": "thin solid #938F99",
  "--time-picker-title-ampm-button-padding": "8px",
  "--time-picker-title-time-background": "var(--color-surface-container-highest)",
  "--time-picker-title-inactive-opacity": "1",
  "--time-picker-title-time-active-background": "var(--color-primary-container)",
  "--time-picker-title-ampm-button-active-background": "var(--color-warning-container)",
  "--time-picker-font-size": "var(--font-size-md)",
  "--time-picker-min-width": "290px",
  "--time-picker-title-height": "105px",
  "--time-picker-title-hint-font-size": "14px",
  "--time-picker-title-time-margin": "0 5px",
  "--time-picker-title-ampm-margin-left": "10px",
  "--time-picker-clock-left": "27px",
  "--time-picker-clock-right": "27px",
  "--time-picker-clock-top": "27px",
  "--time-picker-clock-bottom": "27px",
  "--time-picker-clock-container-width": "256px",
  "--time-picker-clock-container-height": "256px",
  "--time-picker-clock-hand-height": "calc(50% - 4px)",
  "--time-picker-clock-hand-width": "2px",
  "--time-picker-clock-hand-bottom": "50%",
  "--time-picker-clock-hand-left": "calc(50% - 1px)",
  "--time-picker-clock-hand-background": "var(--color-primary)",
  "--time-picker-clock-hand-border-color": "var(--color-primary)",
  "--time-picker-clock-hand-before-width": "10px",
  "--time-picker-clock-hand-before-height": "10px",
  "--time-picker-clock-hand-before-border-width": "2px",
  "--time-picker-clock-hand-after-width": "4px",
  "--time-picker-clock-hand-after-height": "4px",
  "--time-picker-clock-item-height": "32px",
  "--time-picker-clock-item-width": "32px",
  "--time-picker-clock-item-active-background": "var(--color-primary)",
  "--time-picker-clock-item-active-color": "var(--color-on-primary)",
  "--time-picker-inner-left": "36px",
  "--time-picker-inner-right": "36px",
  "--time-picker-inner-top": "36px",
  "--time-picker-inner-bottom": "36px",
  "--time-picker-body-height": "288px",
  "--time-picker-title-time-container-justify-content": "flex-end"
};
var stdin_default$1d = {
  "--tooltip-default-color": "var(--color-inverse-surface)",
  "--tooltip-opacity": "1",
  "--tooltip-default-text-color": "#322F35",
  "--tooltip-border-radius": "4px",
  "--tooltip-font-size": "14px",
  "--tooltip-padding": "8px 16px",
  "--tooltip-offset": "10px",
  "--tooltip-primary-color": "var(--color-primary)",
  "--tooltip-info-color": "var(--color-info)",
  "--tooltip-success-color": "var(--color-success)",
  "--tooltip-warning-color": "var(--color-warning)",
  "--tooltip-danger-color": "var(--color-danger)",
  "--tooltip-primary-text-color": "var(--color-on-primary)",
  "--tooltip-info-text-color": "var(--color-on-info)",
  "--tooltip-success-text-color": "var(--color-on-success)",
  "--tooltip-warning-text-color": "var(--color-on-warning)",
  "--tooltip-danger-text-color": "var(--color-on-danger)"
};
var stdin_default$1c = {
  "--uploader-file-border-radius": "8px",
  "--uploader-action-background": "var(--color-surface-container-highest)",
  "--uploader-file-name-background": "var(--color-surface-container-highest)",
  "--uploader-file-cover-background": "var(--color-surface-container-highest)",
  "--uploader-action-icon-color": "var(--color-on-surface-variant)",
  "--uploader-file-name-color": "var(--color-on-surface-variant)",
  "--uploader-action-icon-size": "24px",
  "--uploader-action-margin": "0 10px 10px 0",
  "--uploader-file-size": "80px",
  "--uploader-file-margin": "0 10px 10px 0",
  "--uploader-file-name-font-size": "12px",
  "--uploader-file-name-padding": "10px",
  "--uploader-file-text-align": "center",
  "--uploader-file-close-background": "rgba(0, 0, 0, 0.3)",
  "--uploader-file-close-size": "24px",
  "--uploader-file-close-icon-font-size": "14px",
  "--uploader-file-close-icon-color": "#fff",
  "--uploader-file-cover-fit": "cover",
  "--uploader-preview-video-width": "100vw",
  "--uploader-preview-video-height": "100vw",
  "--uploader-file-indicator-height": "4px",
  "--uploader-file-indicator-normal-color": "var(--color-disabled)",
  "--uploader-file-indicator-success-color": "var(--color-success)",
  "--uploader-file-indicator-error-color": "var(--color-danger)",
  "--uploader-file-progress-color": "var(--color-primary)",
  "--uploader-disabled-color": "var(--color-disabled)",
  "--uploader-disabled-text-color": "var(--color-text-disabled)",
  "--uploader-loading-background": "linear-gradient(90deg, hsla(0, 0%, 100%, 0), hsla(0, 0%, 100%, 0.3), hsla(0, 0%, 100%, 0))"
};
var stdin_default$1b = {
  "--watermark-content-color": "#ffffff"
};
var __defProp$2 = Object.defineProperty;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key3, value) => key3 in obj ? __defProp$2(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$2(a, prop, b[prop]);
    }
  return a;
};
var stdin_default$1a = __spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2({
  "--color-scheme": "dark",
  "--font-size-xs": "10px",
  "--font-size-sm": "12px",
  "--font-size-md": "14px",
  "--font-size-lg": "16px",
  "--icon-size-xs": "16px",
  "--icon-size-sm": "18px",
  "--icon-size-md": "20px",
  "--icon-size-lg": "22px",
  "--hsl-body": "260, 14%, 8%",
  "--color-body": "hsla(var(--hsl-body), 1)",
  "--hsl-text": "0, 0%, 100%",
  "--color-text": "hsla(var(--hsl-text), 1)",
  "--hsl-primary": "258, 100%, 87%",
  "--color-primary": "hsla(var(--hsl-primary), 1)",
  "--hsl-info": "263, 27%, 81%",
  "--color-info": "hsla(var(--hsl-info), 1)",
  "--hsl-success": "77, 44%, 66%",
  "--color-success": "hsla(var(--hsl-success), 1)",
  "--hsl-warning": "343, 63%, 83%",
  "--color-warning": "hsla(var(--hsl-warning), 1)",
  "--hsl-danger": "3, 70%, 83%",
  "--color-danger": "hsla(var(--hsl-danger), 1)",
  "--hsl-on-primary": "259, 58%, 28%",
  "--color-on-primary": "hsla(var(--hsl-on-primary), 1)",
  "--hsl-on-info": "258, 18%, 22%",
  "--color-on-info": "hsla(var(--hsl-on-info), 1)",
  "--hsl-on-success": "76, 100%, 10%",
  "--color-on-success": "hsla(var(--hsl-on-success), 1)",
  "--hsl-on-warning": "338, 33%, 22%",
  "--color-on-warning": "hsla(var(--hsl-on-warning), 1)",
  "--hsl-on-danger": "3, 71%, 22%",
  "--color-on-danger": "hsla(var(--hsl-on-danger), 1)",
  "--hsl-primary-container": "257, 37%, 42%",
  "--color-primary-container": "hsla(var(--hsl-primary-container), 1)",
  "--hsl-info-container": "260, 12%, 35%",
  "--color-info-container": "hsla(var(--hsl-info-container), 1)",
  "--hsl-success-container": "77, 57%, 23%",
  "--color-success-container": "hsla(var(--hsl-success-container), 1)",
  "--hsl-warning-container": "342, 21%, 36%",
  "--color-warning-container": "hsla(var(--hsl-warning-container), 1)",
  "--hsl-danger-container": "2, 48%, 42%",
  "--color-danger-container": "hsla(var(--hsl-danger-container), 1)",
  "--hsl-on-primary-container": "263, 100%, 93%",
  "--color-on-primary-container": "hsla(var(--hsl-on-primary-container), 1)",
  "--hsl-on-info-container": "263, 65%, 92%",
  "--color-on-info-container": "hsla(var(--hsl-on-info-container), 1)",
  "--hsl-on-success-container": "77, 68%, 77%",
  "--color-on-success-container": "hsla(var(--hsl-on-success-container), 1)",
  "--hsl-on-warning-container": "342, 100%, 92%",
  "--color-on-warning-container": "hsla(var(--hsl-on-warning-container), 1)",
  "--hsl-on-danger-container": "4, 71%, 92%",
  "--color-on-danger-container": "hsla(var(--hsl-on-danger-container), 1)",
  "--hsl-disabled": "0, 0%, 25%",
  "--color-disabled": "hsla(var(--hsl-disabled), 1)",
  "--hsl-text-disabled": "0, 0%, 46%",
  "--color-text-disabled": "hsla(var(--hsl-text-disabled), 1)",
  "--hsl-surface-container": "257, 10%, 14%",
  "--color-surface-container": "hsla(var(--hsl-surface-container), 1)",
  "--hsl-surface-container-low": "264, 8%, 12%",
  "--color-surface-container-low": "hsla(var(--hsl-surface-container-low), 1)",
  "--hsl-surface-container-high": "257, 8%, 17%",
  "--color-surface-container-high": "hsla(var(--hsl-surface-container-high), 1)",
  "--hsl-surface-container-highest": "257, 6%, 22%",
  "--color-surface-container-highest": "hsla(var(--hsl-surface-container-highest), 1)",
  "--hsl-inverse-surface": "280, 17%, 90%",
  "--color-inverse-surface": "hsla(var(--hsl-inverse-surface), 1)",
  "--hsl-outline": "264, 7%, 29%",
  "--color-outline": "hsla(var(--hsl-outline), 1)",
  "--hsl-on-surface-variant": "270, 11%, 79%",
  "--color-on-surface-variant": "hsla(var(--hsl-on-surface-variant), 1)",
  "--opacity-disabled": "0.6",
  "--opacity-hover": "0.12",
  "--opacity-focus": "0.2",
  "--cubic-bezier": "cubic-bezier(0.25, 0.8, 0.5, 1)",
  "--shadow-key-umbra-opacity": "rgba(0, 0, 0, 0.2)",
  "--shadow-key-penumbra-opacity": "rgba(0, 0, 0, 0.14)",
  "--shadow-key-ambient-opacity": "rgba(0, 0, 0, 0.12)"
}, stdin_default$21), stdin_default$2a), stdin_default$1N), stdin_default$1E), stdin_default$1C), stdin_default$1D), stdin_default$1R), stdin_default$22), stdin_default$1I), stdin_default$1$), stdin_default$1y), stdin_default$28), stdin_default$1Q), stdin_default$1_), stdin_default$1t), stdin_default$20), stdin_default$1Z), stdin_default$25), stdin_default$1d), stdin_default$1v), stdin_default$1f), stdin_default$1h), stdin_default$1k), stdin_default$1S), stdin_default$1g), stdin_default$1z), stdin_default$1b), stdin_default$1X), stdin_default$1r), stdin_default$29), stdin_default$24), stdin_default$23), stdin_default$1m), stdin_default$2b), stdin_default$1T), stdin_default$1u), stdin_default$1w), stdin_default$1x), stdin_default$1P), stdin_default$26), stdin_default$1p), stdin_default$1B), stdin_default$1V), stdin_default$1i), stdin_default$1n), stdin_default$1c), stdin_default$1e), stdin_default$1U), stdin_default$1s), stdin_default$1o), stdin_default$27), stdin_default$1W), stdin_default$1O), stdin_default$1M), stdin_default$1L), stdin_default$1K), stdin_default$1J), stdin_default$1H), stdin_default$1G), stdin_default$1F), stdin_default$1A), stdin_default$1q), stdin_default$1l), stdin_default$1j), stdin_default$1Y);
var stdin_default$19 = {
  "--action-sheet-background": "var(--color-surface-container-high)",
  "--action-sheet-title-color": "var(--color-on-surface-variant)",
  "--action-sheet-action-item-color": "#1D1B20",
  "--action-sheet-border-radius": "0px"
};
var stdin_default$18 = {
  "--alert-padding": "16px",
  "--alert-border-radius": "4px",
  "--alert-icon-size": "22px",
  "--alert-icon-margin": "0 12px 0 0",
  "--alert-close-icon-size": "22px",
  "--alert-close-icon-margin": "2px 0 0 12px",
  "--alert-standard-info-text-color": "var(--color-on-info)",
  "--alert-standard-danger-text-color": "var(--color-on-danger)",
  "--alert-standard-success-text-color": "var(--color-on-success)",
  "--alert-standard-warning-text-color": "var(--color-on-warning)",
  "--alert-danger-background": "var(--color-danger)",
  "--alert-success-background": "var(--color-success)",
  "--alert-warning-background": "var(--color-warning)",
  "--alert-info-background": "var(--color-info)",
  "--alert-tonal-danger-background": "hsla(var(--hsl-danger), 0.12)",
  "--alert-tonal-success-background": "hsla(var(--hsl-success), 0.12)",
  "--alert-tonal-warning-background": "hsla(var(--hsl-warning), 0.12)",
  "--alert-tonal-info-background": "hsla(var(--hsl-info), 0.12)",
  "--alert-tonal-danger-text-color": "var(--color-danger)",
  "--alert-tonal-success-text-color": "var(--color-success)",
  "--alert-tonal-warning-text-color": "var(--color-warning)",
  "--alert-tonal-info-text-color": "var(--color-info)",
  "--alert-message-font-size": "14px",
  "--alert-title-font-size": "16px",
  "--alert-title-font-weight": "500",
  "--alert-message-margin-top": "4px",
  "--alert-message-line-height": "1.5",
  "--alert-title-line-height": "1.5"
};
var stdin_default$17 = {
  "--app-bar-color": "var(--color-primary)",
  "--app-bar-title-padding": "0 12px",
  "--app-bar-title-font-size": "var(--font-size-lg)",
  "--app-bar-text-color": "#fff",
  "--app-bar-height": "54px",
  "--app-bar-left-gap": "6px",
  "--app-bar-right-gap": "6px",
  "--app-bar-border-radius": "4px",
  "--app-bar-font-size": "var(--font-size-lg)",
  "--app-bar-border-bottom": "thin solid var(--color-outline)"
};
var stdin_default$16 = {
  "--avatar-text-color": "#fff",
  "--avatar-background-color": "var(--color-primary)"
};
var stdin_default$15 = {
  "--avatar-group-offset": "-10px"
};
var stdin_default$14 = {
  "--back-top-button-border-radius": "12px",
  "--back-top-right": "40px",
  "--back-top-bottom": "40px",
  "--back-top-button-size": "40px"
};
var stdin_default$13 = {
  "--badge-content-padding": "2px 6px",
  "--badge-content-border": "none",
  "--badge-content-border-radius": "100px",
  "--badge-content-font-size": "12px",
  "--badge-icon-size": "12px",
  "--badge-default-color": "#e0e0e0",
  "--badge-primary-color": "var(--color-primary)",
  "--badge-danger-color": "var(--color-danger)",
  "--badge-success-color": "var(--color-success)",
  "--badge-warning-color": "var(--color-warning)",
  "--badge-info-color": "var(--color-info)",
  "--badge-default-text-color": "#1d1b20",
  "--badge-primary-text-color": "var(--color-on-primary)",
  "--badge-danger-text-color": "var(--color-on-danger)",
  "--badge-success-text-color": "var(--color-on-success)",
  "--badge-warning-text-color": "var(--color-on-warning)",
  "--badge-info-text-color": "var(--color-on-info)",
  "--badge-dot-width": "8px",
  "--badge-dot-height": "8px"
};
var stdin_default$12 = {
  "--bottom-navigation-background-color": "var(--color-surface-container)",
  "--bottom-navigation-fab-border-radius": "12px",
  "--bottom-navigation-height": "50px",
  "--bottom-navigation-variant-height": "66px",
  "--bottom-navigation-z-index": "1",
  "--bottom-navigation-border-color": "var(--color-outline)",
  "--bottom-navigation-fab-offset": "4px"
};
var stdin_default$11 = {
  "--bottom-navigation-item-active-background-color": "var(--color-info-container)",
  "--bottom-navigation-item-inactive-color": "var(--color-on-surface-variant)",
  "--bottom-navigation-item-variant-active-background-color": "var(--color-info-container)",
  "--bottom-navigation-item-variant-active-color": "var(--color-on-info-container)",
  "--bottom-navigation-fab-border-radius": "12px",
  "--bottom-navigation-item-font-size": "var(--font-size-sm)",
  "--bottom-navigation-item-active-color": "var(--color-primary)",
  "--bottom-navigation-item-line-height": "1",
  "--bottom-navigation-item-icon-size": "22px",
  "--bottom-navigation-item-icon-margin-bottom": "5px",
  "--bottom-navigation-item-variant-icon-container-height": "30px",
  "--bottom-navigation-item-variant-icon-container-border-radius": "100px",
  "--bottom-navigation-item-variant-icon-container-max-width": "58px"
};
var stdin_default$10 = {
  "--breadcrumb-inactive-color": "var(--color-on-surface-variant)",
  "--breadcrumb-active-color": "var(--color-primary)",
  "--breadcrumb-separator-margin": "0 10px",
  "--breadcrumb-separator-font-size": "14px"
};
var stdin_default$$ = {
  "--button-default-color": "var(--color-surface-container-low)",
  "--button-default-text-color": "var(--color-primary)",
  "--button-default-icon-color": "var(--color-on-info-container)",
  "--button-default-icon-container-color": "var(--color-surface-container-high)",
  "--button-border-radius": "100px",
  "--button-primary-text-color": "var(--color-on-primary)",
  "--button-danger-text-color": "var(--color-on-danger)",
  "--button-success-text-color": "var(--color-on-success)",
  "--button-warning-text-color": "var(--color-on-warning)",
  "--button-info-text-color": "var(--color-on-info)",
  "--button-primary-color": "var(--color-primary)",
  "--button-danger-color": "var(--color-danger)",
  "--button-success-color": "var(--color-success)",
  "--button-warning-color": "var(--color-warning)",
  "--button-info-color": "var(--color-info)",
  "--button-primary-icon-color": "var(--color-on-primary-container)",
  "--button-danger-icon-color": "var(--color-on-danger-container)",
  "--button-success-icon-color": "var(--color-on-success-container)",
  "--button-warning-icon-color": "var(--color-on-warning-container)",
  "--button-info-icon-color": "var(--color-on-info-container)",
  "--button-primary-icon-container-color": "var(--color-primary-container)",
  "--button-danger-icon-container-color": "var(--color-danger-container)",
  "--button-success-icon-container-color": "var(--color-success-container)",
  "--button-warning-icon-container-color": "var(--color-warning-container)",
  "--button-info-icon-container-color": "var(--color-info-container)",
  "--button-disabled-color": "var(--color-disabled)",
  "--button-disabled-text-color": "var(--color-text-disabled)",
  "--button-mini-padding": "0 8px",
  "--button-small-padding": "0 12px",
  "--button-normal-padding": "0 16px",
  "--button-large-padding": "0 22px",
  "--button-round-padding": "6px",
  "--button-mini-height": "20px",
  "--button-small-height": "28px",
  "--button-normal-height": "36px",
  "--button-large-height": "44px",
  "--button-mini-font-size": "var(--font-size-xs)",
  "--button-small-font-size": "var(--font-size-sm)",
  "--button-normal-font-size": "var(--font-size-md)",
  "--button-large-font-size": "var(--font-size-lg)"
};
var stdin_default$_ = {
  "--card-border-radius": "12px",
  "--card-background": "var(--color-surface-container-low)",
  "--card-filled-background": "var(--color-surface-container-highest)",
  "--card-image-height": "188px",
  "--card-title-color": "#1D1B20",
  "--card-title-font-size": "16px",
  "--card-title-padding": "0 16px",
  "--card-title-margin": "16px 0 0 0",
  "--card-content-padding": "0 16px",
  "--card-content-margin": "16px 0 0 0",
  "--card-content-color": "var(--color-on-surface-variant)",
  "--card-content-font-size": "14px",
  "--card-content-row-margin": "16px 0 0 0",
  "--card-subtitle-color": "var(--color-on-surface-variant)",
  "--card-subtitle-padding": "0 16px",
  "--card-subtitle-margin": "4px 0 0 0",
  "--card-description-margin": "32px 0 0 0",
  "--card-description-padding": "0 16px",
  "--card-description-color": "var(--color-on-surface-variant)",
  "--card-padding": "0 0 16px 0",
  "--card-footer-margin": "32px 0 0 0",
  "--card-title-row-margin": "16px 0 0 0",
  "--card-subtitle-row-margin": "4px 0 0 0",
  "--card-footer-padding": "0 16px",
  "--card-close-button-size": "56px",
  "--card-close-button-primary-color": "var(--color-primary-container)",
  "--card-close-button-text-color": "var(--color-on-primary-container)",
  "--card-close-button-border-radius": "12px",
  "--card-outline-color": "var(--color-outline)",
  "--card-image-width": "100%",
  "--card-row-image-width": "140px",
  "--card-row-height": "140px",
  "--card-subtitle-font-size": "14px",
  "--card-description-font-size": "14px",
  "--card-footer-right": "13px",
  "--card-footer-bottom": "9px",
  "--card-line-height": "22px",
  "--card-row-line-height": "1.5",
  "--card-floating-buttons-bottom": "16px",
  "--card-floating-buttons-right": "16px",
  "--card-floating-buttons-color": "#fff",
  "--card-close-button-icon-size": "24px"
};
var stdin_default$Z = {
  "--cell-description-color": "var(--color-on-surface-variant)",
  "--cell-color": "var(--color-text)",
  "--cell-font-size": "var(--font-size-md)",
  "--cell-description-font-size": "var(--font-size-sm)",
  "--cell-description-margin-top": "4px",
  "--cell-padding": "10px 12px",
  "--cell-min-height": "40px",
  "--cell-border-color": "var(--color-outline)",
  "--cell-border-left": "12px",
  "--cell-border-right": "12px",
  "--cell-icon-right": "8px",
  "--cell-extra-left": "8px"
};
var stdin_default$Y = {
  "--checkbox-unchecked-color": "var(--color-on-surface-variant)",
  "--checkbox-text-color": "var(--color-on-surface-variant)",
  "--checkbox-checked-color": "var(--color-primary)",
  "--checkbox-disabled-color": "var(--color-text-disabled)",
  "--checkbox-error-color": "var(--color-danger)",
  "--checkbox-action-padding": "6px",
  "--checkbox-icon-size": "24px"
};
var stdin_default$X = {
  "--chip-round-radius": "8px",
  "--chip-default-color": "var(--color-surface-container-high)",
  "--chip-default-text-color": "#1D192B",
  "--chip-primary-text-color": "var(--color-on-primary-container)",
  "--chip-danger-text-color": "var(--color-on-danger-container)",
  "--chip-success-text-color": "var(--color-on-success-container)",
  "--chip-warning-text-color": "var(--color-on-warning-container)",
  "--chip-info-text-color": "var(--color-on-info-container)",
  "--chip-primary-color": "var(--color-primary-container)",
  "--chip-danger-color": "var(--color-danger-container)",
  "--chip-success-color": "var(--color-success-container)",
  "--chip-warning-color": "var(--color-warning-container)",
  "--chip-info-color": "var(--color-info-container)",
  "--chip-primary-plain-color": "var(--color-primary)",
  "--chip-danger-plain-color": "var(--color-danger)",
  "--chip-success-plain-color": "var(--color-success)",
  "--chip-warning-plain-color": "var(--color-warning)",
  "--chip-info-plain-color": "var(--color-info)",
  "--chip-border-radius": "2px",
  "--chip-normal-height": "32px",
  "--chip-large-height": "40px",
  "--chip-small-height": "24px",
  "--chip-mini-height": "16px",
  "--chip-normal-padding": "0 10px",
  "--chip-large-padding": "0 17px",
  "--chip-small-padding": "0 6px",
  "--chip-mini-padding": "0 4px",
  "--chip-text-normal-margin": "0 5px",
  "--chip-text-large-margin": "0 5px",
  "--chip-text-small-margin": "0 3px",
  "--chip-text-mini-margin": "0 2px",
  "--chip-mini-font-size": "var(--font-size-xs)",
  "--chip-small-font-size": "var(--font-size-sm)",
  "--chip-normal-font-size": "var(--font-size-md)",
  "--chip-large-font-size": "var(--font-size-lg)"
};
var stdin_default$W = {
  "--code-font-size": "14px",
  "--code-line-height": "1.7"
};
var stdin_default$V = {
  "--collapse-background": "var(--color-surface-container-low)",
  "--collapse-text-color": "#1D1B20",
  "--collapse-header-font-size": "var(--font-size-lg)",
  "--collapse-header-padding": "10px 12px",
  "--collapse-content-font-size": "var(--font-size-md)",
  "--collapse-content-padding": "0 12px 10px",
  "--collapse-item-margin-top": "16px",
  "--collapse-disable-color": "#bdbdbd",
  "--collapse-border-top": "thin solid var(--color-outline)"
};
var stdin_default$U = {
  "--countdown-text-color": "var(--color-text)",
  "--countdown-text-font-size": "var(--font-size-lg)"
};
var stdin_default$T = {
  "--counter-padding": "0 4px",
  "--counter-font-color": "#fff",
  "--counter-background": "var(--color-primary)",
  "--counter-input-width": "28px",
  "--counter-input-margin": "0 4px",
  "--counter-input-font-size": "14px",
  "--counter-button-size": "28px",
  "--counter-button-text-color": "#fff",
  "--counter-button-icon-size": "100%",
  "--counter-disabled-color": "var(--color-disabled)",
  "--counter-disabled-opacity": "var(--opacity-disabled)",
  "--counter-error-color": "var(--color-danger)"
};
var stdin_default$S = {
  "--date-picker-title-background": "var(--color-surface-container-high)",
  "--date-picker-title-color": "#1D1B20",
  "--date-picker-title-hint-color": "var(--color-on-surface-variant)",
  "--date-picker-body-background-color": "var(--color-surface-container-high)",
  "--date-picker-main-color": "#1D1B20",
  "--date-picker-border-radius": "20px",
  "--date-picker-title-padding": "20px 20px 16px",
  "--date-picker-actions-padding": "20px",
  "--day-picker-head-item-color": "#1D1B20",
  "--date-picker-header-arrow-filter": "opacity(1)",
  "--date-picker-header-padding": "0 0 16px",
  "--date-picker-body-height": "300px",
  "--date-picker-body-padding": "0 14px 16px",
  "--date-picker-header-color": "var(--color-on-surface-variant)",
  "--date-picker-font-size": "var(--font-size-md)",
  "--date-picker-min-width": "290px",
  "--date-picker-title-hint-font-size": "var(--font-size-md)",
  "--date-picker-title-height": "105px",
  "--date-picker-title-year-font-size": "var(--font-size-md)",
  "--date-picker-title-year-font-weight": "500",
  "--date-picker-title-year-margin-bottom": "8px",
  "--date-picker-title-date-height": "48px",
  "--date-picker-title-date-font-size": "34px",
  "--date-picker-title-date-font-weight": "500",
  "--date-picker-title-date-range-font-size": "20px",
  "--date-picker-title-date-justify-content": "normal",
  "--month-picker-padding": "0 12px",
  "--month-picker-item-width": "33%",
  "--month-picker-item-height": "56px",
  "--month-picker-item-button-max-width": "140px",
  "--year-picker-padding": "0 12px",
  "--year-picker-item-width": "33%",
  "--year-picker-item-height": "56px",
  "--year-picker-item-button-max-width": "140px",
  "--day-picker-content-item-width": "14.28%",
  "--day-picker-content-item-font-size": "var(--font-size-sm)",
  "--day-picker-content-item-padding": "2px 0",
  "--day-picker-content-item-button-width": "32px",
  "--day-picker-content-item-button-height": "32px",
  "--day-picker-content-item-button-font-size": "var(--font-size-sm)",
  "--day-picker-head-item-padding": "8px 0",
  "--day-picker-head-item-font-weight": "600"
};
var stdin_default$R = {
  "--dialog-width": "312px",
  "--dialog-background": "var(--color-surface-container-high)",
  "--dialog-title-color": "#1D1B20",
  "--dialog-message-color": "var(--color-on-surface-variant)",
  "--dialog-border-radius": "28px",
  "--dialog-title-padding": "24px 24px 0",
  "--dialog-message-padding": "16px 24px 24px",
  "--dialog-actions-padding": "0 24px 24px",
  "--dialog-title-font-size": "20px",
  "--dialog-button-margin-left": "8px",
  "--dialog-message-line-height": "24px",
  "--dialog-message-font-size": "var(--font-size-md)",
  "--dialog-confirm-button-color": "var(--color-primary)",
  "--dialog-cancel-button-color": "var(--color-primary)"
};
var stdin_default$Q = {
  "--divider-color": "var(--color-outline)",
  "--divider-text-color": "#888",
  "--divider-text-margin": "8px 0",
  "--divider-text-padding": "0 8px",
  "--divider-inset": "72px"
};
var stdin_default$P = {
  "--fab-trigger-border-radius": "16px",
  "--fab-action-size": "40px",
  "--fab-action-border-radius": "12px",
  "--fab-top": "70px",
  "--fab-bottom": "16px",
  "--fab-left": "16px",
  "--fab-right": "16px",
  "--fab-trigger-size": "56px",
  "--fab-trigger-inactive-icon-size": "26px",
  "--fab-trigger-active-icon-size": "22px",
  "--fab-actions-padding": "10px 0",
  "--fab-action-margin": "6px",
  "--fab-transition-standard-easing": "cubic-bezier(0.4, 0, 0.2, 1)"
};
var stdin_default$O = {
  "--field-decorator-text-color": "#1D1B20",
  "--field-decorator-blur-color": "#79747E",
  "--field-decorator-error-color": "var(--color-danger)",
  "--field-decorator-focus-color": "var(--color-primary)",
  "--field-decorator-placeholder-size": "16px",
  "--field-decorator-icon-size": "20px",
  "--field-decorator-line-size": "1px",
  "--field-decorator-line-focus-size": "2px",
  "--field-decorator-line-border-radius": "4px",
  "--field-decorator-disabled-color": "var(--color-text-disabled)",
  "--field-decorator-standard-normal-margin-top": "22px",
  "--field-decorator-standard-normal-margin-bottom": "4px",
  "--field-decorator-standard-normal-icon-margin-top": "22px",
  "--field-decorator-standard-normal-icon-margin-bottom": "4px",
  "--field-decorator-standard-normal-non-hint-margin-top": "4px",
  "--field-decorator-standard-small-margin-top": "18px",
  "--field-decorator-standard-small-margin-bottom": "4px",
  "--field-decorator-standard-small-icon-margin-top": "18px",
  "--field-decorator-standard-small-icon-margin-bottom": "4px",
  "--field-decorator-standard-small-non-hint-margin-top": "2px",
  "--field-decorator-outlined-normal-margin-top": "16px",
  "--field-decorator-outlined-normal-margin-bottom": "16px",
  "--field-decorator-outlined-normal-padding-left": "16px",
  "--field-decorator-outlined-normal-padding-right": "16px",
  "--field-decorator-outlined-normal-placeholder-space": "4px",
  "--field-decorator-outlined-normal-icon-margin-top": "16px",
  "--field-decorator-outlined-normal-icon-margin-bottom": "16px",
  "--field-decorator-outlined-small-margin-top": "8px",
  "--field-decorator-outlined-small-margin-bottom": "8px",
  "--field-decorator-outlined-small-padding-left": "12px",
  "--field-decorator-outlined-small-padding-right": "12px",
  "--field-decorator-outlined-small-placeholder-space": "2px",
  "--field-decorator-outlined-small-icon-margin-top": "8px",
  "--field-decorator-outlined-small-icon-margin-bottom": "8px"
};
var stdin_default$N = {
  "--floating-panel-background": "var(--color-surface-container-low)",
  "--floating-panel-toolbar-background": "#79747E",
  "--floating-panel-toolbar-width": "32px",
  "--floating-panel-toolbar-height": "4px",
  "--floating-panel-header-height": "36px",
  "--floating-panel-z-index": "999",
  "--floating-panel-border-top": "none",
  "--floating-panel-border-radius": "0",
  "--floating-panel-toolbar-border-radius": "10px",
  "--floating-panel-transition-timing-function": "cubic-bezier(0.18, 0.89, 0.32, 1.28)"
};
var stdin_default$M = {
  "--form-details-error-message-color": "var(--color-danger)",
  "--form-details-extra-message-color": "#888",
  "--form-details-margin-top": "6px",
  "--form-details-font-size": "12px",
  "--form-details-message-margin-right": "4px"
};
var stdin_default$L = {
  "--hover-overlay-opacity": "var(--opacity-hover)",
  "--hover-overlay-focusing-opacity": "var(--opacity-focus)"
};
var stdin_default$K = {
  "--icon-size": "20px"
};
var stdin_default$J = {
  "--image-preview-swipe-indicators-text-color": "#ddd",
  "--image-preview-swipe-indicators-padding": "16px 0",
  "--image-preview-zoom-container-background": "#000",
  "--image-preview-close-icon-top": "14px",
  "--image-preview-close-icon-right": "14px",
  "--image-preview-extra-top": "14px",
  "--image-preview-extra-left": "14px",
  "--image-preview-close-icon-size": "22px",
  "--image-preview-close-icon-color": "#fff"
};
var stdin_default$I = {
  "--index-bar-list-right": "0",
  "--index-bar-list-top": "50%",
  "--index-bar-list-left": "auto",
  "--index-bar-list-bottom": "auto",
  "--index-bar-list-transform": "translate(0, -50%)",
  "--index-bar-list-item-font-size": "var(--font-size-xs)",
  "--index-bar-list-item-color": "var(--color-primary)",
  "--index-bar-list-item-active-color": "var(--color-danger)",
  "--index-bar-list-item-height": "14px",
  "--index-bar-list-item-padding": "0 10px"
};
var stdin_default$H = {
  "--input-input-height": "24px",
  "--input-input-font-size": "16px",
  "--input-textarea-height": "auto"
};
var stdin_default$G = {
  "--link-default-color": "#000",
  "--link-primary-color": "var(--color-primary)",
  "--link-danger-color": "var(--color-danger)",
  "--link-success-color": "var(--color-success)",
  "--link-warning-color": "var(--color-warning)",
  "--link-info-color": "var(--color-info)",
  "--link-disabled-color": "var(--color-text-disabled)",
  "--link-font-size": "var(--font-size-md)",
  "--link-focus-opacity": "0.8"
};
var stdin_default$F = {
  "--list-loading-height": "50px",
  "--list-finished-height": "50px",
  "--list-error-height": "50px",
  "--list-loading-color": "#888",
  "--list-finished-color": "#888",
  "--list-error-color": "#888",
  "--list-loading-font-size": "var(--font-size-md)",
  "--list-finished-font-size": "var(--font-size-md)",
  "--list-error-font-size": "var(--font-size-md)"
};
var stdin_default$E = {
  "--loading-color": "var(--color-primary)",
  "--loading-opacity": "0.38",
  "--loading-desc-margin": "8px 0 0",
  "--loading-desc-color": "var(--color-primary)"
};
var stdin_default$D = {
  "--loading-bar-color": "var(--color-primary)",
  "--loading-bar-error-color": "var(--color-danger)",
  "--loading-bar-height": "3px"
};
var stdin_default$C = {
  "--menu-background-color": "var(--color-surface-container)",
  "--menu-border-radius": "4px"
};
var stdin_default$B = {
  "--menu-option-text-color": "#1D1B20",
  "--menu-option-normal-height": "38px",
  "--menu-option-small-height": "30px",
  "--menu-option-mini-height": "24px",
  "--menu-option-large-height": "46px",
  "--menu-option-padding": "0 12px",
  "--menu-option-normal-font-size": "var(--font-size-md)",
  "--menu-option-small-font-size": "var(--font-size-sm)",
  "--menu-option-mini-font-size": "var(--font-size-xs)",
  "--menu-option-large-font-size": "var(--font-size-lg)",
  "--menu-option-selected-background": "var(--color-primary)",
  "--menu-option-disabled-color": "var(--color-text-disabled)"
};
var stdin_default$A = {
  "--menu-select-menu-background-color": "var(--color-surface-container)",
  "--menu-select-menu-border-radius": "4px",
  "--menu-select-menu-max-height": "278px",
  "--menu-select-menu-padding": "0"
};
var stdin_default$z = {
  "--option-text-color": "#1D1B20",
  "--option-height": "38px",
  "--option-padding": "0 12px",
  "--option-font-size": "16px",
  "--option-selected-background": "var(--field-decorator-focus-color)",
  "--option-disabled-color": "var(--color-text-disabled)"
};
var stdin_default$y = {
  "--overlay-background-color": "rgba(0, 0, 0, 0.6)"
};
var stdin_default$x = {
  "--pagination-text-color": "#555",
  "--pagination-font-size": "var(--font-size-md)",
  "--pagination-active-color": "var(--color-on-primary)",
  "--pagination-active-bg-color": "var(--color-primary)",
  "--pagination-hover-bg-color": "rgba(85, 85, 85, 0.15)",
  "--pagination-total-margin": "0 12px",
  "--pagination-total-line-height": "24px",
  "--pagination-item-width": "32px",
  "--pagination-item-height": "32px",
  "--pagination-item-margin": "0 6px",
  "--pagination-item-background": "#fff",
  "--pagination-item-border-radius": "4px",
  "--pagination-item-simple-border-radius": "50%",
  "--pagination-input-width": "32px",
  "--pagination-disabled-color": "var(--color-text-disabled)",
  "--pagination-bg-disabled-color": "var(--color-disabled)",
  "--pagination-size-line-height": "24px",
  "--pagination-size-padding": "0 6px"
};
var stdin_default$w = {
  "--paper-background": "var(--color-surface-container-low)",
  "--paper-border-radius": "12px"
};
var stdin_default$v = {
  "--picker-background": "var(--color-body)",
  "--picker-cancel-button-text-color": "var(--color-primary)",
  "--picker-mask-background-image": "linear-gradient(180deg, rgba(254, 247, 255, 0.9), rgba(254, 247, 255, 0.4)), linear-gradient(0deg, rgba(254, 247, 255, 0.9), rgba(254, 247, 255, 0.4))",
  "--picker-toolbar-height": "44px",
  "--picker-confirm-button-text-color": "var(--color-primary)",
  "--picker-picked-border": "1px solid var(--color-outline)",
  "--picker-title-font-size": "var(--font-size-lg)",
  "--picker-title-text-color": "#555",
  "--picker-option-font-size": "var(--font-size-lg)",
  "--picker-option-text-color": "#555",
  "--picker-toolbar-padding": "0 4px"
};
var stdin_default$u = {
  "--popup-content-background-color": "var(--color-surface-container-high)",
  "--popup-overlay-background-color": "rgba(0, 0, 0, 0.6)"
};
var stdin_default$t = {
  "--progress-font-size": "var(--font-size-sm)",
  "--progress-track-color": "#d8d8d8",
  "--progress-label-color": "#555",
  "--progress-background": "var(--color-primary)",
  "--progress-default-color": "#f5f5f5",
  "--progress-primary-color": "var(--color-primary)",
  "--progress-danger-color": "var(--color-danger)",
  "--progress-success-color": "var(--color-success)",
  "--progress-warning-color": "var(--color-warning)",
  "--progress-info-color": "var(--color-info)",
  "--progress-linear-border-radius": "0px"
};
var stdin_default$s = {
  "--pull-refresh-background": "var(--color-body)",
  "--pull-refresh-size": "40px",
  "--pull-refresh-color": "var(--color-primary)",
  "--pull-refresh-success-color": "var(--color-success)",
  "--pull-refresh-icon-size": "25px"
};
var stdin_default$r = {
  "--radio-unchecked-color": "var(--color-on-surface-variant)",
  "--radio-text-color": "var(--color-on-surface-variant)",
  "--radio-checked-color": "var(--color-primary)",
  "--radio-disabled-color": "var(--color-text-disabled)",
  "--radio-error-color": "var(--color-danger)",
  "--radio-icon-size": "24px",
  "--radio-action-padding": "6px"
};
var stdin_default$q = {
  "--rate-color": "var(--color-on-surface-variant)",
  "--rate-size": "24px",
  "--rate-disabled-color": "var(--color-text-disabled)",
  "--rate-error-color": "var(--color-danger)",
  "--rate-action-padding": "4px",
  "--rate-primary-color": "var(--color-primary)"
};
var stdin_default$p = {
  "--result-background": "var(--color-body)",
  "--result-border-radius": "12px",
  "--result-title-color": "#1D1B20",
  "--result-description-color": "var(--color-on-surface-variant)",
  "--result-info-border-color": "rgba(98, 91, 113, 0.3)",
  "--result-success-border-color": "rgba(83, 101, 37, 0.3)",
  "--result-error-border-color": "rgba(179, 38, 30, 0.3)",
  "--result-warning-border-color": "rgba(125, 82, 96, 0.3)",
  "--result-padding": "24px",
  "--result-title-font-size": "32px",
  "--result-title-margin": "15px 0 0 0",
  "--result-image-size": "80px",
  "--result-title-font-weight": "500",
  "--result-description-margin": "10px 0 0 0",
  "--result-description-font-size": "14px",
  "--result-description-line-height": "1.6",
  "--result-info-color": "var(--color-info)",
  "--result-success-color": "var(--color-success)",
  "--result-error-color": "var(--color-danger)",
  "--result-warning-color": "var(--color-warning)",
  "--result-question-color": "#607d8b",
  "--result-question-border-color": "rgba(96, 125, 139, 0.3)",
  "--result-empty-color": "#9e9e9e",
  "--result-empty-border-color": "rgba(158, 158, 158, 0.3)"
};
var stdin_default$o = {
  "--ripple-cubic-bezier": "cubic-bezier(0.68, 0.01, 0.62, 0.6)",
  "--ripple-color": "currentColor"
};
var stdin_default$n = {
  "--select-scroller-background": "var(--color-surface-container)",
  "--select-scroller-border-radius": "4px",
  "--select-scroller-padding": "6px 0",
  "--select-scroller-max-height": "278px",
  "--select-chip-margin": "5px 5px 0",
  "--select-arrow-size": "20px",
  "--select-standard-menu-margin": `calc(var(--field-decorator-placeholder-size) * 0.75 + 12px) 0 0 0`,
  "--select-label-font-size": "16px"
};
var stdin_default$m = {
  "--skeleton-content-padding": "16px",
  "--skeleton-card-height": "160px",
  "--skeleton-card-border-radius": "4px",
  "--skeleton-card-margin-bottom": "16px",
  "--skeleton-card-background-color": "rgba(0, 0, 0, 0.12)",
  "--skeleton-animation-background": "linear-gradient(90deg, hsla(0, 0%, 100%, 0), hsla(0, 0%, 100%, 0.3), hsla(0, 0%, 100%, 0))",
  "--skeleton-avatar-size": "34px",
  "--skeleton-avatar-border-radius": "50%",
  "--skeleton-avatar-margin-right": "16px",
  "--skeleton-avatar-background-color": "rgba(0, 0, 0, 0.12)",
  "--skeleton-title-width": "50%",
  "--skeleton-title-border-radius": "10px",
  "--skeleton-title-background-color": "rgba(0, 0, 0, 0.12)",
  "--skeleton-row-height": "12px",
  "--skeleton-row-border-radius": "10px",
  "--skeleton-row-margin-top": "10px"
};
var stdin_default$l = {
  "--slider-thumb-size": "16px",
  "--slider-track-height": "4px",
  "--slider-track-background": "var(--color-surface-container-highest)",
  "--slider-track-fill-border-radius": "4px",
  "--slider-track-border-radius": "4px",
  "--slider-error-color": "var(--color-danger)",
  "--slider-track-fill-background": "var(--color-primary)",
  "--slider-thumb-block-background": "var(--color-primary)",
  "--slider-thumb-ripple-background": "var(--color-primary)",
  "--slider-thumb-label-background": "var(--color-primary)",
  "--slider-thumb-label-font-size": "var(--font-size-sm)",
  "--slider-thumb-label-text-color": "var(--color-on-primary)",
  "--slider-disabled-opacity": "var(--opacity-disabled)"
};
var stdin_default$k = {
  "--snackbar-color": "#F5EFF7",
  "--snackbar-background": "var(--color-inverse-surface)",
  "--snackbar-width": "256px",
  "--snackbar-border-radius": "4px",
  "--snackbar-font-size": "var(--font-size-md)",
  "--snackbar-margin": "6px 24px",
  "--snackbar-border-color": "currentColor",
  "--snackbar-success-background": "var(--color-success)",
  "--snackbar-info-background": "var(--color-info)",
  "--snackbar-error-background": "var(--color-danger)",
  "--snackbar-warning-background": "var(--color-warning)",
  "--snackbar-content-padding": "14px 16px",
  "--snackbar-action-margin": "0 8px",
  "--snackbar-vertical-action-margin": "0 8px 8px 0",
  "--snackbar-icon-margin": "0 8px"
};
var stdin_default$j = {
  "--space-size-mini-y": "4px",
  "--space-size-mini-x": "4px",
  "--space-size-small-y": "6px",
  "--space-size-small-x": "6px",
  "--space-size-normal-y": "8px",
  "--space-size-normal-x": "12px",
  "--space-size-large-y": "12px",
  "--space-size-large-x": "20px"
};
var stdin_default$i = {
  "--step-tag-size": "20px",
  "--step-tag-background": "#9e9e9e",
  "--step-tag-font-size": "var(--font-size-md)",
  "--step-tag-color": "var(--color-on-primary)",
  "--step-tag-active-color": "var(--color-primary)",
  "--step-tag-margin": "4px 0",
  "--step-tag-icon-size": "var(--font-size-lg)",
  "--step-content-font-size": "var(--font-size-md)",
  "--step-content-color": "rgba(0, 0, 0, 0.38)",
  "--step-content-active-color": "#000",
  "--step-line-background": "#000",
  "--step-line-gap": "8px",
  "--step-vertical-tag-margin": "0 4px",
  "--step-vertical-min-height": "50px"
};
var stdin_default$h = {
  "--swipe-indicator-color": "#fff",
  "--swipe-indicators-offset": "10px",
  "--swipe-indicator-offset": "4px",
  "--swipe-navigation-z-index": "9",
  "--swipe-navigation-button-width": "36px",
  "--swipe-navigation-button-height": "36px",
  "--swipe-navigation-button-border-radius": "50%",
  "--swipe-navigation-icon-size": "20px",
  "--swipe-navigation-prev-left": "8px",
  "--swipe-navigation-next-right": "8px",
  "--swipe-navigation-prev-top": "8px",
  "--swipe-navigation-next-bottom": "8px"
};
var stdin_default$g = {
  "--switch-track-background": "var(--color-surface-container-low)",
  "--switch-handle-background": "var(--color-surface-container-low)",
  "--switch-track-active-background": "var(--color-primary)",
  "--switch-track-error-background": "var(--color-danger)",
  "--switch-ripple-color": "var(--color-primary)",
  "--switch-handle-color": "var(--color-primary)",
  "--switch-handle-active-color": "var(--color-on-primary)",
  "--switch-handle-active-background": "var(--color-primary)",
  "--switch-handle-error-background": "var(--color-danger)",
  "--switch-disabled-opacity": "var(--opacity-disabled)",
  "--switch-variant-width": "52px",
  "--switch-variant-height": "32px",
  "--switch-variant-track-background": "var(--color-surface-container-highest)",
  "--switch-variant-handle-width": "24px",
  "--switch-variant-handle-height": "24px",
  "--switch-variant-track-border-color": "#79747E",
  "--switch-variant-handle-color": "var(--color-on-primary)",
  "--switch-variant-handle-active-color": "var(--color-primary)",
  "--switch-variant-handle-background": "#79747E",
  "--switch-variant-handle-active-background": "var(--color-on-primary)",
  "--switch-width": "40px",
  "--switch-height": "24px",
  "--switch-track-width": "38px",
  "--switch-track-height": "14.4px",
  "--switch-track-border-radius": "calc(20px * 2 / 3)",
  "--switch-handle-width": "20px",
  "--switch-handle-height": "20px",
  "--switch-ripple-size": "40px",
  "--switch-ripple-left": "-10px",
  "--switch-ripple-active-left": "10px",
  "--switch-loading-size": "16px",
  "--switch-variant-ripple-left": "-4px",
  "--switch-variant-ripple-active-left": "16px"
};
var stdin_default$f = {
  "--tab-inactive-color": "var(--color-on-surface-variant)",
  "--tab-padding": "12px",
  "--tab-active-color": "var(--color-primary)",
  "--tab-disabled-color": "var(--color-text-disabled)",
  "--tab-font-size": "var(--font-size-md)",
  "--tab-font-weight": "400",
  "--tab-active-font-size": "var(--font-size-md)",
  "--tab-active-font-weight": "400"
};
var stdin_default$e = {
  "--table-background": "var(--color-surface-container-low)",
  "--table-tbody-tr-hover-background": "var(--color-surface-container-low)",
  "--table-border-radius": "2px",
  "--table-thead-border-bottom": "thin solid var(--color-outline)",
  "--table-thead-th-text-color": "rgba(0, 0, 0, 0.6)",
  "--table-thead-th-text-align": "left",
  "--table-thead-th-font-size": "14px",
  "--table-thead-tr-border-bottom": "thin solid var(--color-outline)",
  "--table-tbody-tr-border-bottom": "thin solid var(--color-outline)",
  "--table-tbody-td-text-color": "#555",
  "--table-tbody-td-font-size": "16px",
  "--table-tbody-td-text-align": "left",
  "--table-row-height": "46px",
  "--table-row-padding": "0 16px",
  "--table-footer-border-top": "thin solid var(--color-outline)"
};
var stdin_default$d = {
  "--tabs-background": "var(--color-body)",
  "--tabs-item-horizontal-height": "44px",
  "--tabs-item-vertical-height": "66px",
  "--tabs-radius": "2px",
  "--tabs-padding": "12px",
  "--tabs-indicator-size": "2px",
  "--tabs-indicator-border-radius": "0",
  "--tabs-indicator-background": "var(--color-primary)",
  "--tabs-indicator-inner-size": "100%"
};
var stdin_default$c = {
  "--time-picker-title-color": "#1D1B20",
  "--time-picker-title-hint-color": "var(--color-on-surface-variant)",
  "--time-picker-clock-container-background": "var(--color-surface-container-highest)",
  "--time-picker-title-background": "var(--color-surface-container-high)",
  "--time-picker-body-background": "var(--color-surface-container-high)",
  "--time-picker-clock-item-text-color": "#1D1B20",
  "--time-picker-border-radius": "20px",
  "--time-picker-title-padding": "20px 20px 16px",
  "--time-picker-actions-padding": "20px",
  "--time-picker-title-margin-bottom": "20px",
  "--time-picker-title-time-font-size": "40px",
  "--time-picker-title-ampm-border-radius": "8px",
  "--time-picker-title-time-padding": "8px 12px",
  "--time-picker-title-time-border-radius": "8px",
  "--time-picker-title-ampm-border": "thin solid #79747e",
  "--time-picker-title-ampm-button-padding": "8px",
  "--time-picker-title-time-background": "var(--color-surface-container-highest)",
  "--time-picker-title-inactive-opacity": "1",
  "--time-picker-title-time-active-background": "var(--color-primary-container)",
  "--time-picker-title-ampm-button-active-background": "var(--color-warning-container)",
  "--time-picker-font-size": "var(--font-size-md)",
  "--time-picker-min-width": "290px",
  "--time-picker-title-height": "105px",
  "--time-picker-title-hint-font-size": "14px",
  "--time-picker-title-time-margin": "0 5px",
  "--time-picker-title-ampm-margin-left": "10px",
  "--time-picker-clock-left": "27px",
  "--time-picker-clock-right": "27px",
  "--time-picker-clock-top": "27px",
  "--time-picker-clock-bottom": "27px",
  "--time-picker-clock-container-width": "256px",
  "--time-picker-clock-container-height": "256px",
  "--time-picker-clock-hand-height": "calc(50% - 4px)",
  "--time-picker-clock-hand-width": "2px",
  "--time-picker-clock-hand-bottom": "50%",
  "--time-picker-clock-hand-left": "calc(50% - 1px)",
  "--time-picker-clock-hand-background": "var(--color-primary)",
  "--time-picker-clock-hand-border-color": "var(--color-primary)",
  "--time-picker-clock-hand-before-width": "10px",
  "--time-picker-clock-hand-before-height": "10px",
  "--time-picker-clock-hand-before-border-width": "2px",
  "--time-picker-clock-hand-after-width": "4px",
  "--time-picker-clock-hand-after-height": "4px",
  "--time-picker-clock-item-height": "32px",
  "--time-picker-clock-item-width": "32px",
  "--time-picker-clock-item-active-background": "var(--color-primary)",
  "--time-picker-clock-item-active-color": "var(--color-on-primary)",
  "--time-picker-clock-item-disable-color": "rgba(0, 0, 0, 0.26)",
  "--time-picker-clock-item-disable-background": "#bdbdbd",
  "--time-picker-inner-left": "36px",
  "--time-picker-inner-right": "36px",
  "--time-picker-inner-top": "36px",
  "--time-picker-inner-bottom": "36px",
  "--time-picker-body-height": "288px",
  "--time-picker-title-time-container-justify-content": "flex-end"
};
var stdin_default$b = {
  "--tooltip-default-color": "var(--color-inverse-surface)",
  "--tooltip-opacity": "1",
  "--tooltip-border-radius": "4px",
  "--tooltip-font-size": "14px",
  "--tooltip-padding": "8px 16px",
  "--tooltip-offset": "10px",
  "--tooltip-primary-color": "var(--color-primary)",
  "--tooltip-info-color": "var(--color-info)",
  "--tooltip-success-color": "var(--color-success)",
  "--tooltip-warning-color": "var(--color-warning)",
  "--tooltip-danger-color": "var(--color-danger)",
  "--tooltip-default-text-color": "#fff",
  "--tooltip-primary-text-color": "var(--color-on-primary)",
  "--tooltip-info-text-color": "var(--color-on-info)",
  "--tooltip-success-text-color": "var(--color-on-success)",
  "--tooltip-warning-text-color": "var(--color-on-warning)",
  "--tooltip-danger-text-color": "var(--color-on-danger)"
};
var stdin_default$a = {
  "--uploader-file-border-radius": "8px",
  "--uploader-action-background": "var(--color-surface-container-low)",
  "--uploader-file-name-background": "var(--color-surface-container-low)",
  "--uploader-file-cover-background": "var(--color-surface-container-low)",
  "--uploader-action-icon-color": "var(--color-on-surface-variant)",
  "--uploader-file-name-color": "var(--color-on-surface-variant)",
  "--uploader-action-icon-size": "24px",
  "--uploader-action-margin": "0 10px 10px 0",
  "--uploader-file-size": "80px",
  "--uploader-file-margin": "0 10px 10px 0",
  "--uploader-file-name-font-size": "12px",
  "--uploader-file-name-padding": "10px",
  "--uploader-file-text-align": "center",
  "--uploader-file-close-background": "rgba(0, 0, 0, 0.3)",
  "--uploader-file-close-size": "24px",
  "--uploader-file-close-icon-font-size": "14px",
  "--uploader-file-close-icon-color": "#fff",
  "--uploader-file-cover-fit": "cover",
  "--uploader-preview-video-width": "100vw",
  "--uploader-preview-video-height": "100vw",
  "--uploader-file-indicator-height": "4px",
  "--uploader-file-indicator-normal-color": "var(--color-disabled)",
  "--uploader-file-indicator-success-color": "var(--color-success)",
  "--uploader-file-indicator-error-color": "var(--color-danger)",
  "--uploader-file-progress-color": "var(--color-primary)",
  "--uploader-disabled-color": "var(--color-disabled)",
  "--uploader-disabled-text-color": "var(--color-text-disabled)",
  "--uploader-loading-background": "linear-gradient(90deg, hsla(0, 0%, 100%, 0), hsla(0, 0%, 100%, 0.3), hsla(0, 0%, 100%, 0))"
};
var stdin_default$9 = {
  "--watermark-content-color": "#808080"
};
var __defProp$1 = Object.defineProperty;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key3, value) => key3 in obj ? __defProp$1(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var stdin_default$8 = __spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1({
  "--color-scheme": "light",
  "--font-size-xs": "10px",
  "--font-size-sm": "12px",
  "--font-size-md": "14px",
  "--font-size-lg": "16px",
  "--icon-size-xs": "16px",
  "--icon-size-sm": "18px",
  "--icon-size-md": "20px",
  "--icon-size-lg": "22px",
  "--hsl-body": "293, 100%, 98%",
  "--color-body": "hsla(var(--hsl-body), 1)",
  "--hsl-text": "0, 0%, 0%",
  "--color-text": "hsla(var(--hsl-text), 1)",
  "--hsl-primary": "256, 34%, 48%",
  "--color-primary": "hsla(var(--hsl-primary), 1)",
  "--hsl-info": "259, 11%, 40%",
  "--color-info": "hsla(var(--hsl-info), 1)",
  "--hsl-success": "77, 46%, 27%",
  "--color-success": "hsla(var(--hsl-success), 1)",
  "--hsl-warning": "340, 21%, 41%",
  "--color-warning": "hsla(var(--hsl-warning), 1)",
  "--hsl-danger": "3, 71%, 41%",
  "--color-danger": "hsla(var(--hsl-danger), 1)",
  "--hsl-on-primary": "0, 0%, 100%",
  "--color-on-primary": "hsla(var(--hsl-on-primary), 1)",
  "--hsl-on-info": "0, 0%, 100%",
  "--color-on-info": "hsla(var(--hsl-on-info), 1)",
  "--hsl-on-success": "0, 0%, 100%",
  "--color-on-success": "hsla(var(--hsl-on-success), 1)",
  "--hsl-on-warning": "0, 0%, 100%",
  "--color-on-warning": "hsla(var(--hsl-on-warning), 1)",
  "--hsl-on-danger": "0, 0%, 100%",
  "--color-on-danger": "hsla(var(--hsl-on-danger), 1)",
  "--hsl-primary-container": "263, 100%, 93%",
  "--color-primary-container": "hsla(var(--hsl-primary-container), 1)",
  "--hsl-info-container": "263, 65%, 92%",
  "--color-info-container": "hsla(var(--hsl-info-container), 1)",
  "--hsl-success-container": "77, 68%, 77%",
  "--color-success-container": "hsla(var(--hsl-success-container), 1)",
  "--hsl-warning-container": "342, 100%, 92%",
  "--color-warning-container": "hsla(var(--hsl-warning-container), 1)",
  "--hsl-danger-container": "4, 71%, 92%",
  "--color-danger-container": "hsla(var(--hsl-danger-container), 1)",
  "--hsl-on-primary-container": "261, 100%, 18%",
  "--color-on-primary-container": "hsla(var(--hsl-on-primary-container), 1)",
  "--hsl-on-info-container": "253, 26%, 13%",
  "--color-on-info-container": "hsla(var(--hsl-on-info-container), 1)",
  "--hsl-on-success-container": "79, 100%, 6%",
  "--color-on-success-container": "hsla(var(--hsl-on-success-container), 1)",
  "--hsl-on-warning-container": "338, 48%, 13%",
  "--color-on-warning-container": "hsla(var(--hsl-on-warning-container), 1)",
  "--hsl-on-danger-container": "3, 71%, 15%",
  "--color-on-danger-container": "hsla(var(--hsl-on-danger-container), 1)",
  "--hsl-disabled": "0, 0%, 88%",
  "--color-disabled": "hsla(var(--hsl-disabled), 1)",
  "--hsl-text-disabled": "0, 0%, 67%",
  "--color-text-disabled": "hsla(var(--hsl-text-disabled), 1)",
  "--hsl-surface-container": "276, 38%, 95%",
  "--color-surface-container": "hsla(var(--hsl-surface-container), 1)",
  "--hsl-surface-container-low": "278, 44%, 96%",
  "--color-surface-container-low": "hsla(var(--hsl-surface-container-low), 1)",
  "--hsl-surface-container-high": "276, 25%, 92%",
  "--color-surface-container-high": "hsla(var(--hsl-surface-container-high), 1)",
  "--hsl-surface-container-highest": "280, 17%, 90%",
  "--color-surface-container-highest": "hsla(var(--hsl-surface-container-highest), 1)",
  "--hsl-inverse-surface": "270, 6%, 20%",
  "--color-inverse-surface": "hsla(var(--hsl-inverse-surface), 1)",
  "--hsl-outline": "270, 11%, 79%",
  "--color-outline": "hsla(var(--hsl-outline), 1)",
  "--hsl-on-surface-variant": "264, 7%, 29%",
  "--color-on-surface-variant": "hsla(var(--hsl-on-surface-variant), 1)",
  "--opacity-disabled": "0.6",
  "--opacity-hover": "0.12",
  "--opacity-focus": "0.2",
  "--cubic-bezier": "cubic-bezier(0.25, 0.8, 0.5, 1)",
  "--shadow-key-umbra-opacity": "rgba(0, 0, 0, 0.2)",
  "--shadow-key-penumbra-opacity": "rgba(0, 0, 0, 0.14)",
  "--shadow-key-ambient-opacity": "rgba(0, 0, 0, 0.12)"
}, stdin_default$$), stdin_default$18), stdin_default$L), stdin_default$C), stdin_default$A), stdin_default$B), stdin_default$P), stdin_default$10), stdin_default$G), stdin_default$Z), stdin_default$w), stdin_default$16), stdin_default$O), stdin_default$Y), stdin_default$r), stdin_default$_), stdin_default$X), stdin_default$b), stdin_default$d), stdin_default$f), stdin_default$e), stdin_default$V), stdin_default$p), stdin_default$12), stdin_default$11), stdin_default$k), stdin_default$19), stdin_default$R), stdin_default$s), stdin_default$u), stdin_default$v), stdin_default$N), stdin_default$14), stdin_default$n), stdin_default$z), stdin_default$l), stdin_default$a), stdin_default$c), stdin_default$S), stdin_default$g), stdin_default$q), stdin_default$15), stdin_default$13), stdin_default$U), stdin_default$T), stdin_default$Q), stdin_default$M), stdin_default$K), stdin_default$J), stdin_default$I), stdin_default$H), stdin_default$F), stdin_default$E), stdin_default$D), stdin_default$y), stdin_default$x), stdin_default$t), stdin_default$o), stdin_default$m), stdin_default$j), stdin_default$i), stdin_default$h), stdin_default$9), stdin_default$17), stdin_default$W);
function toViewport(theme, options = {}) {
  const { viewportWidth = 375, viewportUnit = "vmin", unitPrecision = 6 } = options;
  return Object.entries(theme).reduce((target, [key3, value]) => {
    target[key3] = value.includes("px") ? value.replace(
      /(\d+(\.\d+)?)px/g,
      (_, p1) => `${Number((p1 / viewportWidth * 100).toFixed(unitPrecision))}${viewportUnit}`
    ) : value;
    return target;
  }, {});
}
const Themes = { dark: stdin_default$2c, md3Light: stdin_default$8, md3Dark: stdin_default$1a, toViewport };
const _ThemesComponent = null;
var stdin_default$7 = Themes;
const hoursAmpm = ["12", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11"];
const hours24 = ["00", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"];
const minSec = ["00", "05", "10", "15", "20", "25", "30", "35", "40", "45", "50", "55"];
const props$2 = {
  modelValue: String,
  elevation: {
    type: [Boolean, Number, String],
    default: false
  },
  hint: String,
  color: String,
  titleColor: String,
  format: {
    type: String,
    default: "ampm"
  },
  allowedTime: Object,
  min: String,
  max: String,
  useSeconds: Boolean,
  readonly: Boolean,
  "onUpdate:modelValue": defineListenerProp(),
  onChange: defineListenerProp()
};
const notConvert = (format2, ampm) => format2 === "24hr" || ampm === "am";
const convertHour = (format2, ampm, hour) => {
  const index = hoursAmpm.findIndex((hourAmpm) => toNumber(hourAmpm) === toNumber(hour));
  const getHour = notConvert(format2, ampm) ? hour : hours24[index];
  return {
    hourStr: getHour,
    hourNum: toNumber(getHour)
  };
};
const getNumberTime = (time) => {
  const [hour, minute, second] = time.split(":");
  return {
    hour: toNumber(hour),
    minute: toNumber(minute),
    second: toNumber(second)
  };
};
const getIsDisableMinute = (values) => {
  var _a, _b;
  const { time, format: format2, ampm, hour, max: max2, min: min2, disableHour } = values;
  const { hourStr, hourNum } = convertHour(format2, ampm, hour);
  let isBetweenMinMax = false;
  let isAllow = false;
  if (disableHour.includes(hourStr)) {
    return true;
  }
  if (max2 && !min2) {
    const { hour: maxHour, minute: maxMinute } = getNumberTime(max2);
    isBetweenMinMax = maxHour === hourNum && time > maxMinute;
  }
  if (!max2 && min2) {
    const { hour: minHour, minute: minMinute } = getNumberTime(min2);
    isBetweenMinMax = minHour === hourNum && time < minMinute;
  }
  if (max2 && min2) {
    const { hour: maxHour, minute: maxMinute } = getNumberTime(max2);
    const { hour: minHour, minute: minMinute } = getNumberTime(min2);
    isBetweenMinMax = minHour === hourNum && time < minMinute || maxHour === hourNum && time > maxMinute;
  }
  if ((_a = values.allowedTime) == null ? void 0 : _a.minutes) {
    isAllow = (_b = values.allowedTime) == null ? void 0 : _b.minutes(time);
  }
  return isBetweenMinMax || isAllow;
};
const getIsDisableSecond = (values) => {
  var _a, _b;
  const { time, format: format2, ampm, hour, minute, max: max2, min: min2, disableHour } = values;
  const { hourStr, hourNum } = convertHour(format2, ampm, hour);
  let isBetweenMinMax = false;
  let isAllow = false;
  if (disableHour.includes(hourStr)) {
    return true;
  }
  if (max2 && !min2) {
    const { hour: maxHour, minute: maxMinute, second: maxSecond } = getNumberTime(max2);
    isBetweenMinMax = maxHour === hourNum && maxMinute < minute || maxMinute === minute && time > maxSecond;
  }
  if (!max2 && min2) {
    const { hour: minHour, minute: minMinute, second: minSecond } = getNumberTime(min2);
    isBetweenMinMax = minHour === hourNum && minMinute > minute || minMinute === minute && time > minSecond;
  }
  if (max2 && min2) {
    const { hour: maxHour, minute: maxMinute, second: maxSecond } = getNumberTime(max2);
    const { hour: minHour, minute: minMinute, second: minSecond } = getNumberTime(min2);
    isBetweenMinMax = maxHour === hourNum && maxMinute < minute || minHour === hourNum && minMinute > minute || maxHour === hourNum && maxMinute === minute && time > maxSecond || minHour === hourNum && minMinute === minute && time < minSecond;
  }
  if ((_a = values.allowedTime) == null ? void 0 : _a.seconds) {
    isAllow = (_b = values.allowedTime) == null ? void 0 : _b.seconds(time);
  }
  return isBetweenMinMax || isAllow;
};
const { n: n$3, classes: classes$3 } = createNamespace("time-picker");
function __render__$3(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.n("clock"))
    },
    [
      vue.createElementVNode(
        "div",
        {
          class: vue.normalizeClass(_ctx.n("clock-hand")),
          style: vue.normalizeStyle(_ctx.handStyle)
        },
        null,
        6
        /* CLASS, STYLE */
      ),
      (vue.openBlock(true), vue.createElementBlock(
        vue.Fragment,
        null,
        vue.renderList(_ctx.timeScales, (timeScale, index) => {
          return vue.openBlock(), vue.createElementBlock(
            "div",
            {
              key: timeScale,
              class: vue.normalizeClass(
                _ctx.classes(
                  _ctx.n("clock-item"),
                  [_ctx.isActive(index, false), _ctx.n("clock-item--active")],
                  [_ctx.isDisable(timeScale), _ctx.n("clock-item--disable")]
                )
              ),
              style: vue.normalizeStyle(_ctx.getStyle(index, timeScale, false))
            },
            vue.toDisplayString(timeScale),
            7
            /* TEXT, CLASS, STYLE */
          );
        }),
        128
        /* KEYED_FRAGMENT */
      )),
      _ctx.format === "24hr" && _ctx.type === "hour" ? (vue.openBlock(), vue.createElementBlock(
        "div",
        {
          key: 0,
          ref: "inner",
          class: vue.normalizeClass(_ctx.n("clock-inner"))
        },
        [
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList(_ctx.hours24, (hour, index) => {
              return vue.openBlock(), vue.createElementBlock(
                "div",
                {
                  key: hour,
                  class: vue.normalizeClass(
                    _ctx.classes(
                      _ctx.n("clock-item"),
                      [_ctx.isActive(index, true), _ctx.n("clock-item--active")],
                      [_ctx.isDisable(hour), _ctx.n("clock-item--disable")]
                    )
                  ),
                  style: vue.normalizeStyle(_ctx.getStyle(index, hour, true))
                },
                vue.toDisplayString(hour),
                7
                /* TEXT, CLASS, STYLE */
              );
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ],
        2
        /* CLASS */
      )) : vue.createCommentVNode("v-if", true)
    ],
    2
    /* CLASS */
  );
}
const __sfc__$3 = vue.defineComponent({
  name: "Clock",
  props: {
    isInner: {
      type: Boolean,
      required: true
    },
    rad: {
      type: Number
    },
    format: {
      type: String,
      default: "ampm"
    },
    allowedTime: {
      type: Object
    },
    time: {
      type: Object,
      required: true
    },
    useSeconds: {
      type: Boolean
    },
    preventNextUpdate: {
      type: Boolean
    },
    type: {
      type: String,
      default: "hour"
    },
    ampm: {
      type: String,
      default: "am"
    },
    color: {
      type: String
    },
    min: {
      type: String
    },
    max: {
      type: String
    }
  },
  emits: ["update", "change-prevent-update"],
  setup(props2, { emit }) {
    const inner = vue.ref(null);
    const disableHour = vue.ref([]);
    const disable24HourIndex = vue.ref([]);
    const handStyle = vue.computed(() => ({
      transform: `rotate(${toNumber(props2.rad)}deg)`,
      height: props2.isInner && props2.type === "hour" ? "calc(50% - 40px)" : "calc(50% - 4px)",
      backgroundColor: getHandleColor(),
      borderColor: getHandleColor()
    }));
    const activeItemIndex = vue.computed(() => {
      if (props2.rad === void 0) {
        return;
      }
      const value = props2.rad / 30;
      return value >= 0 ? value : value + 12;
    });
    const timeScales = vue.computed(() => {
      if (props2.type === "hour") {
        return hoursAmpm;
      }
      return minSec;
    });
    const isDisableMinSec = (time, isDisable2) => {
      time = time != null ? time : props2.type === "minute" ? props2.time.minute : props2.time.second;
      const disableMethod = props2.type === "minute" ? getIsDisableMinute : getIsDisableSecond;
      const values = {
        time: toNumber(time),
        format: props2.format,
        ampm: props2.ampm,
        hour: props2.time.hour,
        minute: toNumber(props2.time.minute),
        max: props2.max,
        min: props2.min,
        allowedTime: props2.allowedTime,
        disableHour: disableHour.value
      };
      if (isDisable2 && props2.type === "minute") {
        Reflect.deleteProperty(values, "minute");
      }
      return disableMethod(values);
    };
    const getHandleColor = () => {
      if (activeItemIndex.value === void 0) {
        return props2.color;
      }
      const hour = props2.isInner ? hours24[activeItemIndex.value] : timeScales.value[activeItemIndex.value];
      if (timeScales.value === minSec) {
        return isDisableMinSec() ? "var(--time-picker-clock-item-disable-background)" : props2.color;
      }
      return isDisable(hour) ? "var(--time-picker-clock-item-disable-background)" : props2.color;
    };
    const isActive = (index, inner2) => {
      if (inner2) {
        return activeItemIndex.value === index && props2.isInner;
      }
      return activeItemIndex.value === index && (!props2.isInner || props2.type !== "hour");
    };
    const isDisable = (time) => {
      if (props2.type === "hour") {
        if (notConvert(props2.format, props2.ampm)) {
          return disableHour.value.includes(time);
        }
        const timeIndex = hoursAmpm.findIndex((hour) => hour === time);
        return disable24HourIndex.value.includes(timeIndex);
      }
      return isDisableMinSec(time, true);
    };
    const getStyle2 = (index, hour, inner2) => {
      const rad = 2 * Math.PI / 12 * index - Math.PI / 2;
      const left2 = 50 * (1 + Math.cos(rad));
      const top2 = 50 * (1 + Math.sin(rad));
      const computedColor = () => {
        if (!isActive(index, inner2)) {
          return {
            backgroundColor: void 0,
            color: void 0
          };
        }
        if (isDisable(hour)) {
          return {
            backgroundColor: "var(--time-picker-clock-item-disable-background)",
            color: "var(--time-picker-clock-item-disable-color)"
          };
        }
        return {
          backgroundColor: props2.color,
          color: void 0
        };
      };
      const { backgroundColor, color } = computedColor();
      return {
        left: `${left2}%`,
        top: `${top2}%`,
        backgroundColor,
        color
      };
    };
    const getSize2 = () => {
      const { width, height } = getRect(inner.value);
      return {
        width,
        height
      };
    };
    const getHour = () => {
      if (activeItemIndex.value === void 0) {
        return void 0;
      }
      const hours = props2.ampm === "am" ? hoursAmpm : hours24;
      return padStart$1(hours[activeItemIndex.value], 2, "0");
    };
    vue.watch([activeItemIndex, () => props2.isInner], ([index, inner2], [oldIndex, oldInner]) => {
      const isSame = index === oldIndex && inner2 === oldInner;
      if (isSame || props2.type !== "hour" || activeItemIndex.value === void 0) {
        return;
      }
      const newHour = inner2 ? hours24[activeItemIndex.value] : getHour();
      const second = props2.useSeconds ? `:${props2.time.second}` : "";
      const newTime = `${newHour}:${props2.time.minute}${second}`;
      if (!props2.preventNextUpdate) {
        emit("update", newTime);
      }
      emit("change-prevent-update");
    });
    vue.watch(
      () => props2.rad,
      (rad, oldRad) => {
        if (props2.type === "hour" || rad === void 0 || oldRad === void 0) {
          return;
        }
        const radToMinSec = rad / 6 >= 0 ? rad / 6 : rad / 6 + 60;
        const oldRadToMinSec = oldRad / 6 >= 0 ? oldRad / 6 : oldRad / 6 + 60;
        if (radToMinSec === oldRadToMinSec) {
          return;
        }
        let newTime;
        const { hourStr } = convertHour(props2.format, props2.ampm, props2.time.hour);
        if (props2.type === "minute") {
          const newMinute = dayjs().minute(radToMinSec).format("mm");
          const second = props2.useSeconds ? `:${props2.time.second}` : "";
          newTime = `${hourStr}:${newMinute}${second}`;
        }
        if (props2.type === "second") {
          const newSecond = dayjs().second(radToMinSec).format("ss");
          const second = props2.useSeconds ? `:${newSecond}` : "";
          newTime = `${hourStr}:${props2.time.minute}${second}`;
        }
        emit("update", newTime);
      }
    );
    vue.watch(
      [() => props2.max, () => props2.min, () => props2.allowedTime],
      ([max2, min2, allowedTime]) => {
        disableHour.value = [];
        if (max2 && !min2) {
          const { hour: maxHour } = getNumberTime(max2);
          const disableAmpmHours = hoursAmpm.filter((hour) => toNumber(hour) > maxHour);
          const disable24Hours = hours24.filter((hour) => toNumber(hour) > maxHour);
          disableHour.value = [...disableAmpmHours, ...disable24Hours];
        }
        if (!max2 && min2) {
          const { hour: minHour } = getNumberTime(min2);
          const disableAmpmHours = hoursAmpm.filter((hour) => toNumber(hour) < minHour);
          const disable24Hours = hours24.filter((hour) => toNumber(hour) < minHour);
          disableHour.value = [...disableAmpmHours, ...disable24Hours];
        }
        if (max2 && min2) {
          const { hour: maxHour } = getNumberTime(max2);
          const { hour: minHour } = getNumberTime(min2);
          const disableAmpmHours = hoursAmpm.filter((hour) => toNumber(hour) < minHour || toNumber(hour) > maxHour);
          const disable24Hours = hours24.filter((hour) => toNumber(hour) < minHour || toNumber(hour) > maxHour);
          disableHour.value = [...disableAmpmHours, ...disable24Hours];
        }
        if (allowedTime == null ? void 0 : allowedTime.hours) {
          const { hours } = allowedTime;
          const disableAmpmHours = hoursAmpm.filter((hour) => !hours(toNumber(hour)));
          const disable24Hours = hours24.filter((hour) => !hours(toNumber(hour)));
          disableHour.value = [.../* @__PURE__ */ new Set([...disableHour.value, ...disableAmpmHours, ...disable24Hours])];
        }
        disable24HourIndex.value = disableHour.value.map((hour) => hours24.findIndex((hour24) => hour === hour24)).filter((hour) => hour >= 0);
      },
      { immediate: true, deep: true }
    );
    return {
      n: n$3,
      classes: classes$3,
      hours24,
      timeScales,
      inner,
      handStyle,
      disableHour,
      isActive,
      isDisable,
      getSize: getSize2,
      getStyle: getStyle2,
      activeItemIndex
    };
  }
});
__sfc__$3.render = __render__$3;
var stdin_default$6 = __sfc__$3;
const { name: name$2, n: n$2, classes: classes$2 } = createNamespace("time-picker");
function __render__$2(_ctx, _cache) {
  var _a;
  const _component_clock = vue.resolveComponent("clock");
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      ref: "picker",
      class: vue.normalizeClass(_ctx.classes(_ctx.n(), _ctx.formatElevation(_ctx.elevation, 2)))
    },
    [
      vue.createElementVNode(
        "div",
        {
          class: vue.normalizeClass(_ctx.n("title")),
          style: vue.normalizeStyle({ background: _ctx.titleColor || _ctx.color })
        },
        [
          vue.createElementVNode(
            "div",
            {
              class: vue.normalizeClass(_ctx.n("title-hint"))
            },
            vue.toDisplayString((_a = _ctx.hint) != null ? _a : (_ctx.pt ? _ctx.pt : _ctx.t)("timePickerHint")),
            3
            /* TEXT, CLASS */
          ),
          vue.createElementVNode(
            "div",
            {
              class: vue.normalizeClass(_ctx.n("title-time-container"))
            },
            [
              vue.createElementVNode(
                "div",
                {
                  class: vue.normalizeClass(_ctx.n("title-time"))
                },
                [
                  vue.createElementVNode(
                    "div",
                    {
                      class: vue.normalizeClass(_ctx.classes(_ctx.n("title-btn"), [_ctx.type === "hour", _ctx.n("title-btn--active")])),
                      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.checkPanel("hour"))
                    },
                    vue.toDisplayString(_ctx.time.hour),
                    3
                    /* TEXT, CLASS */
                  ),
                  vue.createElementVNode(
                    "span",
                    {
                      class: vue.normalizeClass(_ctx.n("title-splitter"))
                    },
                    ":",
                    2
                    /* CLASS */
                  ),
                  vue.createElementVNode(
                    "div",
                    {
                      class: vue.normalizeClass(_ctx.classes(_ctx.n("title-btn"), [_ctx.type === "minute", _ctx.n("title-btn--active")])),
                      onClick: _cache[1] || (_cache[1] = ($event) => _ctx.checkPanel("minute"))
                    },
                    vue.toDisplayString(_ctx.time.minute),
                    3
                    /* TEXT, CLASS */
                  ),
                  _ctx.useSeconds ? (vue.openBlock(), vue.createElementBlock(
                    "span",
                    {
                      key: 0,
                      class: vue.normalizeClass(_ctx.n("title-splitter"))
                    },
                    ":",
                    2
                    /* CLASS */
                  )) : vue.createCommentVNode("v-if", true),
                  _ctx.useSeconds ? (vue.openBlock(), vue.createElementBlock(
                    "div",
                    {
                      key: 1,
                      class: vue.normalizeClass(_ctx.classes(_ctx.n("title-btn"), [_ctx.type === "second", _ctx.n("title-btn--active")])),
                      onClick: _cache[2] || (_cache[2] = ($event) => _ctx.checkPanel("second"))
                    },
                    vue.toDisplayString(_ctx.time.second),
                    3
                    /* TEXT, CLASS */
                  )) : vue.createCommentVNode("v-if", true)
                ],
                2
                /* CLASS */
              ),
              _ctx.format === "ampm" ? (vue.openBlock(), vue.createElementBlock(
                "div",
                {
                  key: 0,
                  class: vue.normalizeClass(_ctx.n("title-ampm"))
                },
                [
                  vue.createElementVNode(
                    "div",
                    {
                      class: vue.normalizeClass(_ctx.classes(_ctx.n("title-btn"), [_ctx.ampm === "am", _ctx.n("title-btn--active")])),
                      onClick: _cache[3] || (_cache[3] = ($event) => _ctx.checkAmpm("am"))
                    },
                    " AM ",
                    2
                    /* CLASS */
                  ),
                  vue.createElementVNode(
                    "div",
                    {
                      class: vue.normalizeClass(_ctx.classes(_ctx.n("title-btn"), [_ctx.ampm === "pm", _ctx.n("title-btn--active")])),
                      onClick: _cache[4] || (_cache[4] = ($event) => _ctx.checkAmpm("pm"))
                    },
                    " PM ",
                    2
                    /* CLASS */
                  )
                ],
                2
                /* CLASS */
              )) : vue.createCommentVNode("v-if", true)
            ],
            2
            /* CLASS */
          )
        ],
        6
        /* CLASS, STYLE */
      ),
      vue.createElementVNode(
        "div",
        {
          class: vue.normalizeClass(_ctx.n("body"))
        },
        [
          vue.createElementVNode(
            "div",
            {
              ref: "container",
              class: vue.normalizeClass(_ctx.n("clock-container")),
              onTouchstart: _cache[5] || (_cache[5] = (...args) => _ctx.moveHand && _ctx.moveHand(...args)),
              onTouchmove: _cache[6] || (_cache[6] = (...args) => _ctx.moveHand && _ctx.moveHand(...args)),
              onTouchend: _cache[7] || (_cache[7] = (...args) => _ctx.end && _ctx.end(...args))
            },
            [
              vue.createVNode(vue.Transition, {
                name: `${_ctx.n()}-panel-fade`
              }, {
                default: vue.withCtx(() => [
                  (vue.openBlock(), vue.createBlock(_component_clock, {
                    key: _ctx.type,
                    ref: "inner",
                    type: _ctx.type,
                    ampm: _ctx.ampm,
                    color: _ctx.color,
                    "is-inner": _ctx.isInner,
                    format: _ctx.format,
                    "allowed-time": _ctx.allowedTime,
                    rad: _ctx.getRad,
                    time: _ctx.time,
                    "prevent-next-update": _ctx.isPreventNextUpdate,
                    "use-seconds": _ctx.useSeconds,
                    max: _ctx.max,
                    min: _ctx.min,
                    onUpdate: _ctx.update,
                    onChangePreventUpdate: _ctx.changePreventUpdate
                  }, null, 8, ["type", "ampm", "color", "is-inner", "format", "allowed-time", "rad", "time", "prevent-next-update", "use-seconds", "max", "min", "onUpdate", "onChangePreventUpdate"]))
                ]),
                _: 1
                /* STABLE */
              }, 8, ["name"])
            ],
            34
            /* CLASS, NEED_HYDRATION */
          )
        ],
        2
        /* CLASS */
      ),
      _ctx.$slots.actions ? (vue.openBlock(), vue.createElementBlock(
        "div",
        {
          key: 0,
          class: vue.normalizeClass(_ctx.n("actions"))
        },
        [
          vue.renderSlot(_ctx.$slots, "actions")
        ],
        2
        /* CLASS */
      )) : vue.createCommentVNode("v-if", true)
    ],
    2
    /* CLASS */
  );
}
const __sfc__$2 = vue.defineComponent({
  name: name$2,
  components: { Clock: stdin_default$6 },
  props: props$2,
  setup(props2) {
    const container = vue.ref(null);
    const picker = vue.ref(null);
    const inner = vue.ref(null);
    const isInner = vue.ref(false);
    const isPreventNextUpdate = vue.ref(false);
    const isActualInner = vue.ref(false);
    const isChosenUsableHour = vue.ref(false);
    const isChosenUsableMinute = vue.ref(false);
    const isDisableHour = vue.ref(false);
    const isDisableMinute = vue.ref(false);
    const minuteRad = vue.ref(0);
    const secondRad = vue.ref(0);
    const hourRad = vue.ref();
    const type = vue.ref("hour");
    const ampm = vue.ref("am");
    const time = vue.ref({
      hour: "00",
      minute: "00",
      second: "00"
    });
    const center = vue.reactive({
      x: 0,
      y: 0
    });
    const innerRange = vue.reactive({
      x: [],
      y: []
    });
    const getRad = vue.computed(() => {
      if (type.value === "hour") {
        return hourRad.value;
      }
      if (type.value === "minute") {
        return minuteRad.value;
      }
      return secondRad.value;
    });
    const { t: pt } = injectLocaleProvider();
    vue.watch(
      () => props2.modelValue,
      (value) => {
        if (value === void 0 || value === "") {
          resetTime();
          return;
        }
        const { hour, minute, second } = getNumberTime(value);
        const formatHour12 = dayjs().hour(hour).format("hh");
        const formatHour24 = dayjs().hour(hour).format("HH");
        const formatMinute = dayjs().minute(minute).format("mm");
        const formatSecond = dayjs().second(second).format("ss");
        hourRad.value = (formatHour12 === "12" ? 0 : toNumber(formatHour12)) * 30;
        minuteRad.value = toNumber(formatMinute) * 6;
        secondRad.value = toNumber(formatSecond) * 6;
        time.value = getTime(value);
        if (props2.format !== "24hr") {
          ampm.value = padStart$1(`${hour}`, 2, "0") === formatHour24 && hours24.includes(formatHour24) ? "pm" : "am";
        }
        isInner.value = props2.format === "24hr" && hours24.includes(formatHour24);
      },
      { immediate: true }
    );
    function resetTime() {
      hourRad.value = void 0;
      minuteRad.value = 0;
      secondRad.value = 0;
      time.value = {
        hour: "00",
        minute: "00",
        second: "00"
      };
      ampm.value = "am";
    }
    function update(newTime) {
      call(props2["onUpdate:modelValue"], newTime);
      call(props2.onChange, newTime);
    }
    function rad2deg(rad) {
      return rad * 57.29577951308232;
    }
    function checkPanel(panelType) {
      isChosenUsableHour.value = false;
      isDisableMinute.value = false;
      type.value = panelType;
    }
    function findAvailableHour(ampm2) {
      const { disableHour } = inner.value;
      const index = hoursAmpm.findIndex((hour) => toNumber(hour) === toNumber(time.value.hour));
      const hours = ampm2 === "am" ? hoursAmpm : hours24;
      const realignmentHours = [...hours.slice(index), ...hours.slice(0, index)];
      return realignmentHours.find((hour, index2) => {
        isPreventNextUpdate.value = index2 !== 0;
        return !disableHour.includes(hour);
      });
    }
    function checkAmpm(ampmType) {
      if (props2.readonly) {
        return;
      }
      ampm.value = ampmType;
      const newHour = findAvailableHour(ampmType);
      if (!newHour) {
        return;
      }
      const second = props2.useSeconds ? `:${time.value.second}` : "";
      const newTime = `${padStart$1(newHour, 2, "0")}:${time.value.minute}${second}`;
      update(newTime);
    }
    function getInner(clientX, clientY) {
      const xIsInRange = clientX >= innerRange.x[0] && clientX <= innerRange.x[1];
      const yIsInRange = clientY >= innerRange.y[0] && clientY <= innerRange.y[1];
      return xIsInRange && yIsInRange;
    }
    function getTime(value) {
      const hourFormat = props2.format === "24hr" ? "HH" : "hh";
      const { hour, minute, second } = getNumberTime(value);
      return {
        hour: dayjs().hour(hour).format(hourFormat),
        minute: dayjs().minute(minute).format("mm"),
        second: dayjs().second(second).format("ss")
      };
    }
    function getHourIndex(rad) {
      const value = rad / 30;
      return value >= 0 ? value : value + 12;
    }
    function getRangeSize() {
      const { width: innerWidth, height: innerHeight } = inner.value.getSize();
      const rangeXMin = center.x - innerWidth / 2 - 8;
      const rangeXMax = center.x + innerWidth / 2 + 8;
      const rangeYMin = center.y - innerHeight / 2 - 8;
      const rangeYMax = center.y + innerHeight / 2 + 8;
      return {
        rangeXMin,
        rangeXMax,
        rangeYMin,
        rangeYMax
      };
    }
    function setHourRad(clientX, clientY, roundDeg) {
      const { disableHour } = inner.value;
      isActualInner.value = getInner(clientX, clientY);
      const rad = Math.round(roundDeg / 30) * 30 + 90;
      const index = getHourIndex(rad);
      const anotherHour = isInner.value ? hoursAmpm[index] : hours24[index];
      if (!disableHour.includes(anotherHour)) {
        isInner.value = props2.format === "24hr" ? getInner(clientX, clientY) : false;
      }
      if (isInner.value !== isActualInner.value) {
        return;
      }
      const newHour = isInner.value || ampm.value === "pm" ? hours24[index] : hoursAmpm[index];
      isDisableHour.value = disableHour.includes(newHour);
      if (isDisableHour.value) {
        return;
      }
      hourRad.value = rad;
      isChosenUsableHour.value = true;
    }
    function setMinuteRad(roundDeg) {
      const { disableHour } = inner.value;
      const rad = Math.round(roundDeg / 6) * 6 + 90;
      const radToMin = rad / 6 >= 0 ? rad / 6 : rad / 6 + 60;
      const values = {
        time: radToMin,
        format: props2.format,
        ampm: ampm.value,
        hour: time.value.hour,
        max: props2.max,
        min: props2.min,
        disableHour,
        allowedTime: props2.allowedTime
      };
      isDisableMinute.value = getIsDisableMinute(values);
      if (isDisableMinute.value) {
        return;
      }
      minuteRad.value = rad;
      isChosenUsableMinute.value = true;
    }
    function setSecondRad(roundDeg) {
      const { disableHour } = inner.value;
      const rad = Math.round(roundDeg / 6) * 6 + 90;
      const radToSec = rad / 6 >= 0 ? rad / 6 : rad / 6 + 60;
      const values = {
        time: radToSec,
        format: props2.format,
        ampm: ampm.value,
        hour: time.value.hour,
        minute: toNumber(time.value.minute),
        max: props2.max,
        min: props2.min,
        disableHour,
        allowedTime: props2.allowedTime
      };
      if (!getIsDisableSecond(values)) {
        secondRad.value = rad;
      }
    }
    function setCenterAndRange() {
      const { left: left2, top: top2, width, height } = getRect(container.value);
      center.x = left2 + width / 2;
      center.y = top2 + height / 2;
      if (type.value === "hour" && props2.format === "24hr") {
        const { rangeXMin, rangeXMax, rangeYMin, rangeYMax } = getRangeSize();
        innerRange.x = [rangeXMin, rangeXMax];
        innerRange.y = [rangeYMin, rangeYMax];
      }
    }
    function moveHand(event) {
      preventDefault(event);
      if (props2.readonly) {
        return;
      }
      setCenterAndRange();
      const { clientX, clientY } = event.touches[0];
      const x = clientX - center.x;
      const y = clientY - center.y;
      const roundDeg = Math.round(rad2deg(Math.atan2(y, x)));
      if (type.value === "hour") {
        setHourRad(clientX, clientY, roundDeg);
      } else if (type.value === "minute") {
        setMinuteRad(roundDeg);
      } else {
        setSecondRad(roundDeg);
      }
    }
    function end2() {
      if (props2.readonly) {
        return;
      }
      if (type.value === "hour" && isChosenUsableHour.value) {
        type.value = "minute";
        return;
      }
      if (type.value === "minute" && props2.useSeconds && isChosenUsableMinute.value) {
        type.value = "second";
      }
    }
    function changePreventUpdate() {
      isPreventNextUpdate.value = false;
    }
    return {
      getRad,
      time,
      container,
      inner,
      picker,
      isInner,
      type,
      ampm,
      isPreventNextUpdate,
      n: n$2,
      classes: classes$2,
      t,
      pt,
      moveHand,
      checkPanel,
      checkAmpm,
      end: end2,
      update,
      changePreventUpdate,
      formatElevation
    };
  }
});
__sfc__$2.render = __render__$2;
var stdin_default$5 = __sfc__$2;
withInstall(stdin_default$5);
withPropsDefaultsSetter(stdin_default$5, props$2);
const _TimePickerComponent = stdin_default$5;
var stdin_default$4 = stdin_default$5;
const props$1 = {
  modelValue: {
    type: Array,
    default: () => []
  },
  accept: {
    type: String,
    default: "image/*"
  },
  capture: {
    type: [String, Boolean],
    default: void 0
  },
  multiple: Boolean,
  readonly: Boolean,
  disabled: Boolean,
  elevation: {
    type: [Boolean, Number, String],
    default: true
  },
  resolveType: {
    type: String,
    default: "default"
  },
  removable: {
    type: Boolean,
    default: true
  },
  maxlength: [Number, String],
  maxsize: [Number, String],
  previewed: {
    type: Boolean,
    default: true
  },
  ripple: {
    type: Boolean,
    default: true
  },
  validateTrigger: {
    type: Array,
    default: () => ["onChange", "onRemove"]
  },
  rules: [Array, Function, Object],
  hideList: Boolean,
  preventDefaultPreview: Boolean,
  onClickAction: defineListenerProp(),
  onBeforeFilter: defineListenerProp(),
  onBeforeRead: defineListenerProp(),
  onAfterRead: defineListenerProp(),
  onBeforeRemove: defineListenerProp(),
  onRemove: defineListenerProp(),
  onOversize: defineListenerProp(),
  onPreview: defineListenerProp(),
  "onUpdate:modelValue": defineListenerProp()
};
var __async$1 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const { name: name$1, n: n$1, classes: classes$1 } = createNamespace("uploader");
let fid = 0;
const _hoisted_1$1 = ["onClick"];
const _hoisted_2$1 = ["onClick"];
const _hoisted_3$1 = ["src", "alt"];
const _hoisted_4$1 = ["tabindex"];
const _hoisted_5 = ["multiple", "accept", "capture", "disabled"];
const _hoisted_6 = ["src"];
function __render__$1(_ctx, _cache) {
  const _component_var_icon = vue.resolveComponent("var-icon");
  const _component_var_hover_overlay = vue.resolveComponent("var-hover-overlay");
  const _component_var_form_details = vue.resolveComponent("var-form-details");
  const _component_var_popup = vue.resolveComponent("var-popup");
  const _directive_ripple = vue.resolveDirective("ripple");
  const _directive_hover = vue.resolveDirective("hover");
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.classes(_ctx.n(), _ctx.n("$--box")))
    },
    [
      vue.createElementVNode(
        "div",
        {
          class: vue.normalizeClass(_ctx.n("file-list"))
        },
        [
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList(_ctx.files, (f) => {
              return vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", {
                key: f.id,
                class: vue.normalizeClass(_ctx.classes(_ctx.n("file"), _ctx.formatElevation(_ctx.elevation, 2), [f.state === "loading", _ctx.n("--loading")])),
                onClick: ($event) => _ctx.preview(f)
              }, [
                vue.createElementVNode(
                  "div",
                  {
                    class: vue.normalizeClass(_ctx.n("file-name"))
                  },
                  vue.toDisplayString(f.name || f.url),
                  3
                  /* TEXT, CLASS */
                ),
                _ctx.removable ? vue.renderSlot(_ctx.$slots, "remove-button", {
                  key: 0,
                  remove: () => {
                    _ctx.handleRemove(f);
                  }
                }, () => [
                  vue.createElementVNode("div", {
                    class: vue.normalizeClass(_ctx.n("file-close")),
                    onClick: vue.withModifiers(($event) => _ctx.handleRemove(f), ["stop"])
                  }, [
                    vue.createVNode(_component_var_icon, {
                      class: vue.normalizeClass(_ctx.n("file-close-icon")),
                      "var-uploader-cover": "",
                      name: "delete"
                    }, null, 8, ["class"])
                  ], 10, _hoisted_2$1)
                ]) : vue.createCommentVNode("v-if", true),
                f.cover ? (vue.openBlock(), vue.createElementBlock("img", {
                  key: 1,
                  role: "img",
                  class: vue.normalizeClass(_ctx.n("file-cover")),
                  style: vue.normalizeStyle({ objectFit: f.fit }),
                  src: f.cover,
                  alt: f.name
                }, null, 14, _hoisted_3$1)) : vue.createCommentVNode("v-if", true),
                vue.createElementVNode(
                  "div",
                  {
                    class: vue.normalizeClass(_ctx.n("file-indicator"))
                  },
                  [
                    vue.createElementVNode(
                      "div",
                      {
                        class: vue.normalizeClass(
                          _ctx.classes(_ctx.n("progress"), [f.state === "success", _ctx.n("--success")], [f.state === "error", _ctx.n("--error")])
                        ),
                        style: vue.normalizeStyle({ width: f.state === "success" || f.state === "error" ? "100%" : `${f.progress}%` })
                      },
                      null,
                      6
                      /* CLASS, STYLE */
                    )
                  ],
                  2
                  /* CLASS */
                )
              ], 10, _hoisted_1$1)), [
                [_directive_ripple, { disabled: _ctx.disabled || _ctx.formDisabled || _ctx.readonly || _ctx.formReadonly || !_ctx.ripple }]
              ]);
            }),
            128
            /* KEYED_FRAGMENT */
          )),
          !_ctx.maxlength || _ctx.modelValue.length < _ctx.toNumber(_ctx.maxlength) ? vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", {
            key: 0,
            ref: "actionRef",
            class: vue.normalizeClass(
              _ctx.classes(
                _ctx.n("--outline-none"),
                [!_ctx.$slots.default, `${_ctx.n("action")} ${_ctx.formatElevation(_ctx.elevation, 2)}`],
                [_ctx.disabled || _ctx.formDisabled, _ctx.n("--disabled")]
              )
            ),
            tabindex: _ctx.disabled || _ctx.formDisabled ? void 0 : "0",
            onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleActionClick && _ctx.handleActionClick(...args)),
            onFocus: _cache[3] || (_cache[3] = ($event) => _ctx.isFocusing = true),
            onBlur: _cache[4] || (_cache[4] = ($event) => _ctx.isFocusing = false)
          }, [
            vue.createElementVNode("input", {
              ref: "input",
              type: "file",
              class: vue.normalizeClass(_ctx.n("action-input")),
              multiple: _ctx.multiple,
              accept: _ctx.accept,
              capture: _ctx.capture,
              disabled: _ctx.disabled || _ctx.formDisabled || _ctx.readonly || _ctx.formReadonly,
              onChange: _cache[0] || (_cache[0] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
              onClick: _cache[1] || (_cache[1] = vue.withModifiers(() => {
              }, ["stop"]))
            }, null, 42, _hoisted_5),
            vue.renderSlot(_ctx.$slots, "default", {}, () => [
              vue.createVNode(_component_var_icon, {
                class: vue.normalizeClass(_ctx.n("action-icon")),
                "var-uploader-cover": "",
                name: "plus"
              }, null, 8, ["class"]),
              vue.createVNode(_component_var_hover_overlay, {
                hovering: _ctx.hovering && !_ctx.disabled && !_ctx.formDisabled && !_ctx.readonly && !_ctx.formReadonly,
                focusing: _ctx.isFocusing && !_ctx.disabled && !_ctx.formDisabled && !_ctx.readonly && !_ctx.formReadonly
              }, null, 8, ["hovering", "focusing"])
            ])
          ], 42, _hoisted_4$1)), [
            [_directive_ripple, {
              disabled: _ctx.disabled || _ctx.formDisabled || _ctx.readonly || _ctx.formReadonly || !_ctx.ripple || Boolean(_ctx.$slots.default)
            }],
            [_directive_hover, _ctx.handleHovering, "desktop"]
          ]) : vue.createCommentVNode("v-if", true)
        ],
        2
        /* CLASS */
      ),
      vue.createVNode(_component_var_form_details, {
        "error-message": _ctx.errorMessage,
        "extra-message": _ctx.maxlengthText
      }, vue.createSlots({
        _: 2
        /* DYNAMIC */
      }, [
        _ctx.$slots["extra-message"] ? {
          name: "extra-message",
          fn: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "extra-message")
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["error-message", "extra-message"]),
      vue.createVNode(_component_var_popup, {
        show: _ctx.showPreview,
        "onUpdate:show": _cache[5] || (_cache[5] = ($event) => _ctx.showPreview = $event),
        class: vue.normalizeClass(_ctx.n("preview")),
        "var-uploader-cover": "",
        position: "center",
        onClosed: _cache[6] || (_cache[6] = ($event) => _ctx.currentPreview = null)
      }, {
        default: vue.withCtx(() => {
          var _a, _b;
          return [
            _ctx.currentPreview && _ctx.isHTMLSupportVideo((_a = _ctx.currentPreview) == null ? void 0 : _a.url) ? (vue.openBlock(), vue.createElementBlock("video", {
              key: 0,
              class: vue.normalizeClass(_ctx.n("preview-video")),
              playsinline: "true",
              "webkit-playsinline": "true",
              "x5-playsinline": "true",
              "x5-video-player-type": "h5",
              "x5-video-player-fullscreen": "false",
              controls: "",
              src: (_b = _ctx.currentPreview) == null ? void 0 : _b.url
            }, null, 10, _hoisted_6)) : vue.createCommentVNode("v-if", true)
          ];
        }),
        _: 1
        /* STABLE */
      }, 8, ["show", "class"])
    ],
    2
    /* CLASS */
  );
}
const __sfc__$1 = vue.defineComponent({
  name: name$1,
  directives: { Ripple: stdin_default$63, Hover: stdin_default$62 },
  components: {
    VarIcon: stdin_default$5_,
    VarPopup: stdin_default$64,
    VarFormDetails: stdin_default$5R,
    VarHoverOverlay: stdin_default$60
  },
  props: props$1,
  setup(props2) {
    const isFocusing = vue.ref(false);
    const actionRef = vue.ref(null);
    const input = vue.ref(null);
    const showPreview = vue.ref(false);
    const currentPreview = vue.ref(null);
    const maxlengthText = vue.computed(() => {
      const {
        maxlength,
        modelValue: { length }
      } = props2;
      return isNumber(maxlength) ? `${length} / ${maxlength}` : "";
    });
    const { form, bindForm } = useForm();
    const {
      errorMessage,
      validateWithTrigger: vt,
      validate: v,
      // expose
      resetValidation
    } = useValidation();
    const { hovering, handleHovering } = useHoverOverlay();
    const files = vue.computed(() => {
      const { modelValue, hideList } = props2;
      if (hideList) {
        return [];
      }
      return modelValue;
    });
    let callReset = false;
    const varFileUtils = {
      getSuccess,
      getError,
      getLoading
    };
    const uploaderProvider = {
      validate,
      resetValidation,
      reset
    };
    call(bindForm, uploaderProvider);
    useEventListener(() => window, "keydown", handleKeydown);
    useEventListener(() => window, "keyup", handleKeyup);
    vue.watch(
      () => props2.modelValue,
      () => {
        !callReset && validateWithTrigger("onChange");
        callReset = false;
      },
      { deep: true }
    );
    function handleKeydown(event) {
      if (!isFocusing.value) {
        return;
      }
      if (event.key === " " || event.key === "Enter") {
        event.preventDefault();
      }
      if (event.key === "Enter") {
        actionRef.value.click();
      }
    }
    function handleKeyup(event) {
      if (!isFocusing.value || event.key !== " ") {
        return;
      }
      event.preventDefault();
      actionRef.value.click();
    }
    function preview(varFile) {
      const { disabled, previewed, preventDefaultPreview, onPreview } = props2;
      if ((form == null ? void 0 : form.disabled.value) || disabled || !previewed) {
        return;
      }
      call(onPreview, vue.reactive(varFile));
      if (preventDefaultPreview) {
        return;
      }
      const { url } = varFile;
      if (isHTMLSupportImage(url)) {
        stdin_default$4l(url);
        return;
      }
      if (isHTMLSupportVideo(url)) {
        currentPreview.value = varFile;
        showPreview.value = true;
      }
    }
    function createVarFile(file) {
      return {
        id: fid++,
        url: "",
        cover: "",
        name: file.name,
        file,
        progress: 0
      };
    }
    function getFiles(event) {
      const el = event.target;
      const { files: fileList } = el;
      return Array.from(fileList);
    }
    function resolver(varFile) {
      return __async$1(this, null, function* () {
        const file = varFile.file;
        const shouldWithDataURL = props2.resolveType === "default" && file.type.startsWith("image") || props2.resolveType === "data-url";
        if (shouldWithDataURL) {
          const dataURL = yield toDataURL(file);
          varFile.cover = dataURL;
          varFile.url = dataURL;
        }
        return varFile;
      });
    }
    function getResolvers(varFiles) {
      return varFiles.map(resolver);
    }
    function getBeforeReaders(varFiles) {
      const { onBeforeRead } = props2;
      return varFiles.map(
        (varFile) => new Promise((resolve) => {
          if (!onBeforeRead) {
            resolve({
              valid: true,
              varFile
            });
          }
          const results = normalizeToArray(call(onBeforeRead, vue.reactive(varFile)));
          Promise.all(results).then((values) => {
            resolve({
              valid: values.every(Boolean),
              varFile
            });
          });
        })
      );
    }
    function handleChange(event) {
      return __async$1(this, null, function* () {
        const { maxsize, maxlength, modelValue, onOversize, onAfterRead, onBeforeFilter, readonly, disabled } = props2;
        if ((form == null ? void 0 : form.disabled.value) || (form == null ? void 0 : form.readonly.value) || disabled || readonly) {
          return;
        }
        const getValidSizeVarFile = (varFiles2) => varFiles2.filter((varFile) => {
          if (varFile.file.size > toNumber(maxsize)) {
            call(onOversize, vue.reactive(varFile));
            return false;
          }
          return true;
        });
        const getValidLengthVarFiles = (varFiles2) => {
          const limit = Math.min(varFiles2.length, toNumber(maxlength) - modelValue.length);
          return varFiles2.slice(0, limit);
        };
        const getFilterVarFiles = (varFiles2) => __async$1(this, null, function* () {
          if (!onBeforeFilter) {
            return varFiles2;
          }
          const events = normalizeToArray(onBeforeFilter);
          for (const event2 of events) {
            varFiles2 = yield event2(varFiles2);
          }
          return varFiles2;
        });
        const files2 = getFiles(event);
        let varFiles = files2.map(createVarFile);
        varFiles = yield getFilterVarFiles(varFiles);
        varFiles = maxsize != null ? getValidSizeVarFile(varFiles) : varFiles;
        varFiles = maxlength != null ? getValidLengthVarFiles(varFiles) : varFiles;
        const resolvedVarFiles = yield Promise.all(getResolvers(varFiles));
        const validationVarFiles = yield Promise.all(getBeforeReaders(resolvedVarFiles));
        const validVarFiles = validationVarFiles.filter(({ valid }) => valid).map(({ varFile }) => varFile);
        call(props2["onUpdate:modelValue"], [...modelValue, ...validVarFiles]);
        event.target.value = "";
        validVarFiles.forEach((varFile) => call(onAfterRead, vue.reactive(varFile)));
      });
    }
    function handleRemove(removedVarFile) {
      return __async$1(this, null, function* () {
        const { disabled, readonly, modelValue, onBeforeRemove, onRemove } = props2;
        if ((form == null ? void 0 : form.disabled.value) || (form == null ? void 0 : form.readonly.value) || disabled || readonly) {
          return;
        }
        if (onBeforeRemove) {
          const results = normalizeToArray(call(onBeforeRemove, vue.reactive(removedVarFile)));
          if ((yield Promise.all(results)).some((result) => !result)) {
            return;
          }
        }
        const expectedFiles = modelValue.filter((varFile) => varFile !== removedVarFile);
        call(onRemove, vue.reactive(removedVarFile));
        validateWithTrigger("onRemove");
        call(props2["onUpdate:modelValue"], expectedFiles);
      });
    }
    function handleActionClick(event) {
      if ((form == null ? void 0 : form.disabled.value) || props2.disabled) {
        return;
      }
      if (props2.onClickAction) {
        call(props2.onClickAction, chooseFile, event);
        return;
      }
      chooseFile();
    }
    function getSuccess() {
      return props2.modelValue.filter((varFile) => varFile.state === "success");
    }
    function getError() {
      return props2.modelValue.filter((varFile) => varFile.state === "error");
    }
    function getLoading() {
      return props2.modelValue.filter((varFile) => varFile.state === "loading");
    }
    function chooseFile() {
      input.value.click();
    }
    function closePreview() {
      currentPreview.value = null;
      showPreview.value = false;
      stdin_default$4l.close();
    }
    function validateWithTrigger(trigger) {
      vue.nextTick(() => {
        const { validateTrigger, rules, modelValue } = props2;
        vt(validateTrigger, trigger, rules, modelValue, varFileUtils);
      });
    }
    function validate() {
      return v(props2.rules, props2.modelValue, varFileUtils);
    }
    function reset() {
      callReset = true;
      call(props2["onUpdate:modelValue"], []);
      resetValidation();
    }
    return {
      input,
      actionRef,
      files,
      showPreview,
      currentPreview,
      errorMessage,
      maxlengthText,
      hovering,
      isFocusing,
      formDisabled: form == null ? void 0 : form.disabled,
      formReadonly: form == null ? void 0 : form.readonly,
      n: n$1,
      classes: classes$1,
      formatElevation,
      toNumber,
      handleHovering,
      isHTMLSupportVideo,
      isHTMLSupportImage,
      preview,
      handleChange,
      handleRemove,
      getSuccess,
      getError,
      getLoading,
      validate,
      resetValidation,
      reset,
      chooseFile,
      closePreview,
      handleActionClick,
      toSizeUnit
    };
  }
});
__sfc__$1.render = __render__$1;
var stdin_default$3 = __sfc__$1;
withInstall(stdin_default$3);
withPropsDefaultsSetter(stdin_default$3, props$1);
const _UploaderComponent = stdin_default$3;
var stdin_default$2 = stdin_default$3;
const props = {
  width: {
    type: Number,
    default: 100
  },
  height: {
    type: Number,
    default: 100
  },
  content: String,
  image: String,
  rotate: {
    type: Number,
    default: -22
  },
  offsetX: {
    type: Number,
    default: 0
  },
  offsetY: {
    type: Number,
    default: 0
  },
  gapX: {
    type: Number,
    default: 0
  },
  gapY: {
    type: Number,
    default: 0
  },
  zIndex: {
    type: [Number, String],
    default: 10
  },
  opacity: {
    type: [Number, String],
    default: 0.5
  },
  fullscreen: Boolean,
  font: {
    type: Object,
    default: () => ({
      fontStyle: "normal",
      fontVariant: "normal",
      fontWeight: "normal",
      fontSize: 14
    })
  }
};
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key3, value) => key3 in obj ? __defProp(obj, key3, { enumerable: true, configurable: true, writable: true, value }) : obj[key3] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const { name, n, classes } = createNamespace("watermark");
const _hoisted_1 = { ref: "svgRef" };
const _hoisted_2 = ["viewBox", "width", "height"];
const _hoisted_3 = ["width", "height"];
const _hoisted_4 = ["href", "xlink:href", "x", "y", "width", "height"];
function __render__(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock(
    "div",
    {
      class: vue.normalizeClass(_ctx.n())
    },
    [
      vue.renderSlot(_ctx.$slots, "default"),
      (vue.openBlock(), vue.createBlock(vue.Teleport, {
        to: "body",
        disabled: !_ctx.fullscreen
      }, [
        vue.createElementVNode(
          "div",
          {
            ref: "containerRef",
            class: vue.normalizeClass(_ctx.classes(_ctx.n("container"), [_ctx.fullscreen, _ctx.n("--fullscreen")])),
            style: vue.normalizeStyle({
              backgroundImage: `url(${_ctx.watermarkUrl})`,
              zIndex: _ctx.zIndex
            })
          },
          [
            vue.withDirectives(vue.createElementVNode(
              "div",
              _hoisted_1,
              [
                (vue.openBlock(), vue.createElementBlock("svg", {
                  xmlns: "http://www.w3.org/2000/svg",
                  "xmlns:xlink": "http://www.w3.org/1999/xlink",
                  viewBox: `0 0 ${_ctx.width + _ctx.gapX} ${_ctx.height + _ctx.gapY}`,
                  width: `${_ctx.width + _ctx.gapX}`,
                  height: `${_ctx.height + _ctx.gapY}`,
                  style: vue.normalizeStyle({
                    padding: `0 ${_ctx.gapX}px ${_ctx.gapY}px 0`,
                    opacity: _ctx.opacity
                  })
                }, [
                  _ctx.showContent() ? (vue.openBlock(), vue.createElementBlock("foreignObject", {
                    key: 0,
                    x: "0",
                    y: "0",
                    width: _ctx.width,
                    height: _ctx.height
                  }, [
                    vue.createElementVNode(
                      "div",
                      {
                        xmlns: "http://www.w3.org/1999/xhtml",
                        style: vue.normalizeStyle({
                          transform: `translate(${_ctx.offsetX}px, ${_ctx.offsetY}px) rotate(${_ctx.rotate}deg)`,
                          transformOrigin: "center"
                        })
                      },
                      [
                        vue.renderSlot(_ctx.$slots, "content", {}, () => [
                          vue.createElementVNode(
                            "span",
                            {
                              style: vue.normalizeStyle(__spreadProps(__spreadValues({}, _ctx.font), { fontSize: `${_ctx.font.fontSize}px`, color: _ctx.textColor }))
                            },
                            vue.toDisplayString(_ctx.content),
                            5
                            /* TEXT, STYLE */
                          )
                        ])
                      ],
                      4
                      /* STYLE */
                    )
                  ], 8, _hoisted_3)) : vue.createCommentVNode("v-if", true),
                  !_ctx.$slots.content && _ctx.image ? (vue.openBlock(), vue.createElementBlock("image", {
                    key: 1,
                    href: _ctx.imageUrl,
                    "xlink:href": _ctx.imageUrl,
                    x: _ctx.offsetX,
                    y: _ctx.offsetY,
                    width: _ctx.width,
                    height: _ctx.height,
                    style: vue.normalizeStyle({
                      transform: `rotate(${_ctx.rotate}deg)`,
                      transformOrigin: "center"
                    })
                  }, null, 12, _hoisted_4)) : vue.createCommentVNode("v-if", true)
                ], 12, _hoisted_2))
              ],
              512
              /* NEED_PATCH */
            ), [
              [vue.vShow, false]
            ])
          ],
          6
          /* CLASS, STYLE */
        )
      ], 8, ["disabled"]))
    ],
    2
    /* CLASS */
  );
}
const __sfc__ = vue.defineComponent({
  name,
  props,
  setup(props2, { slots }) {
    const watermarkUrl = vue.ref("");
    const imageUrl = vue.ref("");
    const textColor = vue.ref("");
    const svgRef = vue.ref(null);
    const containerRef = vue.ref(null);
    vue.watch(
      () => [
        props2.image,
        props2.font,
        props2.content,
        props2.height,
        props2.width,
        props2.rotate,
        props2.gapX,
        props2.gapY,
        props2.offsetX,
        props2.offsetY,
        props2.opacity
      ],
      resize,
      {
        deep: true
      }
    );
    vue.onMounted(resize);
    vue.onUnmounted(revokeWatermarkUrl);
    function showContent() {
      if (slots.content) {
        return true;
      }
      if (props2.content && !props2.image) {
        return true;
      }
      return false;
    }
    function imageToBase64() {
      return new Promise((resolve) => {
        const canvas = document.createElement("canvas");
        const ctx2 = canvas.getContext("2d");
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.referrerPolicy = "no-referrer";
        img.src = props2.image;
        img.onload = () => {
          canvas.width = img.width;
          canvas.height = img.height;
          ctx2.drawImage(img, 0, 0);
          resolve(canvas.toDataURL());
        };
      });
    }
    function svgToBlobUrl(svgStr) {
      const svgBlob = new Blob([svgStr], {
        type: "image/svg+xml"
      });
      return URL.createObjectURL(svgBlob);
    }
    function revokeWatermarkUrl() {
      if (watermarkUrl.value) {
        URL.revokeObjectURL(watermarkUrl.value);
      }
    }
    function resize() {
      return __async(this, null, function* () {
        textColor.value = getStyle$1(containerRef.value).color;
        if (props2.image) {
          imageUrl.value = yield imageToBase64();
        }
        yield vue.nextTick();
        revokeWatermarkUrl();
        watermarkUrl.value = svgToBlobUrl(svgRef.value.innerHTML);
      });
    }
    return {
      svgRef,
      containerRef,
      watermarkUrl,
      imageUrl,
      textColor,
      n,
      classes,
      showContent,
      resize
    };
  }
});
__sfc__.render = __render__;
var stdin_default$1 = __sfc__;
withInstall(stdin_default$1);
withPropsDefaultsSetter(stdin_default$1, props);
const _WatermarkComponent = stdin_default$1;
var stdin_default = stdin_default$1;
const version = "3.8.3";
function install(app) {
  stdin_default$5X.install && app.use(stdin_default$5X);
  stdin_default$5V.install && app.use(stdin_default$5V);
  stdin_default$5T.install && app.use(stdin_default$5T);
  stdin_default$5C.install && app.use(stdin_default$5C);
  stdin_default$5z.install && app.use(stdin_default$5z);
  stdin_default$5x.install && app.use(stdin_default$5x);
  stdin_default$5r.install && app.use(stdin_default$5r);
  stdin_default$5p.install && app.use(stdin_default$5p);
  stdin_default$5n.install && app.use(stdin_default$5n);
  stdin_default$5l.install && app.use(stdin_default$5l);
  stdin_default$5j.install && app.use(stdin_default$5j);
  stdin_default$5h.install && app.use(stdin_default$5h);
  stdin_default$5t.install && app.use(stdin_default$5t);
  stdin_default$5f.install && app.use(stdin_default$5f);
  stdin_default$5d.install && app.use(stdin_default$5d);
  stdin_default$5b.install && app.use(stdin_default$5b);
  stdin_default$5L.install && app.use(stdin_default$5L);
  stdin_default$59.install && app.use(stdin_default$59);
  stdin_default$57.install && app.use(stdin_default$57);
  stdin_default$55.install && app.use(stdin_default$55);
  stdin_default$53.install && app.use(stdin_default$53);
  stdin_default$51.install && app.use(stdin_default$51);
  stdin_default$4$.install && app.use(stdin_default$4$);
  stdin_default$4Z.install && app.use(stdin_default$4Z);
  stdin_default$66.install && app.use(stdin_default$66);
  stdin_default$4X.install && app.use(stdin_default$4X);
  stdin_default$4V.install && app.use(stdin_default$4V);
  stdin_default$4T.install && app.use(stdin_default$4T);
  stdin_default$4L.install && app.use(stdin_default$4L);
  stdin_default$4J.install && app.use(stdin_default$4J);
  stdin_default$4H.install && app.use(stdin_default$4H);
  stdin_default$4F.install && app.use(stdin_default$4F);
  stdin_default$4B.install && app.use(stdin_default$4B);
  stdin_default$4z.install && app.use(stdin_default$4z);
  stdin_default$5P.install && app.use(stdin_default$5P);
  stdin_default$4x.install && app.use(stdin_default$4x);
  stdin_default$4v.install && app.use(stdin_default$4v);
  stdin_default$5R.install && app.use(stdin_default$5R);
  stdin_default$4t.install && app.use(stdin_default$4t);
  stdin_default$62.install && app.use(stdin_default$62);
  stdin_default$60.install && app.use(stdin_default$60);
  stdin_default$5_.install && app.use(stdin_default$5_);
  stdin_default$4r.install && app.use(stdin_default$4r);
  stdin_default$4l.install && app.use(stdin_default$4l);
  stdin_default$4j.install && app.use(stdin_default$4j);
  stdin_default$4h.install && app.use(stdin_default$4h);
  stdin_default$5N.install && app.use(stdin_default$5N);
  stdin_default$5B.install && app.use(stdin_default$5B);
  stdin_default$4f.install && app.use(stdin_default$4f);
  stdin_default$4d.install && app.use(stdin_default$4d);
  stdin_default$5v.install && app.use(stdin_default$5v);
  stdin_default$4b.install && app.use(stdin_default$4b);
  stdin_default$67.install && app.use(stdin_default$67);
  stdin_default$49.install && app.use(stdin_default$49);
  stdin_default$5H.install && app.use(stdin_default$5H);
  stdin_default$5J.install && app.use(stdin_default$5J);
  stdin_default$5E.install && app.use(stdin_default$5E);
  stdin_default$47.install && app.use(stdin_default$47);
  stdin_default$45.install && app.use(stdin_default$45);
  stdin_default$43.install && app.use(stdin_default$43);
  stdin_default$41.install && app.use(stdin_default$41);
  stdin_default$3$.install && app.use(stdin_default$3$);
  stdin_default$64.install && app.use(stdin_default$64);
  stdin_default$3Z.install && app.use(stdin_default$3Z);
  stdin_default$3X.install && app.use(stdin_default$3X);
  stdin_default$3V.install && app.use(stdin_default$3V);
  stdin_default$3T.install && app.use(stdin_default$3T);
  stdin_default$3R.install && app.use(stdin_default$3R);
  stdin_default$3J.install && app.use(stdin_default$3J);
  stdin_default$63.install && app.use(stdin_default$63);
  stdin_default$3H.install && app.use(stdin_default$3H);
  stdin_default$3F.install && app.use(stdin_default$3F);
  stdin_default$3D.install && app.use(stdin_default$3D);
  stdin_default$3B.install && app.use(stdin_default$3B);
  stdin_default$3y.install && app.use(stdin_default$3y);
  stdin_default$3w.install && app.use(stdin_default$3w);
  stdin_default$3u.install && app.use(stdin_default$3u);
  stdin_default$3s.install && app.use(stdin_default$3s);
  stdin_default$4O.install && app.use(stdin_default$4O);
  stdin_default$3q.install && app.use(stdin_default$3q);
  stdin_default$4p.install && app.use(stdin_default$4p);
  stdin_default$4n.install && app.use(stdin_default$4n);
  stdin_default$3o.install && app.use(stdin_default$3o);
  stdin_default$3m.install && app.use(stdin_default$3m);
  stdin_default$3k.install && app.use(stdin_default$3k);
  stdin_default$3i.install && app.use(stdin_default$3i);
  stdin_default$3g.install && app.use(stdin_default$3g);
  stdin_default$3e.install && app.use(stdin_default$3e);
  stdin_default$7.install && app.use(stdin_default$7);
  stdin_default$4.install && app.use(stdin_default$4);
  stdin_default$4D.install && app.use(stdin_default$4D);
  stdin_default$2.install && app.use(stdin_default$2);
  stdin_default.install && app.use(stdin_default);
}
const index_bundle = {
  version,
  install,
  ActionSheet: stdin_default$5X,
  Alert: stdin_default$5V,
  AppBar: stdin_default$5T,
  AutoComplete: stdin_default$5C,
  Avatar: stdin_default$5z,
  AvatarGroup: stdin_default$5x,
  BackTop: stdin_default$5r,
  Badge: stdin_default$5p,
  BottomNavigation: stdin_default$5n,
  BottomNavigationItem: stdin_default$5l,
  Breadcrumb: stdin_default$5j,
  Breadcrumbs: stdin_default$5h,
  Button: stdin_default$5t,
  ButtonGroup: stdin_default$5f,
  Card: stdin_default$5d,
  Cell: stdin_default$5b,
  Checkbox: stdin_default$5L,
  CheckboxGroup: stdin_default$59,
  Chip: stdin_default$57,
  Code: stdin_default$55,
  Col: stdin_default$53,
  Collapse: stdin_default$51,
  CollapseItem: stdin_default$4$,
  CollapseTransition: stdin_default$4Z,
  Context: stdin_default$66,
  CountTo: stdin_default$4X,
  Countdown: stdin_default$4V,
  Counter: stdin_default$4T,
  DatePicker: stdin_default$4L,
  Dialog: stdin_default$4J,
  Divider: stdin_default$4H,
  Drag: stdin_default$4F,
  Ellipsis: stdin_default$4B,
  Fab: stdin_default$4z,
  FieldDecorator: stdin_default$5P,
  FloatingPanel: stdin_default$4x,
  Form: stdin_default$4v,
  FormDetails: stdin_default$5R,
  HighlighterProvider: stdin_default$4t,
  Hover: stdin_default$62,
  HoverOverlay: stdin_default$60,
  Icon: stdin_default$5_,
  Image: stdin_default$4r,
  ImagePreview: stdin_default$4l,
  IndexAnchor: stdin_default$4j,
  IndexBar: stdin_default$4h,
  Input: stdin_default$5N,
  Lazy: stdin_default$5B,
  Link: stdin_default$4f,
  List: stdin_default$4d,
  Loading: stdin_default$5v,
  LoadingBar: stdin_default$4b,
  Locale: stdin_default$67,
  LocaleProvider: stdin_default$49,
  Menu: stdin_default$5H,
  MenuOption: stdin_default$5J,
  MenuSelect: stdin_default$5E,
  Option: stdin_default$47,
  Overlay: stdin_default$45,
  Pagination: stdin_default$43,
  Paper: stdin_default$41,
  Picker: stdin_default$3$,
  Popup: stdin_default$64,
  Progress: stdin_default$3Z,
  PullRefresh: stdin_default$3X,
  Radio: stdin_default$3V,
  RadioGroup: stdin_default$3T,
  Rate: stdin_default$3R,
  Result: stdin_default$3J,
  Ripple: stdin_default$63,
  Row: stdin_default$3H,
  Select: stdin_default$3F,
  Skeleton: stdin_default$3D,
  Slider: stdin_default$3B,
  Snackbar: stdin_default$3y,
  Space: stdin_default$3w,
  Step: stdin_default$3u,
  Steps: stdin_default$3s,
  Sticky: stdin_default$4O,
  StyleProvider: stdin_default$3q,
  Swipe: stdin_default$4p,
  SwipeItem: stdin_default$4n,
  Switch: stdin_default$3o,
  Tab: stdin_default$3m,
  TabItem: stdin_default$3k,
  Table: stdin_default$3i,
  Tabs: stdin_default$3g,
  TabsItems: stdin_default$3e,
  Themes: stdin_default$7,
  TimePicker: stdin_default$4,
  Tooltip: stdin_default$4D,
  Uploader: stdin_default$2,
  Watermark: stdin_default
};
exports.ActionSheet = stdin_default$5X;
exports.Alert = stdin_default$5V;
exports.AppBar = stdin_default$5T;
exports.AutoComplete = stdin_default$5C;
exports.Avatar = stdin_default$5z;
exports.AvatarGroup = stdin_default$5x;
exports.BackTop = stdin_default$5r;
exports.Badge = stdin_default$5p;
exports.BottomNavigation = stdin_default$5n;
exports.BottomNavigationItem = stdin_default$5l;
exports.Breadcrumb = stdin_default$5j;
exports.Breadcrumbs = stdin_default$5h;
exports.Button = stdin_default$5t;
exports.ButtonGroup = stdin_default$5f;
exports.Card = stdin_default$5d;
exports.Cell = stdin_default$5b;
exports.Checkbox = stdin_default$5L;
exports.CheckboxGroup = stdin_default$59;
exports.Chip = stdin_default$57;
exports.Code = stdin_default$55;
exports.Col = stdin_default$53;
exports.Collapse = stdin_default$51;
exports.CollapseItem = stdin_default$4$;
exports.CollapseTransition = stdin_default$4Z;
exports.Context = stdin_default$66;
exports.CountTo = stdin_default$4X;
exports.Countdown = stdin_default$4V;
exports.Counter = stdin_default$4T;
exports.DatePicker = stdin_default$4L;
exports.Dialog = stdin_default$4J;
exports.Divider = stdin_default$4H;
exports.Drag = stdin_default$4F;
exports.Ellipsis = stdin_default$4B;
exports.Fab = stdin_default$4z;
exports.FieldDecorator = stdin_default$5P;
exports.FloatingPanel = stdin_default$4x;
exports.Form = stdin_default$4v;
exports.FormDetails = stdin_default$5R;
exports.HighlighterProvider = stdin_default$4t;
exports.Hover = stdin_default$62;
exports.HoverOverlay = stdin_default$60;
exports.Icon = stdin_default$5_;
exports.Image = stdin_default$4r;
exports.ImagePreview = stdin_default$4l;
exports.IndexAnchor = stdin_default$4j;
exports.IndexBar = stdin_default$4h;
exports.Input = stdin_default$5N;
exports.Lazy = stdin_default$5B;
exports.Link = stdin_default$4f;
exports.List = stdin_default$4d;
exports.Loading = stdin_default$5v;
exports.LoadingBar = stdin_default$4b;
exports.Locale = stdin_default$67;
exports.LocaleProvider = stdin_default$49;
exports.Menu = stdin_default$5H;
exports.MenuOption = stdin_default$5J;
exports.MenuSelect = stdin_default$5E;
exports.Option = stdin_default$47;
exports.Overlay = stdin_default$45;
exports.PIXEL = PIXEL;
exports.Pagination = stdin_default$43;
exports.Paper = stdin_default$41;
exports.Picker = stdin_default$3$;
exports.Popup = stdin_default$64;
exports.Progress = stdin_default$3Z;
exports.PullRefresh = stdin_default$3X;
exports.Radio = stdin_default$3V;
exports.RadioGroup = stdin_default$3T;
exports.Rate = stdin_default$3R;
exports.Result = stdin_default$3J;
exports.Ripple = stdin_default$63;
exports.Row = stdin_default$3H;
exports.SNACKBAR_TYPE = SNACKBAR_TYPE;
exports.Select = stdin_default$3F;
exports.Skeleton = stdin_default$3D;
exports.Slider = stdin_default$3B;
exports.Snackbar = stdin_default$3y;
exports.Space = stdin_default$3w;
exports.Step = stdin_default$3u;
exports.Steps = stdin_default$3s;
exports.Sticky = stdin_default$4O;
exports.StyleProvider = stdin_default$3q;
exports.Swipe = stdin_default$4p;
exports.SwipeItem = stdin_default$4n;
exports.Switch = stdin_default$3o;
exports.Tab = stdin_default$3m;
exports.TabItem = stdin_default$3k;
exports.Table = stdin_default$3i;
exports.Tabs = stdin_default$3g;
exports.TabsItems = stdin_default$3e;
exports.Themes = stdin_default$7;
exports.TimePicker = stdin_default$4;
exports.Tooltip = stdin_default$4D;
exports.Uploader = stdin_default$2;
exports.Watermark = stdin_default;
exports._ActionSheetComponent = _ActionSheetComponent;
exports._AlertComponent = _AlertComponent;
exports._AppBarComponent = _AppBarComponent;
exports._AutoCompleteComponent = _AutoCompleteComponent;
exports._AvatarComponent = _AvatarComponent;
exports._AvatarGroupComponent = _AvatarGroupComponent;
exports._BackTopComponent = _BackTopComponent;
exports._BadgeComponent = _BadgeComponent;
exports._BottomNavigationComponent = _BottomNavigationComponent;
exports._BottomNavigationItemComponent = _BottomNavigationItemComponent;
exports._BreadcrumbComponent = _BreadcrumbComponent;
exports._BreadcrumbsComponent = _BreadcrumbsComponent;
exports._ButtonComponent = _ButtonComponent;
exports._ButtonGroupComponent = _ButtonGroupComponent;
exports._CardComponent = _CardComponent;
exports._CellComponent = _CellComponent;
exports._CheckboxComponent = _CheckboxComponent;
exports._CheckboxGroupComponent = _CheckboxGroupComponent;
exports._ChipComponent = _ChipComponent;
exports._CodeComponent = _CodeComponent;
exports._ColComponent = _ColComponent;
exports._CollapseComponent = _CollapseComponent;
exports._CollapseItemComponent = _CollapseItemComponent;
exports._CollapseTransitionComponent = _CollapseTransitionComponent;
exports._ContextComponent = _ContextComponent;
exports._CountToComponent = _CountToComponent;
exports._CountdownComponent = _CountdownComponent;
exports._CounterComponent = _CounterComponent;
exports._DatePickerComponent = _DatePickerComponent;
exports._DialogComponent = _DialogComponent;
exports._DividerComponent = _DividerComponent;
exports._DragComponent = _DragComponent;
exports._EllipsisComponent = _EllipsisComponent;
exports._FabComponent = _FabComponent;
exports._FieldDecoratorComponent = _FieldDecoratorComponent;
exports._FloatingPanelComponent = _FloatingPanelComponent;
exports._FormComponent = _FormComponent;
exports._FormDetailsComponent = _FormDetailsComponent;
exports._HighlighterProviderComponent = _HighlighterProviderComponent;
exports._HoverComponent = _HoverComponent;
exports._HoverOverlayComponent = _HoverOverlayComponent;
exports._IconComponent = _IconComponent;
exports._ImageComponent = _ImageComponent;
exports._ImagePreviewComponent = _ImagePreviewComponent;
exports._IndexAnchorComponent = _IndexAnchorComponent;
exports._IndexBarComponent = _IndexBarComponent;
exports._InputComponent = _InputComponent;
exports._LazyComponent = _LazyComponent;
exports._LinkComponent = _LinkComponent;
exports._ListComponent = _ListComponent;
exports._LoadingBarComponent = _LoadingBarComponent;
exports._LoadingComponent = _LoadingComponent;
exports._LocaleComponent = _LocaleComponent;
exports._LocaleProviderComponent = _LocaleProviderComponent;
exports._MenuComponent = _MenuComponent;
exports._MenuOptionComponent = _MenuOptionComponent;
exports._MenuSelectComponent = _MenuSelectComponent;
exports._OptionComponent = _OptionComponent;
exports._OverlayComponent = _OverlayComponent;
exports._PaginationComponent = _PaginationComponent;
exports._PaperComponent = _PaperComponent;
exports._PickerComponent = _PickerComponent;
exports._PopupComponent = _PopupComponent;
exports._ProgressComponent = _ProgressComponent;
exports._PullRefreshComponent = _PullRefreshComponent;
exports._RadioComponent = _RadioComponent;
exports._RadioGroupComponent = _RadioGroupComponent;
exports._RateComponent = _RateComponent;
exports._ResultComponent = _ResultComponent;
exports._RippleComponent = _RippleComponent;
exports._RowComponent = _RowComponent;
exports._SelectComponent = _SelectComponent;
exports._SkeletonComponent = _SkeletonComponent;
exports._SliderComponent = _SliderComponent;
exports._SnackbarComponent = _SnackbarComponent;
exports._SpaceComponent = _SpaceComponent;
exports._StepComponent = _StepComponent;
exports._StepsComponent = _StepsComponent;
exports._StickyComponent = _StickyComponent;
exports._StyleProviderComponent = _StyleProviderComponent;
exports._SwipeComponent = _SwipeComponent;
exports._SwipeItemComponent = _SwipeItemComponent;
exports._SwitchComponent = _SwitchComponent;
exports._TabComponent = _TabComponent;
exports._TabItemComponent = _TabItemComponent;
exports._TableComponent = _TableComponent;
exports._TabsComponent = _TabsComponent;
exports._TabsItemsComponent = _TabsItemsComponent;
exports._ThemesComponent = _ThemesComponent;
exports._TimePickerComponent = _TimePickerComponent;
exports._TooltipComponent = _TooltipComponent;
exports._UploaderComponent = _UploaderComponent;
exports._WatermarkComponent = _WatermarkComponent;
exports.actionSheetProps = props$1i;
exports.add = add$2;
exports.alertProps = props$1h;
exports.appBarProps = props$1g;
exports.avatarGroupProps = props$16;
exports.avatarProps = props$17;
exports.backTopProps = props$13;
exports.badgeProps = props$12;
exports.bottomNavigationItemProps = props$10;
exports.bottomNavigationProps = props$11;
exports.breadcrumbProps = props$$;
exports.breadcrumbsProps = props$_;
exports.buttonGroupProps = props$Z;
exports.buttonProps = props$14;
exports.cardProps = props$Y;
exports.cellProps = props$X;
exports.checkboxGroupProps = props$W;
exports.checkboxProps = props$1c;
exports.chipProps = props$V;
exports.codeProps = props$U;
exports.colProps = props$T;
exports.collapseItemProps = props$R;
exports.collapseProps = props$S;
exports.collapseTransitionProps = props$Q;
exports.countToProps = props$P;
exports.countdownProps = props$O;
exports.counterProps = props$N;
exports.currentMessage = currentMessage;
exports.datePickerProps = props$M;
exports.default = index_bundle;
exports.defaultLazyOptions = defaultLazyOptions;
exports.dialogProps = props$K;
exports.dividerProps = props$J;
exports.dragProps = props$I;
exports.ellipsisProps = props$G;
exports.enUS = stdin_default$6c;
exports.faIR = stdin_default$6b;
exports.fabProps = props$F;
exports.fieldDecoratorProps = props$1e;
exports.formDetailsProps = props$1f;
exports.formProps = props$D;
exports.hoverOverlayProps = props$1k;
exports.iconProps = props$1j;
exports.imageCache = imageCache;
exports.imagePreviewProps = props$z;
exports.imageProps = props$B;
exports.indexAnchorProps = props$y;
exports.indexBarProps = props$x;
exports.inputProps = props$1d;
exports.install = install;
exports.linkProps = props$w;
exports.listProps = props$v;
exports.loadingBarProps = props$u;
exports.loadingProps = props$15;
exports.menuOptionProps = props$1b;
exports.menuProps = props$1a;
exports.menuSelectProps = props$19;
exports.merge = merge;
exports.messages = messages;
exports.optionProps = props$s;
exports.overlayProps = props$r;
exports.paginationProps = props$q;
exports.paperProps = props$p;
exports.pickerProps = props$o;
exports.popupProps = props$1l;
exports.progressProps = props$n;
exports.pullRefreshProps = props$m;
exports.radioGroupProps = props$k;
exports.radioProps = props$l;
exports.rateProps = props$j;
exports.resultProps = props$i;
exports.rowProps = props$h;
exports.selectProps = props$g;
exports.skeletonProps = props$f;
exports.sliderProps = props$e;
exports.snackbarProps = props$d;
exports.spaceProps = props$c;
exports.stepProps = props$b;
exports.stepsProps = props$a;
exports.stickyProps = props$L;
exports.styleProviderProps = props$9;
exports.swipeProps = props$A;
exports.switchProps = props$8;
exports.t = t;
exports.tabItemProps = props$6;
exports.tabProps = props$7;
exports.tableProps = props$5;
exports.tabsItemsProps = props$3;
exports.tabsProps = props$4;
exports.timePickerProps = props$2;
exports.tooltipProps = props$H;
exports.uploaderProps = props$1;
exports.use = use;
exports.useHoverOverlay = useHoverOverlay;
exports.useLocale = useLocale;
exports.version = version;
exports.watermarkProps = props;
exports.zhCN = stdin_default$6a;
exports.zhHK = stdin_default$68;
exports.zhTW = stdin_default$69;
