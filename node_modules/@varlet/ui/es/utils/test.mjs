var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
import { nextTick } from "vue";
import { getStyle, isPlainObject } from "@varlet/shared";
import { config } from "@vue/test-utils";
const delay = (time) => new Promise((resolve) => {
  setTimeout(resolve, time);
});
function getTouch(el, x, y) {
  return {
    identifier: Date.now(),
    target: el,
    pageX: x,
    pageY: y,
    clientX: x,
    clientY: y,
    radiusX: 2.5,
    radiusY: 2.5,
    rotationAngle: 10,
    force: 0.5
  };
}
function mockDoubleRaf() {
  const originMethod = window.requestAnimationFrame;
  Object.assign(window, {
    requestAnimationFrame(fn) {
      setTimeout(fn, 16);
    }
  });
  return {
    mockRestore() {
      window.requestAnimationFrame = originMethod;
    }
  };
}
function trigger(wrapper, eventName, x = 0, y = 0, offsetX = 0, offsetY = 0) {
  const el = "element" in wrapper ? wrapper.element : wrapper;
  const touchList = [getTouch(el, x, y)];
  const event = new CustomEvent(eventName, { bubbles: true, cancelable: true, detail: {} });
  Object.assign(event, {
    clientX: x,
    clientY: y,
    offsetX,
    offsetY,
    touches: touchList,
    targetTouches: eventName.startsWith("touch") ? touchList : void 0,
    changedTouches: eventName.startsWith("touch") ? touchList : void 0
  });
  el.dispatchEvent(event);
  return nextTick();
}
function triggerKeyboard(wrapper, eventName, eventInitDict = {}) {
  const el = "element" in wrapper ? wrapper.element : wrapper;
  const event = new KeyboardEvent(eventName, eventInitDict);
  el.dispatchEvent(event);
  return nextTick();
}
function mockOffset({
  offsetWidth,
  offsetHeight,
  clientWidth,
  clientHeight,
  offsetLeft,
  offsetTop
} = {}) {
  Object.defineProperties(HTMLElement.prototype, {
    offsetWidth: {
      get() {
        return offsetWidth != null ? offsetWidth : parseFloat(getStyle(this).width) || 0;
      }
    },
    offsetHeight: {
      get() {
        return offsetHeight != null ? offsetHeight : parseFloat(getStyle(this).height) || 0;
      }
    },
    clientWidth: {
      get() {
        return clientWidth != null ? clientWidth : parseFloat(getStyle(this).width) || 0;
      }
    },
    clientHeight: {
      get() {
        return clientHeight != null ? clientHeight : parseFloat(getStyle(this).height) || 0;
      }
    },
    offsetLeft: {
      get() {
        return offsetLeft != null ? offsetLeft : parseFloat(getStyle(this).marginLeft) || 0;
      }
    },
    offsetTop: {
      get() {
        return offsetTop != null ? offsetTop : parseFloat(getStyle(this).marginTop) || 0;
      }
    },
    offsetParent: {
      get() {
        var _a;
        return (_a = this.parentNode) != null ? _a : {};
      }
    }
  });
}
function mockImageNaturalSize(naturalWidth, naturalHeight) {
  Object.defineProperties(HTMLImageElement.prototype, {
    naturalWidth: {
      get() {
        return naturalWidth;
      }
    },
    naturalHeight: {
      get() {
        return naturalHeight;
      }
    }
  });
}
function triggerDrag(el, x = 0, y = 0) {
  return __async(this, null, function* () {
    yield trigger(el, "touchstart", 0, 0);
    yield trigger(el, "touchmove", x / 4, y / 4);
    yield trigger(el, "touchmove", x / 3, y / 3);
    yield trigger(el, "touchmove", x / 2, y / 2);
    yield trigger(el, "touchmove", x, y);
    yield trigger(el, "touchend", x, y);
  });
}
function mockTranslate() {
  const originMethod = window.getComputedStyle;
  const XRE = /translateX\((-?\d+)px\)/;
  const YRE = /translateY\(-?(\d+)px\)/;
  Object.assign(window, {
    getComputedStyle: (el) => {
      var _a, _b, _c, _d;
      const styles = originMethod.call(window, el);
      const x = (_b = (_a = el.style.transform.match(XRE)) == null ? void 0 : _a[1]) != null ? _b : 0;
      const y = (_d = (_c = el.style.transform.match(YRE)) == null ? void 0 : _c[1]) != null ? _d : 0;
      styles.transform = `matrix(1, 0, 0, 1, ${x}, ${y})`;
      return styles;
    }
  });
  return {
    mockRestore() {
      window.getComputedStyle = originMethod;
    }
  };
}
function mockFileReader(url) {
  const originMethod = window.FileReader;
  class FileReader {
    constructor() {
      __publicField(this, "result", "");
    }
    onload() {
    }
    readAsDataURL() {
      this.result = url;
      this.onload();
    }
  }
  Object.assign(window, {
    FileReader
  });
  return {
    mockRestore() {
      window.FileReader = originMethod;
    }
  };
}
function mockStubs() {
  const originStubs = config.global.stubs;
  config.global.stubs = {};
  return {
    mockRestore() {
      config.global.stubs = originStubs;
    }
  };
}
function mockConsole(method, fn = () => {
}) {
  const originMethod = console[method];
  console[method] = fn;
  return {
    mockRestore() {
      console[method] = originMethod;
    }
  };
}
function mockScrollTo() {
  Object.assign(window, { scrollTo() {
  } });
  Object.defineProperty(Element.prototype, "scrollTo", {
    value(x, y) {
      if (isPlainObject(x)) {
        this.scrollLeft = x.left;
        this.scrollTop = x.top;
      } else {
        this.scrollLeft = x;
        this.scrollTop = y;
      }
    }
  });
}
function mockScrollIntoView() {
  Object.defineProperty(Element.prototype, "scrollIntoView", {
    value() {
    }
  });
}
function mockUserAgent(userAgent) {
  const originUserAgent = navigator.userAgent;
  Object.defineProperty(window.navigator, "userAgent", {
    configurable: true,
    get() {
      return userAgent;
    }
  });
  return {
    restore() {
      Object.defineProperty(window.navigator, "userAgent", {
        configurable: true,
        get() {
          return originUserAgent;
        }
      });
    }
  };
}
function mockCanvas() {
  Object.defineProperties(HTMLCanvasElement.prototype, {
    getContext: {
      value() {
        return {
          drawImage() {
          }
        };
      }
    },
    toDataURL: {
      value() {
        return "mock data url";
      }
    }
  });
}
export {
  delay,
  getTouch,
  mockCanvas,
  mockConsole,
  mockDoubleRaf,
  mockFileReader,
  mockImageNaturalSize,
  mockOffset,
  mockScrollIntoView,
  mockScrollTo,
  mockStubs,
  mockTranslate,
  mockUserAgent,
  trigger,
  triggerDrag,
  triggerKeyboard
};
